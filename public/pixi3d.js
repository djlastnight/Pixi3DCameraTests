(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("pixi.js"));
	else if(typeof define === 'function' && define.amd)
		define("PIXI3D", ["pixi.js"], factory);
	else if(typeof exports === 'object')
		exports["PIXI3D"] = factory(require("pixi.js"));
	else
		root["PIXI3D"] = factory(root["PIXI"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_pixi_js__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/index.js ***!
  \*********************************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ "./node_modules/gl-matrix/esm/mat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ "./node_modules/gl-matrix/esm/mat2d.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ "./node_modules/gl-matrix/esm/quat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ "./node_modules/gl-matrix/esm/vec2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });












/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2d.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2d.js ***!
  \*********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, getAngle, multiply, rotateX, rotateY, rotateZ, calculateW, exp, ln, pow, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ln", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat2.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat2.js ***!
  \*********************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArray", function() { return __spreadArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || from);
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}


/***/ }),

/***/ "./src/animation.ts":
/*!**************************!*\
  !*** ./src/animation.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Animation = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
/**
 * Represents an animation.
 */
var Animation = /** @class */ (function (_super) {
    tslib_1.__extends(Animation, _super);
    /**
     * Creates a new animation with the specified name.
     * @param name Name for the animation.
     */
    function Animation(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        /** The speed that the animation will play at. */
        _this.speed = 1;
        /** A value indicating if the animation is looping. */
        _this.loop = false;
        return _this;
    }
    /**
     * Starts playing the animation using the specified ticker.
     * @param ticker The ticker to use for updating the animation. If a ticker
     * is not given, the shared ticker will be used.
     */
    Animation.prototype.play = function (ticker) {
        var _this = this;
        if (ticker === void 0) { ticker = PIXI.Ticker.shared; }
        this.position = 0;
        if (!this._ticker) {
            this._update = function () {
                _this.update(ticker.deltaMS / 1000 * _this.speed);
            };
            this._ticker = ticker.add(this._update);
        }
    };
    /**
     * Stops playing the animation.
     */
    Animation.prototype.stop = function () {
        if (this._ticker && this._update) {
            this._ticker.remove(this._update);
            this._ticker = this._update = undefined;
        }
    };
    /**
     * Updates the animation by the specified delta time.
     * @param delta The time in seconds since last frame.
     */
    Animation.prototype.update = function (delta) {
        this.position += delta;
        if (this.position < this.duration) {
            return;
        }
        if (this.loop) {
            if (this.position > this.duration) {
                this.position = this.position % this.duration;
            }
        }
        else {
            this.position = this.duration;
            this.stop();
        }
        this.emit("complete");
    };
    return Animation;
}(PIXI.utils.EventEmitter));
exports.Animation = Animation;


/***/ }),

/***/ "./src/camera/camera-orbit-control.ts":
/*!********************************************!*\
  !*** ./src/camera/camera-orbit-control.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraOrbitControl = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var camera_1 = __webpack_require__(/*! ./camera */ "./src/camera/camera.ts");
var quat_1 = __webpack_require__(/*! ../math/quat */ "./src/math/quat.ts");
var vec3_1 = __webpack_require__(/*! ../math/vec3 */ "./src/math/vec3.ts");
/**
 * Allows the user to control the camera by orbiting the target.
 */
var CameraOrbitControl = /** @class */ (function () {
    /**
     * Creates a new camera orbit control.
     * @param element The element for listening to user events.
     * @param camera The camera to control. If not set, the main camera will be used
     * by default.
     */
    function CameraOrbitControl(element, camera) {
        var _this = this;
        if (camera === void 0) { camera = camera_1.Camera.main; }
        this.camera = camera;
        this._distance = 5;
        this._grabbed = false;
        this._angles = new PIXI.ObservablePoint(function () {
            _this._angles.x = Math.min(Math.max(-85, _this._angles.x), 85);
        }, undefined, 0, 180);
        /** Target position (x, y, z) to orbit. */
        this.target = { x: 0, y: 0, z: 0 };
        /** Allows the camera to be controlled by user. */
        this.allowControl = true;
        this.camera.renderer.on("prerender", function () {
            _this.updateCamera();
        });
        this.camera.renderer.plugins.interaction.on("mousedown", function (e) {
            if (!e.stopped) {
                _this._grabbed = true;
            }
        });
        element.addEventListener("mouseup", function () {
            _this._grabbed = false;
        });
        element.addEventListener("mousemove", function (event) {
            if (_this.allowControl && event.buttons === 1 && _this._grabbed) {
                _this._angles.x += event.movementY * 0.5;
                _this._angles.y -= event.movementX * 0.5;
            }
        });
        element.addEventListener("mousewheel", function (event) {
            if (_this.allowControl) {
                _this.distance += event.deltaY * 0.01;
                event.preventDefault();
            }
        });
    }
    Object.defineProperty(CameraOrbitControl.prototype, "angles", {
        /**
         * Orientation euler angles (x-axis and y-axis). The angle for the x-axis
         * will be clamped between -85 and 85 degrees.
         */
        get: function () {
            return this._angles;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Updates the position and rotation of the camera.
     */
    CameraOrbitControl.prototype.updateCamera = function () {
        var rot = quat_1.Quat.fromEuler(this._angles.x, this._angles.y, 0, new Float32Array(4));
        var dir = vec3_1.Vec3.transformQuat(vec3_1.Vec3.set(0, 0, 1, new Float32Array(3)), rot, new Float32Array(3));
        var pos = vec3_1.Vec3.subtract(vec3_1.Vec3.set(this.target.x, this.target.y, this.target.z, new Float32Array(3)), vec3_1.Vec3.scale(dir, this.distance, new Float32Array(3)), new Float32Array(3));
        this.camera.position.set(pos[0], pos[1], pos[2]);
        this.camera.rotationQuaternion.set(rot[0], rot[1], rot[2], rot[3]);
    };
    Object.defineProperty(CameraOrbitControl.prototype, "distance", {
        /**
         * Distance between camera and the target. Default value is 5.
         */
        get: function () {
            return this._distance;
        },
        set: function (value) {
            this._distance = Math.min(Math.max(value, 0.01), Number.MAX_SAFE_INTEGER);
        },
        enumerable: false,
        configurable: true
    });
    return CameraOrbitControl;
}());
exports.CameraOrbitControl = CameraOrbitControl;


/***/ }),

/***/ "./src/camera/camera.ts":
/*!******************************!*\
  !*** ./src/camera/camera.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Camera = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var container_1 = __webpack_require__(/*! ../container */ "./src/container.ts");
var mat4_1 = __webpack_require__(/*! ../math/mat4 */ "./src/math/mat4.ts");
var ray_1 = __webpack_require__(/*! ../math/ray */ "./src/math/ray.ts");
var vec3_1 = __webpack_require__(/*! ../math/vec3 */ "./src/math/vec3.ts");
var vec4_1 = __webpack_require__(/*! ../math/vec4 */ "./src/math/vec4.ts");
var matrix_component_1 = __webpack_require__(/*! ../transform/matrix-component */ "./src/transform/matrix-component.ts");
var observable_point_1 = __webpack_require__(/*! ../transform/observable-point */ "./src/transform/observable-point.ts");
var vec3 = new Float32Array(3);
var mat4 = new Float32Array(16);
var vec4 = new Float32Array(4);
/**
 * Camera is a device from which the world is viewed.
 */
var Camera = /** @class */ (function (_super) {
    tslib_1.__extends(Camera, _super);
    /**
     * Creates a new camera using the specified renderer. By default the camera
     * looks towards negative z and is positioned at z = 5.
     * @param renderer Renderer to use.
     */
    function Camera(renderer) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this._transformId = 0;
        _this._orthographic = false;
        _this._orthographicSize = 10;
        _this._fieldOfView = 60;
        _this._near = 0.1;
        _this._far = 1000;
        var aspect = renderer.width / renderer.height;
        var localID = -1;
        _this.renderer.on("prerender", function () {
            if (!_this._aspect) {
                // When there is no specific aspect set, this is used for the 
                // projection matrix to always update each frame (in case when the 
                // renderer aspect ratio has changed).
                if (renderer.width / renderer.height !== aspect) {
                    _this._transformId++;
                    aspect = renderer.width / renderer.height;
                }
            }
            // @ts-ignore: _localID do exist, but be careful if this changes.
            if (!_this.parent && localID !== _this.transform._localID) {
                // When the camera is not attached to the scene hierarchy the transform 
                // needs to be updated manually.
                _this.transform.updateTransform();
                // @ts-ignore: _localID do exist, but be careful if this changes.
                localID = _this.transform._localID;
            }
        });
        if (!Camera.main) {
            Camera.main = _this;
        }
        _this.transform.position.z = 5;
        _this.transform.rotationQuaternion.setEulerAngles(0, 180, 0);
        return _this;
    }
    Object.defineProperty(Camera.prototype, "transformId", {
        get: function () {
            return this.transform._worldID + this._transformId;
        },
        enumerable: false,
        configurable: true
    });
    Camera.prototype.destroy = function (options) {
        _super.prototype.destroy.call(this, options);
        if (this === Camera.main) {
            // @ts-ignore It's ok, main camera was destroyed.
            Camera.main = undefined;
        }
    };
    Object.defineProperty(Camera.prototype, "orthographicSize", {
        /**
         * The camera's half-size when in orthographic mode. The visible area from
         * center of the screen to the top.
         */
        get: function () {
            return this._orthographicSize;
        },
        set: function (value) {
            if (this._orthographicSize !== value) {
                this._orthographicSize = value;
                this._transformId++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "orthographic", {
        /**
         * Camera will render objects uniformly, with no sense of perspective.
         */
        get: function () {
            return this._orthographic;
        },
        set: function (value) {
            if (this._orthographic !== value) {
                this._orthographic = value;
                this._transformId++;
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Converts screen coordinates to a ray.
     * @param x Screen x coordinate.
     * @param y Screen y coordinate.
     * @param viewSize The size of the view when not rendering to the entire screen.
     */
    Camera.prototype.screenToRay = function (x, y, viewSize) {
        if (viewSize === void 0) { viewSize = this.renderer.screen; }
        var screen = this.screenToWorld(x, y, 1, undefined, viewSize);
        if (screen) {
            return new ray_1.Ray(this.worldTransform.position, vec3_1.Vec3.subtract(screen.array, this.worldTransform.position, vec3));
        }
    };
    /**
     * Converts screen coordinates to world coordinates.
     * @param x Screen x coordinate.
     * @param y Screen y coordinate.
     * @param distance Distance from the camera.
     * @param point Point to set.
     * @param viewSize The size of the view when not rendering to the entire screen.
     */
    Camera.prototype.screenToWorld = function (x, y, distance, point, viewSize) {
        var _a;
        if (point === void 0) { point = new observable_point_1.ObservablePoint3D(function () { }, undefined); }
        if (viewSize === void 0) { viewSize = this.renderer.screen; }
        // Make sure the transform is updated in case something has been changed, 
        // otherwise it may be using wrong values.
        this.transform.updateTransform((_a = this.parent) === null || _a === void 0 ? void 0 : _a.transform);
        var far = this.far;
        // Before doing the calculations, the far clip plane is changed to the same 
        // value as distance from the camera. By doing this we can just set z value 
        // for the clip space to 1 and the desired z position will be correct.
        this.far = distance;
        var invertedViewProjection = mat4_1.Mat4.invert(this.viewProjection, mat4);
        if (invertedViewProjection === null) {
            return;
        }
        var clipSpace = vec4_1.Vec4.set((x / viewSize.width) * 2 - 1, ((y / viewSize.height) * 2 - 1) * -1, 1, 1, vec4);
        this.far = far;
        var worldSpace = vec4_1.Vec4.transformMat4(clipSpace, invertedViewProjection, vec4);
        worldSpace[3] = 1.0 / worldSpace[3];
        for (var i = 0; i < 3; i++) {
            worldSpace[i] *= worldSpace[3];
        }
        return point.set(worldSpace[0], worldSpace[1], worldSpace[2]);
    };
    /**
     * Converts world coordinates to screen coordinates.
     * @param x World x coordinate.
     * @param y World y coordinate.
     * @param z World z coordinate.
     * @param point Point to set.
     * @param viewSize The size of the view when not rendering to the entire screen.
     */
    Camera.prototype.worldToScreen = function (x, y, z, point, viewSize) {
        var _a;
        if (point === void 0) { point = new PIXI.Point(); }
        if (viewSize === void 0) { viewSize = this.renderer.screen; }
        // Make sure the transform is updated in case something has been changed, 
        // otherwise it may be using wrong values.
        this.transform.updateTransform((_a = this.parent) === null || _a === void 0 ? void 0 : _a.transform);
        var worldSpace = vec4_1.Vec4.set(x, y, z, 1, vec4);
        var clipSpace = vec4_1.Vec4.transformMat4(vec4_1.Vec4.transformMat4(worldSpace, this.view, vec4), this.projection, vec4);
        if (clipSpace[3] !== 0) {
            for (var i = 0; i < 3; i++) {
                clipSpace[i] /= clipSpace[3];
            }
        }
        return point.set((clipSpace[0] + 1) / 2 * viewSize.width, viewSize.height - (clipSpace[1] + 1) / 2 * viewSize.height);
    };
    Object.defineProperty(Camera.prototype, "aspect", {
        /**
         * The aspect ratio (width divided by height). If not set, the aspect ratio of
         * the renderer will be used by default.
         */
        get: function () {
            return this._aspect;
        },
        set: function (value) {
            if (this._aspect !== value) {
                this._aspect = value;
                this._transformId++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "fieldOfView", {
        /** The vertical field of view in degrees, 60 is the default value. */
        get: function () {
            return this._fieldOfView;
        },
        set: function (value) {
            if (this._fieldOfView !== value) {
                this._fieldOfView = value;
                this._transformId++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "near", {
        /** The near clipping plane distance, 0.1 is the default value. */
        get: function () {
            return this._near;
        },
        set: function (value) {
            if (this._near !== value) {
                this._near = value;
                this._transformId++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "far", {
        /** The far clipping plane distance, 1000 is the default value. */
        get: function () {
            return this._far;
        },
        set: function (value) {
            if (this._far !== value) {
                this._far = value;
                this._transformId++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "projection", {
        /** Returns the projection matrix. */
        get: function () {
            var _this = this;
            if (!this._projection) {
                this._projection = new matrix_component_1.MatrixComponent(this, 16, function (data) {
                    var aspect = _this._aspect || _this.renderer.width / _this.renderer.height;
                    if (_this._orthographic) {
                        mat4_1.Mat4.ortho(-_this._orthographicSize * aspect, _this._orthographicSize * aspect, -_this._orthographicSize, _this._orthographicSize, _this._near, _this._far, data);
                    }
                    else {
                        mat4_1.Mat4.perspective(_this._fieldOfView * PIXI.DEG_TO_RAD, aspect, _this._near, _this._far, data);
                    }
                });
            }
            return this._projection.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "view", {
        /** Returns the view matrix. */
        get: function () {
            var _this = this;
            if (!this._view) {
                this._view = new matrix_component_1.MatrixComponent(this, 16, function (data) {
                    var target = vec3_1.Vec3.add(_this.worldTransform.position, _this.worldTransform.forward, vec3);
                    mat4_1.Mat4.lookAt(_this.worldTransform.position, target, _this.worldTransform.up, data);
                });
            }
            return this._view.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "viewProjection", {
        /** Returns the view projection matrix. */
        get: function () {
            var _this = this;
            if (!this._viewProjection) {
                this._viewProjection = new matrix_component_1.MatrixComponent(this, 16, function (data) {
                    mat4_1.Mat4.multiply(_this.projection, _this.view, data);
                });
            }
            return this._viewProjection.array;
        },
        enumerable: false,
        configurable: true
    });
    return Camera;
}(container_1.Container3D));
exports.Camera = Camera;
PIXI.Renderer.registerPlugin("camera", Camera);


/***/ }),

/***/ "./src/color.ts":
/*!**********************!*\
  !*** ./src/color.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Color = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * Represents a color containing RGBA components.
 */
var Color = /** @class */ (function () {
    /**
     * Creates a new color with the specified components (in range 0-1).
     * @param r The R (red) component.
     * @param g The G (green) component.
     * @param b The B (blue) component.
     * @param a The A (alpha) component.
     */
    function Color(r, g, b, a) {
        if (r === void 0) { r = 0; }
        if (g === void 0) { g = 0; }
        if (b === void 0) { b = 0; }
        if (a === void 0) { a = 1; }
        this._array4 = new Float32Array([r, g, b, a]);
        this._array3 = this._array4.subarray(0, 3);
    }
    /**
     * Creates a new color with the specified components (in range 0-255).
     * @param r The R (red) component.
     * @param g The G (green) component.
     * @param b The B (blue) component.
     * @param a The A (alpha) component.
     */
    Color.fromBytes = function (r, g, b, a) {
        if (r === void 0) { r = 0; }
        if (g === void 0) { g = 0; }
        if (b === void 0) { b = 0; }
        if (a === void 0) { a = 255; }
        return new Color(r / 255, g / 255, b / 255, a / 255);
    };
    /**
     * Creates a new color from the specified hex value.
     * @param hex The hex value as a string or a number.
     */
    Color.fromHex = function (hex) {
        if (typeof hex === "string") {
            hex = parseInt(hex.replace(/[^0-9A-F]/gi, ""), 16);
        }
        return Color.fromBytes((hex >> 16) & 255, (hex >> 8) & 255, hex & 255);
    };
    Object.defineProperty(Color.prototype, "rgb", {
        /** The color as an typed array containing RGB. */
        get: function () {
            return this._array3;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "rgba", {
        /** The color as an typed array containing RGBA. */
        get: function () {
            return this._array4;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "r", {
        /** The R (red) component. */
        get: function () {
            return this._array4[0];
        },
        set: function (value) {
            this._array4[0] = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "g", {
        /** The G (green) component. */
        get: function () {
            return this._array4[1];
        },
        set: function (value) {
            this._array4[1] = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "b", {
        /** The B (blue) component. */
        get: function () {
            return this._array4[2];
        },
        set: function (value) {
            this._array4[2] = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "a", {
        /** The A (alpha) component. */
        get: function () {
            return this._array4[3];
        },
        set: function (value) {
            this._array4[3] = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new color from the specified source.
     * @param source The source to create the color from.
     */
    Color.from = function (source) {
        return new (Color.bind.apply(Color, tslib_1.__spreadArray([void 0], tslib_1.__read(source))))();
    };
    return Color;
}());
exports.Color = Color;


/***/ }),

/***/ "./src/console.ts":
/*!************************!*\
  !*** ./src/console.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Console = void 0;
var Console;
(function (Console) {
    var messages = [];
    function error(message) {
        if (messages.includes(message)) {
            return;
        }
        messages.push(message);
        console.error(message);
    }
    Console.error = error;
})(Console = exports.Console || (exports.Console = {}));


/***/ }),

/***/ "./src/container.ts":
/*!**************************!*\
  !*** ./src/container.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Container3D = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var transform_1 = __webpack_require__(/*! ./transform/transform */ "./src/transform/transform.ts");
/**
 * A container represents a collection of 3D objects.
 */
var Container3D = /** @class */ (function (_super) {
    tslib_1.__extends(Container3D, _super);
    function Container3D() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.transform = new transform_1.Transform3D();
        return _this;
    }
    Object.defineProperty(Container3D.prototype, "position", {
        get: function () {
            return this.transform.position;
        },
        set: function (value) {
            this.transform.position.copyFrom(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Container3D.prototype, "scale", {
        get: function () {
            return this.transform.scale;
        },
        set: function (value) {
            this.transform.scale.copyFrom(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Container3D.prototype, "rotationQuaternion", {
        /** The quaternion rotation of the object. */
        get: function () {
            return this.transform.rotationQuaternion;
        },
        set: function (value) {
            this.transform.rotationQuaternion.copyFrom(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Container3D.prototype, "z", {
        /** The position of the object on the z axis relative to the local
         * coordinates of the parent. */
        get: function () {
            return this.transform.position.z;
        },
        set: function (value) {
            this.transform.position.z = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Container3D.prototype, "localTransform", {
        get: function () {
            return this.transform.localTransform;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Container3D.prototype, "worldTransform", {
        get: function () {
            return this.transform.worldTransform;
        },
        enumerable: false,
        configurable: true
    });
    return Container3D;
}(PIXI.Container));
exports.Container3D = Container3D;


/***/ }),

/***/ "./src/cubemap/cubemap-resource.ts":
/*!*****************************************!*\
  !*** ./src/cubemap/cubemap-resource.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CubemapResource = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var cube_resource_1 = __webpack_require__(/*! ../pixi/cube-resource */ "./src/pixi/cube-resource.ts");
var CubemapResource = /** @class */ (function (_super) {
    tslib_1.__extends(CubemapResource, _super);
    function CubemapResource(source, levels) {
        if (levels === void 0) { levels = 1; }
        var _this = _super.call(this, source) || this;
        _this.levels = levels;
        return _this;
    }
    CubemapResource.prototype.style = function (renderer) {
        var gl = renderer.gl;
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (this.levels > 1) {
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        }
        else {
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }
        return true;
    };
    return CubemapResource;
}(cube_resource_1.CubeResource));
exports.CubemapResource = CubemapResource;


/***/ }),

/***/ "./src/cubemap/cubemap.ts":
/*!********************************!*\
  !*** ./src/cubemap/cubemap.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Cubemap = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var mipmap_resource_1 = __webpack_require__(/*! ./mipmap-resource */ "./src/cubemap/mipmap-resource.ts");
var cubemap_resource_1 = __webpack_require__(/*! ./cubemap-resource */ "./src/cubemap/cubemap-resource.ts");
var buffer_resource_1 = __webpack_require__(/*! ../pixi/buffer-resource */ "./src/pixi/buffer-resource.ts");
/**
 * Cubemap which supports multiple user specified mipmaps.
 */
var Cubemap = /** @class */ (function (_super) {
    tslib_1.__extends(Cubemap, _super);
    function Cubemap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Cubemap, "faces", {
        /** Returns an array of faces. */
        get: function () {
            return ["posx", "negx", "posy", "negy", "posz", "negz"];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Cubemap.prototype, "levels", {
        /** Returns the number of mipmap levels. */
        get: function () {
            return this.resource.levels;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new cubemap from the specified faces.
     * @param faces The faces to create the cubemap from.
     */
    Cubemap.fromFaces = function (faces) {
        var array = Array.isArray(faces) ? faces : [faces];
        var resources = Cubemap.faces.map(function (face, index) {
            return new mipmap_resource_1.MipmapResource(array.map(function (f) { return f[face]; }), PIXI.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index);
        });
        return new Cubemap(new cubemap_resource_1.CubemapResource(resources, array.length));
    };
    /**
     * Creates a new cubemap from the specified colors.
     * @param posx The color for positive x.
     * @param negx The color for negative x.
     * @param posy The color for positive y.
     * @param negy The color for negative y.
     * @param posz The color for positive z.
     * @param negz The color for negative z.
     */
    Cubemap.fromColors = function (posx, negx, posy, negy, posz, negz) {
        if (negx === void 0) { negx = posx; }
        if (posy === void 0) { posy = posx; }
        if (negy === void 0) { negy = posx; }
        if (posz === void 0) { posz = posx; }
        if (negz === void 0) { negz = posx; }
        var resources = [];
        var colors = [posx, negx, posy, negy, posz, negz];
        for (var i = 0; i < colors.length; i++) {
            var resource = new buffer_resource_1.BufferResource(new Uint8Array(colors[i].rgba.map(function (c) { return c * 255; })), { width: 1, height: 1 });
            var texture = new PIXI.Texture(new PIXI.BaseTexture(resource, {
                type: PIXI.TYPES.UNSIGNED_BYTE,
                format: PIXI.FORMATS.RGB,
                alphaMode: PIXI.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
            }));
            resources.push(new mipmap_resource_1.MipmapResource([texture], PIXI.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i));
        }
        return new Cubemap(new cubemap_resource_1.CubemapResource(resources, 1));
    };
    return Cubemap;
}(PIXI.BaseTexture));
exports.Cubemap = Cubemap;


/***/ }),

/***/ "./src/cubemap/mipmap-resource.ts":
/*!****************************************!*\
  !*** ./src/cubemap/mipmap-resource.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MipmapResource = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var array_resource_1 = __webpack_require__(/*! ../pixi/array-resource */ "./src/pixi/array-resource.ts");
var base_image_resource_1 = __webpack_require__(/*! ../pixi/base-image-resource */ "./src/pixi/base-image-resource.ts");
var buffer_resource_1 = __webpack_require__(/*! ../pixi/buffer-resource */ "./src/pixi/buffer-resource.ts");
var MipmapResource = /** @class */ (function (_super) {
    tslib_1.__extends(MipmapResource, _super);
    function MipmapResource(source, target) {
        var _this = _super.call(this, source) || this;
        _this.target = target;
        return _this;
    }
    MipmapResource.prototype.upload = function (renderer, baseTexture) {
        for (var i = 0; i < this.items.length; i++) {
            var resource = this.items[i].resource;
            if (resource instanceof buffer_resource_1.BufferResource) {
                renderer.gl.texImage2D(this.target, i, baseTexture.format, resource.width, resource.height, 0, baseTexture.format, baseTexture.type, resource.data);
            }
            if (resource instanceof base_image_resource_1.BaseImageResource) {
                renderer.gl.texImage2D(this.target, i, baseTexture.format, baseTexture.format, baseTexture.type, resource.source);
            }
        }
        return true;
    };
    return MipmapResource;
}(array_resource_1.ArrayResource));
exports.MipmapResource = MipmapResource;


/***/ }),

/***/ "./src/gltf/animation/gltf-animation.ts":
/*!**********************************************!*\
  !*** ./src/gltf/animation/gltf-animation.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFAnimation = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var animation_1 = __webpack_require__(/*! ../../animation */ "./src/animation.ts");
/**
 * Represents an animation loaded from a glTF model.
 */
var glTFAnimation = /** @class */ (function (_super) {
    tslib_1.__extends(glTFAnimation, _super);
    /**
     * Creates a new glTF animation.
     * @param channels The channels used by this animation.
     * @param name The name for the animation.
     */
    function glTFAnimation(channels, name) {
        var e_1, _a;
        var _this = _super.call(this, name) || this;
        _this._duration = 0;
        _this._position = 0;
        _this._channels = [];
        try {
            for (var channels_1 = tslib_1.__values(channels), channels_1_1 = channels_1.next(); !channels_1_1.done; channels_1_1 = channels_1.next()) {
                var channel = channels_1_1.value;
                _this._duration = Math.max(_this._duration, channel.duration);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (channels_1_1 && !channels_1_1.done && (_a = channels_1.return)) _a.call(channels_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        _this._channels = channels;
        return _this;
    }
    Object.defineProperty(glTFAnimation.prototype, "duration", {
        /** The duration (in seconds) of this animation. */
        get: function () {
            return this._duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(glTFAnimation.prototype, "position", {
        /** The current position (in seconds) of this animation. */
        get: function () {
            return this._position;
        },
        set: function (value) {
            var e_2, _a;
            this._position = value;
            try {
                for (var _b = tslib_1.__values(this._channels), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var channel = _c.value;
                    channel.position = this._position;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        },
        enumerable: false,
        configurable: true
    });
    return glTFAnimation;
}(animation_1.Animation));
exports.glTFAnimation = glTFAnimation;


/***/ }),

/***/ "./src/gltf/animation/gltf-channel.ts":
/*!********************************************!*\
  !*** ./src/gltf/animation/gltf-channel.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFChannel = void 0;
/**
 * Represents an glTF animation channel which targets a specific node.
 */
var glTFChannel = /** @class */ (function () {
    /**
     * Creates a new channel with the specified input and interpolation.
     * @param input An array of inputs representing linear time in seconds.
     * @param interpolation The interpolation method to use.
     */
    function glTFChannel(input, interpolation) {
        this._position = 0;
        this._frame = 0;
        this._input = input;
        this._interpolation = interpolation;
    }
    Object.defineProperty(glTFChannel.prototype, "position", {
        /** The position (in seconds) for this channel. */
        get: function () {
            return this._position;
        },
        set: function (value) {
            this.setPosition(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(glTFChannel.prototype, "duration", {
        /** The duration (in seconds) for this channel. */
        get: function () {
            return this._input[this._input.length - 1];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(glTFChannel.prototype, "frame", {
        /** The current frame for this channel. */
        get: function () {
            return this._frame;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(glTFChannel.prototype, "length", {
        /** The number of frames for this channel. */
        get: function () {
            return this._input.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the position and updates the current frame and animation.
     * @param position The position to set for this channel.
     */
    glTFChannel.prototype.setPosition = function (position) {
        this._position = position;
        this._frame = this.calculateFrame(this._position);
        this.updateTarget(this._interpolation.interpolate(this._frame, this.calculateFramePosition(this._frame, this._position)));
    };
    /**
     * Updates the channel with the specified delta time in seconds.
     * @param delta The time (in seconds) since last frame.
     */
    glTFChannel.prototype.update = function (delta) {
        this.position += delta;
    };
    /**
     * Calculates the position within the specified frame.
     * @param frame The frame to calculate the position in.
     * @param position The position of this channel.
     */
    glTFChannel.prototype.calculateFramePosition = function (frame, position) {
        if (frame === this._input.length - 1) {
            return 1;
        }
        return (position - this._input[frame]) / (this._input[frame + 1] - this._input[frame]);
    };
    /**
     * Calculates the current frame for the specified position.
     * @param position The position of this channel.
     */
    glTFChannel.prototype.calculateFrame = function (position) {
        if (position < this._input[0]) {
            return 0;
        }
        for (var i = 0; i < this._input.length - 1; i++) {
            if (position >= this._input[i] && position < this._input[i + 1]) {
                return i;
            }
        }
        return this._input.length - 1;
    };
    glTFChannel.from = function (input, output, interpolation, path, target) {
        if (path === "translation") {
            return new gltf_translation_1.glTFTranslation(target.transform, input, gltf_interpolation_1.glTFInterpolation.from(interpolation, input, output, 3));
        }
        if (path === "scale") {
            return new gltf_scale_1.glTFScale(target.transform, input, gltf_interpolation_1.glTFInterpolation.from(interpolation, input, output, 3));
        }
        if (path === "rotation") {
            if (interpolation === "LINEAR") {
                return new gltf_rotation_1.glTFRotation(target.transform, input, new gltf_spherical_linear_1.glTFSphericalLinear(output));
            }
            return new gltf_rotation_1.glTFRotation(target.transform, input, gltf_interpolation_1.glTFInterpolation.from(interpolation, input, output, 4));
        }
        if (path === "weights") {
            var weights = target.children[0].morphWeights;
            if (!weights) {
                return undefined;
            }
            return new gltf_weights_1.glTFWeights(weights, input, gltf_interpolation_1.glTFInterpolation.from(interpolation, input, output, weights.length));
        }
        throw new Error("PIXI3D: Unknown channel path \"" + path + "\"");
    };
    return glTFChannel;
}());
exports.glTFChannel = glTFChannel;
var gltf_interpolation_1 = __webpack_require__(/*! ./gltf-interpolation */ "./src/gltf/animation/gltf-interpolation.ts");
var gltf_spherical_linear_1 = __webpack_require__(/*! ./gltf-spherical-linear */ "./src/gltf/animation/gltf-spherical-linear.ts");
var gltf_scale_1 = __webpack_require__(/*! ./gltf-scale */ "./src/gltf/animation/gltf-scale.ts");
var gltf_weights_1 = __webpack_require__(/*! ./gltf-weights */ "./src/gltf/animation/gltf-weights.ts");
var gltf_rotation_1 = __webpack_require__(/*! ./gltf-rotation */ "./src/gltf/animation/gltf-rotation.ts");
var gltf_translation_1 = __webpack_require__(/*! ./gltf-translation */ "./src/gltf/animation/gltf-translation.ts");


/***/ }),

/***/ "./src/gltf/animation/gltf-cubic-spline.ts":
/*!*************************************************!*\
  !*** ./src/gltf/animation/gltf-cubic-spline.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFCubicSpline = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_interpolation_1 = __webpack_require__(/*! ./gltf-interpolation */ "./src/gltf/animation/gltf-interpolation.ts");
var glTFCubicSpline = /** @class */ (function (_super) {
    tslib_1.__extends(glTFCubicSpline, _super);
    function glTFCubicSpline(_input, _output, _stride) {
        var _this = _super.call(this) || this;
        _this._input = _input;
        _this._output = _output;
        _this._stride = _stride;
        _this._data = new Float32Array(_stride);
        return _this;
    }
    glTFCubicSpline.prototype.interpolate = function (frame, position) {
        var diff = this._input[frame + 1] - this._input[frame];
        var pos1 = (frame + 0) * this._stride * 3;
        var pos2 = (frame + 1) * this._stride * 3;
        for (var i = 0; i < this._stride; i++) {
            this._data[i] = glTFCubicSpline.calculate(position, this._output[pos1 + i + 1 * this._stride], this._output[pos2 + i + 1 * this._stride], diff * this._output[pos2 + i], diff * this._output[pos1 + i + 2 * this._stride]);
        }
        return this._data;
    };
    glTFCubicSpline.calculate = function (t, p0, p1, m0, m1) {
        return ((2 * (Math.pow(t, 3)) - 3 * (Math.pow(t, 2)) + 1) * p0) + (((Math.pow(t, 3)) - 2 * (Math.pow(t, 2)) + t) * m0) + ((-2 * (Math.pow(t, 3)) + 3 * (Math.pow(t, 2))) * p1) + (((Math.pow(t, 3)) - (Math.pow(t, 2))) * m1);
    };
    return glTFCubicSpline;
}(gltf_interpolation_1.glTFInterpolation));
exports.glTFCubicSpline = glTFCubicSpline;


/***/ }),

/***/ "./src/gltf/animation/gltf-interpolation.ts":
/*!**************************************************!*\
  !*** ./src/gltf/animation/gltf-interpolation.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFInterpolation = void 0;
/**
 * Represents a specific interpolation method.
 */
var glTFInterpolation = /** @class */ (function () {
    function glTFInterpolation() {
    }
    glTFInterpolation.from = function (type, input, output, stride) {
        switch (type) {
            case "LINEAR": {
                return new gltf_linear_1.glTFLinear(output, stride);
            }
            case "CUBICSPLINE": {
                return new gltf_cubic_spline_1.glTFCubicSpline(input, output, stride);
            }
            case "STEP": {
                return new gltf_step_1.glTFStep(output, stride);
            }
        }
        throw new Error("PIXI3D: Unknown interpolation type \"" + type + "\"");
    };
    return glTFInterpolation;
}());
exports.glTFInterpolation = glTFInterpolation;
// Fixes circular dependency in webpack
var gltf_linear_1 = __webpack_require__(/*! ./gltf-linear */ "./src/gltf/animation/gltf-linear.ts");
var gltf_cubic_spline_1 = __webpack_require__(/*! ./gltf-cubic-spline */ "./src/gltf/animation/gltf-cubic-spline.ts");
var gltf_step_1 = __webpack_require__(/*! ./gltf-step */ "./src/gltf/animation/gltf-step.ts");


/***/ }),

/***/ "./src/gltf/animation/gltf-linear.ts":
/*!*******************************************!*\
  !*** ./src/gltf/animation/gltf-linear.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFLinear = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_interpolation_1 = __webpack_require__(/*! ./gltf-interpolation */ "./src/gltf/animation/gltf-interpolation.ts");
var glTFLinear = /** @class */ (function (_super) {
    tslib_1.__extends(glTFLinear, _super);
    function glTFLinear(_output, _stride) {
        var _this = _super.call(this) || this;
        _this._output = _output;
        _this._stride = _stride;
        _this._data = new Float32Array(_stride);
        return _this;
    }
    glTFLinear.prototype.interpolate = function (frame, position) {
        var pos1 = (frame + 0) * this._stride;
        var pos2 = (frame + 1) * this._stride;
        for (var i = 0; i < this._stride; i++) {
            if (this._output.length > pos2) {
                this._data[i] = (1 - position) * this._output[pos1 + i] + position * this._output[pos2 + i];
            }
            else {
                this._data[i] = this._output[pos1 + i];
            }
        }
        return this._data;
    };
    return glTFLinear;
}(gltf_interpolation_1.glTFInterpolation));
exports.glTFLinear = glTFLinear;


/***/ }),

/***/ "./src/gltf/animation/gltf-rotation.ts":
/*!*********************************************!*\
  !*** ./src/gltf/animation/gltf-rotation.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFRotation = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_channel_1 = __webpack_require__(/*! ./gltf-channel */ "./src/gltf/animation/gltf-channel.ts");
var glTFRotation = /** @class */ (function (_super) {
    tslib_1.__extends(glTFRotation, _super);
    function glTFRotation(transform, input, interpolation) {
        var _this = _super.call(this, input, interpolation) || this;
        _this._transform = transform;
        return _this;
    }
    glTFRotation.prototype.updateTarget = function (data) {
        this._transform.rotationQuaternion.set(data[0], data[1], data[2], data[3]);
    };
    return glTFRotation;
}(gltf_channel_1.glTFChannel));
exports.glTFRotation = glTFRotation;


/***/ }),

/***/ "./src/gltf/animation/gltf-scale.ts":
/*!******************************************!*\
  !*** ./src/gltf/animation/gltf-scale.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFScale = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_channel_1 = __webpack_require__(/*! ./gltf-channel */ "./src/gltf/animation/gltf-channel.ts");
var glTFScale = /** @class */ (function (_super) {
    tslib_1.__extends(glTFScale, _super);
    function glTFScale(transform, input, interpolation) {
        var _this = _super.call(this, input, interpolation) || this;
        _this._transform = transform;
        return _this;
    }
    glTFScale.prototype.updateTarget = function (data) {
        this._transform.scale.set(data[0], data[1], data[2]);
    };
    return glTFScale;
}(gltf_channel_1.glTFChannel));
exports.glTFScale = glTFScale;


/***/ }),

/***/ "./src/gltf/animation/gltf-spherical-linear.ts":
/*!*****************************************************!*\
  !*** ./src/gltf/animation/gltf-spherical-linear.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFSphericalLinear = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var quat_1 = __webpack_require__(/*! ../../math/quat */ "./src/math/quat.ts");
var gltf_interpolation_1 = __webpack_require__(/*! ./gltf-interpolation */ "./src/gltf/animation/gltf-interpolation.ts");
var glTFSphericalLinear = /** @class */ (function (_super) {
    tslib_1.__extends(glTFSphericalLinear, _super);
    function glTFSphericalLinear(_output) {
        var _this = _super.call(this) || this;
        _this._output = _output;
        _this._data = new Float32Array(4);
        return _this;
    }
    glTFSphericalLinear.prototype.interpolate = function (frame, position) {
        var pos1 = (frame + 0) * 4;
        var pos2 = (frame + 1) * 4;
        var a = quat_1.Quat.set(this._output[pos1], this._output[pos1 + 1], this._output[pos1 + 2], this._output[pos1 + 3], new Float32Array(4));
        if (this._output.length <= pos2) {
            return quat_1.Quat.normalize(a, this._data);
        }
        var b = quat_1.Quat.set(this._output[pos2], this._output[pos2 + 1], this._output[pos2 + 2], this._output[pos2 + 3], new Float32Array(4));
        return quat_1.Quat.normalize(quat_1.Quat.slerp(a, b, position, this._data), this._data);
    };
    return glTFSphericalLinear;
}(gltf_interpolation_1.glTFInterpolation));
exports.glTFSphericalLinear = glTFSphericalLinear;


/***/ }),

/***/ "./src/gltf/animation/gltf-step.ts":
/*!*****************************************!*\
  !*** ./src/gltf/animation/gltf-step.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFStep = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_interpolation_1 = __webpack_require__(/*! ./gltf-interpolation */ "./src/gltf/animation/gltf-interpolation.ts");
var glTFStep = /** @class */ (function (_super) {
    tslib_1.__extends(glTFStep, _super);
    function glTFStep(_output, _stride) {
        var _this = _super.call(this) || this;
        _this._output = _output;
        _this._stride = _stride;
        _this._data = new Float32Array(_stride);
        return _this;
    }
    glTFStep.prototype.interpolate = function (frame) {
        for (var i = 0; i < this._stride; i++) {
            this._data[i] = this._output[frame * this._stride + i];
        }
        return this._data;
    };
    return glTFStep;
}(gltf_interpolation_1.glTFInterpolation));
exports.glTFStep = glTFStep;


/***/ }),

/***/ "./src/gltf/animation/gltf-translation.ts":
/*!************************************************!*\
  !*** ./src/gltf/animation/gltf-translation.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFTranslation = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_channel_1 = __webpack_require__(/*! ./gltf-channel */ "./src/gltf/animation/gltf-channel.ts");
var glTFTranslation = /** @class */ (function (_super) {
    tslib_1.__extends(glTFTranslation, _super);
    function glTFTranslation(transform, input, interpolation) {
        var _this = _super.call(this, input, interpolation) || this;
        _this._transform = transform;
        return _this;
    }
    glTFTranslation.prototype.updateTarget = function (data) {
        this._transform.position.set(data[0], data[1], data[2]);
    };
    return glTFTranslation;
}(gltf_channel_1.glTFChannel));
exports.glTFTranslation = glTFTranslation;


/***/ }),

/***/ "./src/gltf/animation/gltf-weights.ts":
/*!********************************************!*\
  !*** ./src/gltf/animation/gltf-weights.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFWeights = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_channel_1 = __webpack_require__(/*! ./gltf-channel */ "./src/gltf/animation/gltf-channel.ts");
var glTFWeights = /** @class */ (function (_super) {
    tslib_1.__extends(glTFWeights, _super);
    function glTFWeights(weights, input, interpolation) {
        var _this = _super.call(this, input, interpolation) || this;
        _this._weights = weights;
        return _this;
    }
    glTFWeights.prototype.updateTarget = function (data) {
        for (var i = 0; i < data.length; i++) {
            this._weights[i] = data[i];
        }
    };
    return glTFWeights;
}(gltf_channel_1.glTFChannel));
exports.glTFWeights = glTFWeights;


/***/ }),

/***/ "./src/gltf/gltf-asset.ts":
/*!********************************!*\
  !*** ./src/gltf/gltf-asset.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFAsset = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
/**
 * glTF assets are JSON files plus supporting external data.
 */
var glTFAsset = /** @class */ (function () {
    /**
     * Creates a new glTF asset using the specified JSON descriptor.
     * @param descriptor The JSON descriptor to create the asset from.
     * @param buffers The buffers used by this asset.
     * @param images The images used by this asset.
     */
    function glTFAsset(descriptor, buffers, images) {
        if (buffers === void 0) { buffers = []; }
        if (images === void 0) { images = []; }
        this.descriptor = descriptor;
        this.buffers = buffers;
        this.images = images;
    }
    /**
     * Loads a new glTF asset (including resources) using the specified JSON
     * descriptor.
     * @param descriptor The JSON descriptor to create the asset from.
     * @param loader The resource loader to use for external resources. The
     * loader can be empty when all resources in the descriptor is embedded.
     */
    glTFAsset.load = function (descriptor, loader) {
        var asset = new glTFAsset(descriptor);
        var _loop_1 = function (i) {
            var buffer = descriptor.buffers[i];
            if (glTFAsset.isEmbeddedResource(buffer.uri)) {
                asset.buffers[i] = glTFAsset.getEmbeddedBuffer(buffer.uri);
            }
            else {
                if (!loader) {
                    throw new Error("PIXI3D: A resource loader is required when buffer is not embedded.");
                }
                loader.load(buffer.uri, function (resource) {
                    asset.buffers[i] = resource.data;
                });
            }
        };
        for (var i = 0; i < descriptor.buffers.length; i++) {
            _loop_1(i);
        }
        if (!descriptor.images) {
            return asset;
        }
        var _loop_2 = function (i) {
            var image = descriptor.images[i];
            if (glTFAsset.isEmbeddedResource(image.uri)) {
                asset.images[i] = PIXI.Texture.from(image.uri, {
                    wrapMode: PIXI.WRAP_MODES.REPEAT
                });
            }
            else {
                if (!loader) {
                    throw new Error("PIXI3D: A resource loader is required when image is not embedded.");
                }
                loader.load(image.uri, function (resource) {
                    if (resource.texture) {
                        resource.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
                        asset.images[i] = resource.texture;
                    }
                });
            }
        };
        for (var i = 0; i < descriptor.images.length; i++) {
            _loop_2(i);
        }
        return asset;
    };
    /**
     * Returns a value indicating if the specified data buffer is a valid glTF.
     * @param data The buffer data to validate.
     */
    glTFAsset.isValid = function (data) {
        var header = new Uint32Array(data, 0, 3);
        if (header[0] === 0x46546C67 && header[1] === 2) {
            return true;
        }
        return false;
    };
    /**
     * Creates a new glTF asset from binary (glb) buffer data.
     * @param data The binary buffer data to read from.
     * @param callback The function which gets called when the asset has been
     * created.
     */
    glTFAsset.fromBuffer = function (data, callback) {
        var chunks = [];
        var offset = 3 * 4;
        while (offset < data.byteLength) {
            var header = new Uint32Array(data, offset, 3);
            chunks.push({
                length: header[0], type: header[1], offset: offset + 2 * 4
            });
            offset += header[0] + 2 * 4;
        }
        var json = new Uint8Array(data, chunks[0].offset, chunks[0].length);
        var descriptor = JSON.parse(new TextDecoder("utf-8").decode(json));
        var buffers = [];
        for (var i = 1; i < chunks.length; i++) {
            buffers.push(data.slice(chunks[i].offset, chunks[i].offset + chunks[i].length));
        }
        if (!descriptor.images || descriptor.images.length === 0) {
            callback(new glTFAsset(descriptor, buffers));
        }
        var images = [];
        var _loop_3 = function (i) {
            var image = descriptor.images[i];
            if (image.bufferView === undefined) {
                return "continue";
            }
            var view = descriptor.bufferViews[image.bufferView];
            var buffer = buffers[view.buffer];
            var array = new Uint8Array(buffer, view.byteOffset, view.byteLength);
            var blob = new Blob([array], { "type": image.mimeType });
            var reader = new FileReader();
            reader.onload = function () {
                images[i] = PIXI.Texture.from(reader.result);
                images[i].baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
                if (images.length === descriptor.images.length) {
                    callback(new glTFAsset(descriptor, buffers, images));
                }
            };
            reader.readAsDataURL(blob);
        };
        for (var i = 0; descriptor.images && i < descriptor.images.length; i++) {
            _loop_3(i);
        }
    };
    glTFAsset.isEmbeddedResource = function (uri) {
        return uri.startsWith("data:");
    };
    glTFAsset.getEmbeddedBuffer = function (value) {
        return Uint8Array.from(atob(value.split(",")[1]), function (c) { return c.charCodeAt(0); }).buffer;
    };
    return glTFAsset;
}());
exports.glTFAsset = glTFAsset;


/***/ }),

/***/ "./src/gltf/gltf-buffer-view.ts":
/*!**************************************!*\
  !*** ./src/gltf/gltf-buffer-view.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFBufferView = void 0;
/**
 * Represents a subset of data in a buffer.
 */
var glTFBufferView = /** @class */ (function () {
    function glTFBufferView(buffer, componentType, stride) {
        if (stride === void 0) { stride = 0; }
        this.buffer = buffer;
        this.componentType = componentType;
        this.stride = stride;
    }
    glTFBufferView.from = function (componentType, buffer, offset, size, stride) {
        switch (componentType) {
            case 5125: return new glTFBufferView(new Uint32Array(buffer, offset, size), componentType, stride);
            case 5126: return new glTFBufferView(new Float32Array(buffer, offset, size), componentType, stride);
            case 5120: return new glTFBufferView(new Int8Array(buffer, offset, size), componentType, stride);
            case 5121: return new glTFBufferView(new Uint8Array(buffer, offset, size), componentType, stride);
            case 5122: return new glTFBufferView(new Int16Array(buffer, offset, size), componentType, stride);
            case 5123: return new glTFBufferView(new Uint16Array(buffer, offset, size), componentType, stride);
            default: {
                throw new Error("PIXI3D: Unknown component type \"" + componentType + "\".");
            }
        }
    };
    return glTFBufferView;
}());
exports.glTFBufferView = glTFBufferView;


/***/ }),

/***/ "./src/gltf/gltf-material.ts":
/*!***********************************!*\
  !*** ./src/gltf/gltf-material.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFMaterial = void 0;
/**
 * glTF defines materials using a common set of parameters that are based on
 * widely used material representations from Physically-Based Rendering (PBR).
 */
var glTFMaterial = /** @class */ (function () {
    function glTFMaterial() {
        this.alphaCutoff = 0.5;
        this.alphaMode = "OPAQUE";
        this.doubleSided = false;
        this.roughness = 1;
        this.metallic = 1;
        this.emissive = [0, 0, 0];
        this.baseColor = [1, 1, 1, 1];
        this.unlit = false;
    }
    return glTFMaterial;
}());
exports.glTFMaterial = glTFMaterial;


/***/ }),

/***/ "./src/gltf/gltf-parser.ts":
/*!*********************************!*\
  !*** ./src/gltf/gltf-parser.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFParser = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_channel_1 = __webpack_require__(/*! ./animation/gltf-channel */ "./src/gltf/animation/gltf-channel.ts");
var gltf_animation_1 = __webpack_require__(/*! ./animation/gltf-animation */ "./src/gltf/animation/gltf-animation.ts");
var gltf_buffer_view_1 = __webpack_require__(/*! ./gltf-buffer-view */ "./src/gltf/gltf-buffer-view.ts");
var gltf_material_1 = __webpack_require__(/*! ./gltf-material */ "./src/gltf/gltf-material.ts");
var mesh_1 = __webpack_require__(/*! ../mesh/mesh */ "./src/mesh/mesh.ts");
var container_1 = __webpack_require__(/*! ../container */ "./src/container.ts");
var standard_material_1 = __webpack_require__(/*! ../material/standard/standard-material */ "./src/material/standard/standard-material.ts");
var mesh_geometry_1 = __webpack_require__(/*! ../mesh/geometry/mesh-geometry */ "./src/mesh/geometry/mesh-geometry.ts");
var model_1 = __webpack_require__(/*! ../model */ "./src/model.ts");
var transform_matrix_1 = __webpack_require__(/*! ../transform/transform-matrix */ "./src/transform/transform-matrix.ts");
var skin_1 = __webpack_require__(/*! ../skinning/skin */ "./src/skinning/skin.ts");
var joint_1 = __webpack_require__(/*! ../skinning/joint */ "./src/skinning/joint.ts");
var textureTransform_1 = __webpack_require__(/*! ../texture/textureTransform */ "./src/texture/textureTransform.ts");
/**
 * Parses glTF assets and creates models and meshes.
 */
var glTFParser = /** @class */ (function () {
    /**
     * Creates a new parser using the specified asset.
     * @param asset The asset to parse.
     * @param materialFactory The material factory to use.
     */
    function glTFParser(asset, materialFactory) {
        this._asset = asset;
        this._materialFactory = materialFactory || standard_material_1.StandardMaterial;
        this._descriptor = this._asset.descriptor;
    }
    /**
     * Creates a model from the specified asset.
     * @param asset The asset to create the model from.
     * @param materialFactory The material factory to use.
     */
    glTFParser.createModel = function (asset, materialFactory) {
        return new glTFParser(asset, materialFactory).parseModel();
    };
    /**
     * Creates a mesh from the specified asset.
     * @param asset The asset to create the mesh from.
     * @param materialFactory The material factory to use.
     * @param mesh The mesh index in the JSON descriptor.
     */
    glTFParser.createMesh = function (asset, materialFactory, mesh) {
        if (mesh === void 0) { mesh = 0; }
        return new glTFParser(asset, materialFactory).parseMesh(mesh);
    };
    /**
     * Creates a new buffer view from the specified accessor.
     * @param accessor The accessor object or index.
     */
    glTFParser.prototype.parseBuffer = function (accessor) {
        if (accessor === undefined) {
            return undefined;
        }
        if (typeof accessor === "number") {
            accessor = this._asset.descriptor.accessors[accessor];
        }
        var bufferView = this._descriptor.bufferViews[accessor.bufferView || 0];
        var offset = accessor.byteOffset || 0;
        if (bufferView.byteOffset !== undefined) {
            offset += bufferView.byteOffset;
        }
        var size = accessor.count * componentCount[accessor.type];
        if (bufferView.byteStride !== undefined) {
            size *= bufferView.byteStride / componentSize[accessor.componentType] / componentCount[accessor.type];
        }
        var buffer = this._asset.buffers[bufferView.buffer];
        return gltf_buffer_view_1.glTFBufferView.from(accessor.componentType, buffer, offset, size, bufferView.byteStride);
    };
    /**
     * Creates an animation from the specified animation.
     * @param animation The source animation object or index.
     * @param nodes The array of nodes which are potential targets for the animation.
     */
    glTFParser.prototype.parseAnimation = function (animation, nodes) {
        var e_1, _a;
        if (typeof animation === "number") {
            animation = this._asset.descriptor.animations[animation];
        }
        var channels = [];
        try {
            for (var _b = tslib_1.__values(animation.channels), _c = _b.next(); !_c.done; _c = _b.next()) {
                var channel = _c.value;
                var sampler = animation.samplers[channel.sampler];
                var input = this.parseBuffer(sampler.input);
                if (input === undefined) {
                    continue;
                }
                var output = this.parseBuffer(sampler.output);
                if (output === undefined) {
                    continue;
                }
                var animationChannel = gltf_channel_1.glTFChannel.from(input.buffer, output.buffer, sampler.interpolation || "LINEAR", channel.target.path, nodes[channel.target.node]);
                if (animationChannel) {
                    channels.push(animationChannel);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return new gltf_animation_1.glTFAnimation(channels, animation.name);
    };
    /**
     * Creates a material from the specified source.
     * @param material The source material object or index.
     */
    glTFParser.prototype.parseMaterial = function (material) {
        if (typeof material === "number") {
            material = this._asset.descriptor.materials[material];
        }
        var result = new gltf_material_1.glTFMaterial();
        if (!material) {
            return this._materialFactory.create(result);
        }
        result.occlusionTexture = this.parseTexture(material.occlusionTexture);
        result.normalTexture = this.parseTexture(material.normalTexture);
        result.emissiveTexture = this.parseTexture(material.emissiveTexture);
        if (material.doubleSided !== undefined) {
            result.doubleSided = material.doubleSided;
        }
        if (material.emissive) {
            result.emissive = material.emissive;
        }
        if (material.alphaMode) {
            result.alphaMode = material.alphaMode;
        }
        if (material.alphaCutoff !== undefined) {
            result.alphaCutoff = material.alphaCutoff;
        }
        var pbr = material.pbrMetallicRoughness;
        result.metallicRoughnessTexture = this.parseTexture(pbr === null || pbr === void 0 ? void 0 : pbr.metallicRoughnessTexture);
        if (pbr === null || pbr === void 0 ? void 0 : pbr.baseColorFactor) {
            result.baseColor = pbr.baseColorFactor;
        }
        result.baseColorTexture = this.parseTexture(pbr === null || pbr === void 0 ? void 0 : pbr.baseColorTexture);
        if ((pbr === null || pbr === void 0 ? void 0 : pbr.metallicFactor) !== undefined) {
            result.metallic = pbr.metallicFactor;
        }
        if ((pbr === null || pbr === void 0 ? void 0 : pbr.roughnessFactor) !== undefined) {
            result.roughness = pbr.roughnessFactor;
        }
        if (material.extensions) {
            result.unlit = material.extensions["KHR_materials_unlit"] != undefined;
        }
        return this._materialFactory.create(result);
    };
    /**
     * Returns the texture used by the specified object.
     * @param source The source object or index.
     */
    glTFParser.prototype.parseTexture = function (source) {
        if (source === undefined) {
            return undefined;
        }
        if (typeof source === "number") {
            source = { index: source };
        }
        var texture = this._asset.images[this._descriptor.textures[source.index].source];
        if (source.extensions && source.extensions.KHR_texture_transform) {
            textureTransform_1.TextureTransform.calculateUVTransform(source.extensions.KHR_texture_transform, texture);
        }
        return texture;
    };
    /**
     * Creates an array of meshes from the specified mesh.
     * @param mesh The source mesh object or index.
     * @returns An array which contain arrays of meshes. This is because of the
     * structure used in glTF, where each mesh contain a number of primitives.
     * Read more about this in discussion at https://github.com/KhronosGroup/glTF/issues/821
     */
    glTFParser.prototype.parseMesh = function (mesh) {
        var _this = this;
        if (typeof mesh === "number") {
            mesh = this._asset.descriptor.meshes[mesh];
        }
        var weights = mesh.weights || [];
        return mesh.primitives.map(function (primitive) {
            return Object.assign(_this.parsePrimitive(primitive), {
                name: mesh.name,
                morphWeights: weights
            });
        });
    };
    /**
     * Creates a skin from the specified source.
     * @param skin The source skin object or index.
     * @param target The target container for the skin.
     * @param nodes The array of nodes which are potential targets for the animation.
     */
    glTFParser.prototype.parseSkin = function (skin, target, nodes) {
        if (typeof skin === "number") {
            skin = this._asset.descriptor.skins[skin];
        }
        var inverseBindMatrices = this.parseBuffer(skin.inverseBindMatrices);
        var joints = [];
        if (inverseBindMatrices) {
            for (var i = 0; i < skin.joints.length; i++) {
                joints.push(new joint_1.Joint(nodes[skin.joints[i]], inverseBindMatrices.buffer.slice(i * 16, i * 16 + 16)));
            }
        }
        return new skin_1.Skin(target, joints);
    };
    /**
     * Creates a mesh from the specified primitive.
     * @param primitive The source primitive object.
     */
    glTFParser.prototype.parsePrimitive = function (primitive) {
        var attributes = primitive.attributes, targets = primitive.targets;
        var geometry = Object.assign(new mesh_geometry_1.MeshGeometry3D(), {
            indices: this.parseBuffer(primitive.indices),
            positions: this.parseBuffer(attributes["POSITION"]),
            normals: this.parseBuffer(attributes["NORMAL"]),
            tangents: this.parseBuffer(attributes["TANGENT"]),
            joints: this.parseBuffer(attributes["JOINTS_0"]),
            weights: this.parseBuffer(attributes["WEIGHTS_0"]),
        });
        for (var i = 0; true; i++) {
            var buffer = this.parseBuffer(attributes["TEXCOORD_" + i]);
            if (buffer === undefined) {
                break;
            }
            geometry.uvs = geometry.uvs || [];
            geometry.uvs.push(buffer);
        }
        if (targets) {
            for (var i = 0; i < targets.length; i++) {
                geometry.targets = geometry.targets || [];
                geometry.targets.push({
                    positions: this.parseBuffer(targets[i]["POSITION"]),
                    normals: this.parseBuffer(targets[i]["NORMAL"]),
                    tangents: this.parseBuffer(targets[i]["TANGENT"])
                });
            }
        }
        var material;
        if (primitive.material !== undefined) {
            material = this.parseMaterial(this._asset.descriptor.materials[primitive.material]);
        }
        else {
            material = this.parseMaterial();
        }
        return new mesh_1.Mesh3D(geometry, material);
    };
    /**
     * Creates a container from the specified node.
     * @param node The source node object or index.
     */
    glTFParser.prototype.parseNode = function (node) {
        if (typeof node === "number") {
            node = this._asset.descriptor.nodes[node];
        }
        var container = Object.assign(new container_1.Container3D(), {
            name: node.name
        });
        if (node.translation) {
            container.position.set(node.translation[0], node.translation[1], node.translation[2]);
        }
        if (node.rotation) {
            container.rotationQuaternion.set(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]);
        }
        if (node.scale) {
            container.scale.set(node.scale[0], node.scale[1], node.scale[2]);
        }
        if (node.matrix) {
            container.transform.setFromMatrix(new transform_matrix_1.TransformMatrix(node.matrix));
        }
        return container;
    };
    glTFParser.prototype.parseModel = function () {
        var e_2, _a, e_3, _b;
        var _this = this;
        var nodes = this._descriptor.nodes.map(function (n) {
            return _this.parseNode(n);
        });
        var scene = this._descriptor.scenes[this._asset.descriptor.scene || 0];
        var model = new model_1.Model();
        var createHierarchy = function (parent, node) {
            var e_4, _a, e_5, _b;
            var mesh = _this._asset.descriptor.nodes[node].mesh;
            var skin;
            if (_this._asset.descriptor.nodes[node].skin !== undefined) {
                skin = _this.parseSkin(_this._asset.descriptor.nodes[node].skin, nodes[node], nodes);
            }
            if (mesh !== undefined) {
                try {
                    for (var _c = tslib_1.__values(_this.parseMesh(mesh)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var primitive = _d.value;
                        model.meshes.push(nodes[node].addChild(primitive));
                        model.meshes[model.meshes.length - 1].skin = skin;
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
            parent.addChild(nodes[node]);
            if (!_this._asset.descriptor.nodes[node].children) {
                return;
            }
            try {
                for (var _e = tslib_1.__values(_this._asset.descriptor.nodes[node].children), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var child = _f.value;
                    createHierarchy(nodes[node], child);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_5) throw e_5.error; }
            }
        };
        try {
            for (var _c = tslib_1.__values(scene.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var node = _d.value;
                createHierarchy(model, node);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (this._asset.descriptor.animations) {
            try {
                for (var _e = tslib_1.__values(this._asset.descriptor.animations), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var animation = _f.value;
                    model.animations.push(this.parseAnimation(animation, nodes));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        return model;
    };
    return glTFParser;
}());
exports.glTFParser = glTFParser;
var componentCount = {
    SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16
};
var componentSize = (_a = {},
    _a[5120] = 1,
    _a[5121] = 1,
    _a[5122] = 2,
    _a[5123] = 2,
    _a[5125] = 4,
    _a[5126] = 4,
    _a);


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SpriteBillboardType = exports.SpriteBatchRenderer = exports.Sprite3D = exports.CubemapResource = exports.Color = exports.Quat = exports.Mat4 = exports.Vec3 = exports.Plane = exports.Ray = exports.PostProcessingSprite = exports.ShadowQuality = exports.ShadowCastingLight = exports.ShadowRenderPass = exports.Joint = exports.Skin = exports.PickingManager = exports.PickingHitArea = exports.StandardMaterialDebugMode = exports.StandardMaterialAlphaMode = exports.StandardMaterial = exports.Skybox = exports.ShaderSourceLoader = exports.Cubemap = exports.CubemapLoader = exports.MaterialRenderSortType = exports.Material = exports.MaterialRenderPass = exports.StandardPipeline = exports.ImageBasedLighting = exports.LightingEnvironment = exports.Light = exports.LightType = exports.Animation = exports.Model = exports.MeshShader = exports.MeshGeometry3D = exports.Mesh3D = exports.CameraOrbitControl = exports.Camera = exports.Container3D = exports.TransformMatrix = exports.Transform3D = exports.ObservableQuaternion = exports.ObservablePoint3D = exports.glTFAsset = exports.glTFBinaryLoader = exports.glTFLoader = void 0;
var gltf_loader_1 = __webpack_require__(/*! ./loader/gltf-loader */ "./src/loader/gltf-loader.ts");
Object.defineProperty(exports, "glTFLoader", { enumerable: true, get: function () { return gltf_loader_1.glTFLoader; } });
var gltf_binary_loader_1 = __webpack_require__(/*! ./loader/gltf-binary-loader */ "./src/loader/gltf-binary-loader.ts");
Object.defineProperty(exports, "glTFBinaryLoader", { enumerable: true, get: function () { return gltf_binary_loader_1.glTFBinaryLoader; } });
var gltf_asset_1 = __webpack_require__(/*! ./gltf/gltf-asset */ "./src/gltf/gltf-asset.ts");
Object.defineProperty(exports, "glTFAsset", { enumerable: true, get: function () { return gltf_asset_1.glTFAsset; } });
var observable_point_1 = __webpack_require__(/*! ./transform/observable-point */ "./src/transform/observable-point.ts");
Object.defineProperty(exports, "ObservablePoint3D", { enumerable: true, get: function () { return observable_point_1.ObservablePoint3D; } });
var observable_quaternion_1 = __webpack_require__(/*! ./transform/observable-quaternion */ "./src/transform/observable-quaternion.ts");
Object.defineProperty(exports, "ObservableQuaternion", { enumerable: true, get: function () { return observable_quaternion_1.ObservableQuaternion; } });
var transform_1 = __webpack_require__(/*! ./transform/transform */ "./src/transform/transform.ts");
Object.defineProperty(exports, "Transform3D", { enumerable: true, get: function () { return transform_1.Transform3D; } });
var transform_matrix_1 = __webpack_require__(/*! ./transform/transform-matrix */ "./src/transform/transform-matrix.ts");
Object.defineProperty(exports, "TransformMatrix", { enumerable: true, get: function () { return transform_matrix_1.TransformMatrix; } });
var container_1 = __webpack_require__(/*! ./container */ "./src/container.ts");
Object.defineProperty(exports, "Container3D", { enumerable: true, get: function () { return container_1.Container3D; } });
var camera_1 = __webpack_require__(/*! ./camera/camera */ "./src/camera/camera.ts");
Object.defineProperty(exports, "Camera", { enumerable: true, get: function () { return camera_1.Camera; } });
var camera_orbit_control_1 = __webpack_require__(/*! ./camera/camera-orbit-control */ "./src/camera/camera-orbit-control.ts");
Object.defineProperty(exports, "CameraOrbitControl", { enumerable: true, get: function () { return camera_orbit_control_1.CameraOrbitControl; } });
var mesh_1 = __webpack_require__(/*! ./mesh/mesh */ "./src/mesh/mesh.ts");
Object.defineProperty(exports, "Mesh3D", { enumerable: true, get: function () { return mesh_1.Mesh3D; } });
var mesh_geometry_1 = __webpack_require__(/*! ./mesh/geometry/mesh-geometry */ "./src/mesh/geometry/mesh-geometry.ts");
Object.defineProperty(exports, "MeshGeometry3D", { enumerable: true, get: function () { return mesh_geometry_1.MeshGeometry3D; } });
var mesh_shader_1 = __webpack_require__(/*! ./mesh/mesh-shader */ "./src/mesh/mesh-shader.ts");
Object.defineProperty(exports, "MeshShader", { enumerable: true, get: function () { return mesh_shader_1.MeshShader; } });
var model_1 = __webpack_require__(/*! ./model */ "./src/model.ts");
Object.defineProperty(exports, "Model", { enumerable: true, get: function () { return model_1.Model; } });
var animation_1 = __webpack_require__(/*! ./animation */ "./src/animation.ts");
Object.defineProperty(exports, "Animation", { enumerable: true, get: function () { return animation_1.Animation; } });
var light_type_1 = __webpack_require__(/*! ./lighting/light-type */ "./src/lighting/light-type.ts");
Object.defineProperty(exports, "LightType", { enumerable: true, get: function () { return light_type_1.LightType; } });
var light_1 = __webpack_require__(/*! ./lighting/light */ "./src/lighting/light.ts");
Object.defineProperty(exports, "Light", { enumerable: true, get: function () { return light_1.Light; } });
var lighting_environment_1 = __webpack_require__(/*! ./lighting/lighting-environment */ "./src/lighting/lighting-environment.ts");
Object.defineProperty(exports, "LightingEnvironment", { enumerable: true, get: function () { return lighting_environment_1.LightingEnvironment; } });
var image_based_lighting_1 = __webpack_require__(/*! ./lighting/image-based-lighting */ "./src/lighting/image-based-lighting.ts");
Object.defineProperty(exports, "ImageBasedLighting", { enumerable: true, get: function () { return image_based_lighting_1.ImageBasedLighting; } });
var standard_pipeline_1 = __webpack_require__(/*! ./pipeline/standard-pipeline */ "./src/pipeline/standard-pipeline.ts");
Object.defineProperty(exports, "StandardPipeline", { enumerable: true, get: function () { return standard_pipeline_1.StandardPipeline; } });
var material_render_pass_1 = __webpack_require__(/*! ./pipeline/material-render-pass */ "./src/pipeline/material-render-pass.ts");
Object.defineProperty(exports, "MaterialRenderPass", { enumerable: true, get: function () { return material_render_pass_1.MaterialRenderPass; } });
var material_1 = __webpack_require__(/*! ./material/material */ "./src/material/material.ts");
Object.defineProperty(exports, "Material", { enumerable: true, get: function () { return material_1.Material; } });
var material_render_sort_type_1 = __webpack_require__(/*! ./material/material-render-sort-type */ "./src/material/material-render-sort-type.ts");
Object.defineProperty(exports, "MaterialRenderSortType", { enumerable: true, get: function () { return material_render_sort_type_1.MaterialRenderSortType; } });
var cubemap_loader_1 = __webpack_require__(/*! ./loader/cubemap-loader */ "./src/loader/cubemap-loader.ts");
Object.defineProperty(exports, "CubemapLoader", { enumerable: true, get: function () { return cubemap_loader_1.CubemapLoader; } });
var cubemap_1 = __webpack_require__(/*! ./cubemap/cubemap */ "./src/cubemap/cubemap.ts");
Object.defineProperty(exports, "Cubemap", { enumerable: true, get: function () { return cubemap_1.Cubemap; } });
var shader_source_loader_1 = __webpack_require__(/*! ./loader/shader-source-loader */ "./src/loader/shader-source-loader.ts");
Object.defineProperty(exports, "ShaderSourceLoader", { enumerable: true, get: function () { return shader_source_loader_1.ShaderSourceLoader; } });
var skybox_1 = __webpack_require__(/*! ./skybox/skybox */ "./src/skybox/skybox.ts");
Object.defineProperty(exports, "Skybox", { enumerable: true, get: function () { return skybox_1.Skybox; } });
var standard_material_1 = __webpack_require__(/*! ./material/standard/standard-material */ "./src/material/standard/standard-material.ts");
Object.defineProperty(exports, "StandardMaterial", { enumerable: true, get: function () { return standard_material_1.StandardMaterial; } });
var standard_material_alpha_mode_1 = __webpack_require__(/*! ./material/standard/standard-material-alpha-mode */ "./src/material/standard/standard-material-alpha-mode.ts");
Object.defineProperty(exports, "StandardMaterialAlphaMode", { enumerable: true, get: function () { return standard_material_alpha_mode_1.StandardMaterialAlphaMode; } });
var standard_material_debug_mode_1 = __webpack_require__(/*! ./material/standard/standard-material-debug-mode */ "./src/material/standard/standard-material-debug-mode.ts");
Object.defineProperty(exports, "StandardMaterialDebugMode", { enumerable: true, get: function () { return standard_material_debug_mode_1.StandardMaterialDebugMode; } });
var picking_hitarea_1 = __webpack_require__(/*! ./picking/picking-hitarea */ "./src/picking/picking-hitarea.ts");
Object.defineProperty(exports, "PickingHitArea", { enumerable: true, get: function () { return picking_hitarea_1.PickingHitArea; } });
var picking_manager_1 = __webpack_require__(/*! ./picking/picking-manager */ "./src/picking/picking-manager.ts");
Object.defineProperty(exports, "PickingManager", { enumerable: true, get: function () { return picking_manager_1.PickingManager; } });
var skin_1 = __webpack_require__(/*! ./skinning/skin */ "./src/skinning/skin.ts");
Object.defineProperty(exports, "Skin", { enumerable: true, get: function () { return skin_1.Skin; } });
var joint_1 = __webpack_require__(/*! ./skinning/joint */ "./src/skinning/joint.ts");
Object.defineProperty(exports, "Joint", { enumerable: true, get: function () { return joint_1.Joint; } });
var shadow_render_pass_1 = __webpack_require__(/*! ./shadow/shadow-render-pass */ "./src/shadow/shadow-render-pass.ts");
Object.defineProperty(exports, "ShadowRenderPass", { enumerable: true, get: function () { return shadow_render_pass_1.ShadowRenderPass; } });
var shadow_casting_light_1 = __webpack_require__(/*! ./shadow/shadow-casting-light */ "./src/shadow/shadow-casting-light.ts");
Object.defineProperty(exports, "ShadowCastingLight", { enumerable: true, get: function () { return shadow_casting_light_1.ShadowCastingLight; } });
var shadow_quality_1 = __webpack_require__(/*! ./shadow/shadow-quality */ "./src/shadow/shadow-quality.ts");
Object.defineProperty(exports, "ShadowQuality", { enumerable: true, get: function () { return shadow_quality_1.ShadowQuality; } });
var post_processing_sprite_1 = __webpack_require__(/*! ./sprite/post-processing-sprite */ "./src/sprite/post-processing-sprite.ts");
Object.defineProperty(exports, "PostProcessingSprite", { enumerable: true, get: function () { return post_processing_sprite_1.PostProcessingSprite; } });
var ray_1 = __webpack_require__(/*! ./math/ray */ "./src/math/ray.ts");
Object.defineProperty(exports, "Ray", { enumerable: true, get: function () { return ray_1.Ray; } });
var plane_1 = __webpack_require__(/*! ./math/plane */ "./src/math/plane.ts");
Object.defineProperty(exports, "Plane", { enumerable: true, get: function () { return plane_1.Plane; } });
var vec3_1 = __webpack_require__(/*! ./math/vec3 */ "./src/math/vec3.ts");
Object.defineProperty(exports, "Vec3", { enumerable: true, get: function () { return vec3_1.Vec3; } });
var mat4_1 = __webpack_require__(/*! ./math/mat4 */ "./src/math/mat4.ts");
Object.defineProperty(exports, "Mat4", { enumerable: true, get: function () { return mat4_1.Mat4; } });
var quat_1 = __webpack_require__(/*! ./math/quat */ "./src/math/quat.ts");
Object.defineProperty(exports, "Quat", { enumerable: true, get: function () { return quat_1.Quat; } });
var color_1 = __webpack_require__(/*! ./color */ "./src/color.ts");
Object.defineProperty(exports, "Color", { enumerable: true, get: function () { return color_1.Color; } });
var cubemap_resource_1 = __webpack_require__(/*! ./cubemap/cubemap-resource */ "./src/cubemap/cubemap-resource.ts");
Object.defineProperty(exports, "CubemapResource", { enumerable: true, get: function () { return cubemap_resource_1.CubemapResource; } });
var sprite_1 = __webpack_require__(/*! ./sprite/sprite */ "./src/sprite/sprite.ts");
Object.defineProperty(exports, "Sprite3D", { enumerable: true, get: function () { return sprite_1.Sprite3D; } });
var sprite_batch_renderer_1 = __webpack_require__(/*! ./sprite/sprite-batch-renderer */ "./src/sprite/sprite-batch-renderer.ts");
Object.defineProperty(exports, "SpriteBatchRenderer", { enumerable: true, get: function () { return sprite_batch_renderer_1.SpriteBatchRenderer; } });
var sprite_billboard_type_1 = __webpack_require__(/*! ./sprite/sprite-billboard-type */ "./src/sprite/sprite-billboard-type.ts");
Object.defineProperty(exports, "SpriteBillboardType", { enumerable: true, get: function () { return sprite_billboard_type_1.SpriteBillboardType; } });


/***/ }),

/***/ "./src/instanced-model.ts":
/*!********************************!*\
  !*** ./src/instanced-model.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InstancedModel = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var container_1 = __webpack_require__(/*! ./container */ "./src/container.ts");
var mesh_1 = __webpack_require__(/*! ./mesh/mesh */ "./src/mesh/mesh.ts");
var InstancedModel = /** @class */ (function (_super) {
    tslib_1.__extends(InstancedModel, _super);
    function InstancedModel(meshes) {
        var e_1, _a;
        var _this = _super.call(this) || this;
        _this.meshes = meshes;
        try {
            for (var meshes_1 = tslib_1.__values(meshes), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                var mesh = meshes_1_1.value;
                _this.addChild(mesh);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (meshes_1_1 && !meshes_1_1.done && (_a = meshes_1.return)) _a.call(meshes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return _this;
    }
    InstancedModel.prototype.destroy = function (options) {
        var e_2, _a;
        _super.prototype.destroy.call(this, options);
        try {
            for (var _b = tslib_1.__values(this.meshes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mesh = _c.value;
                mesh.destroy(options);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    InstancedModel.from = function (model) {
        var meshes = [];
        var cloneChildren = function (node, parent) {
            var e_3, _a;
            try {
                for (var _b = tslib_1.__values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    if (child instanceof mesh_1.Mesh3D) {
                        var mesh = child.createInstance();
                        mesh.name = child.name;
                        meshes.push(parent.addChild(mesh));
                    }
                    else if (child instanceof container_1.Container3D) {
                        var copy = new container_1.Container3D();
                        copy.name = node.name;
                        copy.position = child.position;
                        copy.scale = child.scale;
                        copy.rotationQuaternion = child.rotationQuaternion;
                        parent.addChild(copy);
                        cloneChildren(child, copy);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return parent;
        };
        return cloneChildren(model, new InstancedModel(meshes));
    };
    return InstancedModel;
}(container_1.Container3D));
exports.InstancedModel = InstancedModel;


/***/ }),

/***/ "./src/lighting/assets/brdf.png":
/*!**************************************!*\
  !*** ./src/lighting/assets/brdf.png ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");

/***/ }),

/***/ "./src/lighting/image-based-lighting.ts":
/*!**********************************************!*\
  !*** ./src/lighting/image-based-lighting.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageBasedLighting = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
/**
 * A collection of components used for image-based lighting (IBL).
 */
var ImageBasedLighting = /** @class */ (function () {
    /**
     * Creates a new image-based lighting object.
     * @param diffuse Cube texture used for the diffuse component.
     * @param specular Cube mipmap texture used for the specular component.
     * @param brdf BRDF integration map lookup texture.
     */
    function ImageBasedLighting(diffuse, specular, brdf) {
        this._diffuse = diffuse;
        this._brdf = brdf || PIXI.Texture.from(__webpack_require__(/*! ./assets/brdf.png */ "./src/lighting/assets/brdf.png").default);
        this._specular = specular;
    }
    Object.defineProperty(ImageBasedLighting.prototype, "diffuse", {
        /** Cube texture used for the diffuse component. */
        get: function () {
            return this._diffuse;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageBasedLighting.prototype, "brdf", {
        /** BRDF integration map lookup texture. */
        get: function () {
            return this._brdf;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageBasedLighting.prototype, "specular", {
        /** Cube mipmap texture used for the specular component. */
        get: function () {
            return this._specular;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageBasedLighting.prototype, "valid", {
        /**
         * Value indicating if this object is valid to be used for rendering.
         */
        get: function () {
            return this._diffuse.valid && this._specular.valid && this._brdf.valid;
        },
        enumerable: false,
        configurable: true
    });
    return ImageBasedLighting;
}());
exports.ImageBasedLighting = ImageBasedLighting;


/***/ }),

/***/ "./src/lighting/light-type.ts":
/*!************************************!*\
  !*** ./src/lighting/light-type.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LightType = void 0;
var LightType;
(function (LightType) {
    /**
     * A light that is located at a point and emits light in a cone shape.
     */
    LightType["spot"] = "spot";
    /**
     * A light that is located infinitely far away, and emits light in one
     * direction only.
     */
    LightType["directional"] = "directional";
    /**
     * A light that is located at a point and emits light in all directions
     * equally.
     */
    LightType["point"] = "point";
    /**
     * A light that is present all around the scene and doesnt come from
     * any specific source object.
     */
    LightType["ambient"] = "ambient";
})(LightType = exports.LightType || (exports.LightType = {}));


/***/ }),

/***/ "./src/lighting/light.ts":
/*!*******************************!*\
  !*** ./src/lighting/light.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Light = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var color_1 = __webpack_require__(/*! ../color */ "./src/color.ts");
var container_1 = __webpack_require__(/*! ../container */ "./src/container.ts");
var light_type_1 = __webpack_require__(/*! ./light-type */ "./src/lighting/light-type.ts");
var Light = /** @class */ (function (_super) {
    tslib_1.__extends(Light, _super);
    function Light() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The type of the light. */
        _this.type = light_type_1.LightType.point;
        /** The color of the light. */
        _this.color = new color_1.Color(1, 1, 1);
        /** The range of the light. */
        _this.range = 10;
        /** The intensity of the light. */
        _this.intensity = 10;
        /** The inner cone angle specified in degrees. */
        _this.innerConeAngle = 0;
        /** The outer cone angle specified in degrees. */
        _this.outerConeAngle = 45;
        return _this;
    }
    return Light;
}(container_1.Container3D));
exports.Light = Light;


/***/ }),

/***/ "./src/lighting/lighting-environment.ts":
/*!**********************************************!*\
  !*** ./src/lighting/lighting-environment.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LightingEnvironment = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
/**
 * A lighting environment represents the different lighting conditions for a
 * specific object or an entire scene.
 */
var LightingEnvironment = /** @class */ (function () {
    /**
     * Creates a new lighting environment using the specified renderer.
     * @param renderer The renderer to use.
     */
    function LightingEnvironment(renderer, imageBasedLighting) {
        var _this = this;
        this.renderer = renderer;
        /** The lights affecting this lighting environment. */
        this.lights = [];
        this.renderer.on("prerender", function () {
            var e_1, _a;
            try {
                for (var _b = tslib_1.__values(_this.lights), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var light = _c.value;
                    // Make sure the transform has been updated in the case where the light
                    // is not part of the stage hierarchy.
                    if (!light.parent) {
                        light.transform.updateTransform();
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        if (!LightingEnvironment.main) {
            LightingEnvironment.main = this;
        }
        this._imageBasedLighting = imageBasedLighting;
    }
    Object.defineProperty(LightingEnvironment.prototype, "imageBasedLighting", {
        get: function () {
            return this._imageBasedLighting;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightingEnvironment.prototype, "valid", {
        /** Value indicating if this object is valid to be used for rendering. */
        get: function () {
            return !this._imageBasedLighting || this._imageBasedLighting.valid;
        },
        enumerable: false,
        configurable: true
    });
    LightingEnvironment.prototype.destroy = function () {
    };
    return LightingEnvironment;
}());
exports.LightingEnvironment = LightingEnvironment;
PIXI.Renderer.registerPlugin("lighting", LightingEnvironment);


/***/ }),

/***/ "./src/loader/cubemap-loader.ts":
/*!**************************************!*\
  !*** ./src/loader/cubemap-loader.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CubemapLoader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var cubemap_1 = __webpack_require__(/*! ../cubemap/cubemap */ "./src/cubemap/cubemap.ts");
exports.CubemapLoader = {
    use: function (resource, next) {
        if (resource.extension !== "cubemap") {
            return next();
        }
        var loader = this;
        var mipmaps = resource.data.map(function (mipmap) {
            return cubemap_1.Cubemap.faces.map(function (face) {
                return resource.url.substring(0, resource.url.lastIndexOf("/") + 1) + mipmap.replace("{{face}}", face);
            });
        });
        // The list of urls (faces and mipmaps) which needs to be loaded before the 
        // cubemap should be created.
        var urls = mipmaps.reduce(function (acc, val) { return acc.concat(val); }, []);
        loader.add(urls.filter(function (url) { return !loader.resources[url]; }).map(function (url) {
            return { parentResource: resource, url: url };
        }));
        var completed = 0;
        // Listen for resources being loaded.
        var binding = loader.onLoad.add(function (loader, res) {
            if (urls.includes(res.url)) {
                if (++completed === urls.length) {
                    // All resources used by cubemap has been loaded.
                    var textures = mipmaps.map(function (face) {
                        return {
                            posx: PIXI.Texture.from(face[0]),
                            negx: PIXI.Texture.from(face[1]),
                            posy: PIXI.Texture.from(face[2]),
                            negy: PIXI.Texture.from(face[3]),
                            posz: PIXI.Texture.from(face[4]),
                            negz: PIXI.Texture.from(face[5]),
                        };
                    });
                    resource.cubemap = cubemap_1.Cubemap.fromFaces(textures);
                    binding.detach();
                }
            }
        });
        next();
    },
    add: function () {
        PIXI.LoaderResource.setExtensionXhrType("cubemap", PIXI.LoaderResource.XHR_RESPONSE_TYPE.JSON);
    }
};
PIXI.Loader.registerPlugin(exports.CubemapLoader);


/***/ }),

/***/ "./src/loader/gltf-binary-loader.ts":
/*!******************************************!*\
  !*** ./src/loader/gltf-binary-loader.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFBinaryLoader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var gltf_asset_1 = __webpack_require__(/*! ../gltf/gltf-asset */ "./src/gltf/gltf-asset.ts");
exports.glTFBinaryLoader = {
    use: function (resource, next) {
        if (resource.extension !== "glb") {
            return next();
        }
        if (gltf_asset_1.glTFAsset.isValid(resource.data)) {
            gltf_asset_1.glTFAsset.fromBuffer(resource.data, function (gltf) {
                Object.assign(resource, { gltf: gltf });
            });
        }
        next();
    },
    add: function () {
        PIXI.LoaderResource.setExtensionXhrType("glb", PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
    }
};
PIXI.Loader.registerPlugin(exports.glTFBinaryLoader);


/***/ }),

/***/ "./src/loader/gltf-loader.ts":
/*!***********************************!*\
  !*** ./src/loader/gltf-loader.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.glTFLoader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var gltf_asset_1 = __webpack_require__(/*! ../gltf/gltf-asset */ "./src/gltf/gltf-asset.ts");
exports.glTFLoader = {
    use: function (resource, next) {
        if (resource.extension !== "gltf") {
            return next();
        }
        var loader = this;
        Object.assign(resource, {
            gltf: gltf_asset_1.glTFAsset.load(resource.data, new glTFExternalResourceLoader(loader, resource))
        });
        next();
    },
    add: function () {
        PIXI.LoaderResource.setExtensionXhrType("bin", PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
        PIXI.LoaderResource.setExtensionXhrType("gltf", PIXI.LoaderResource.XHR_RESPONSE_TYPE.JSON);
    }
};
PIXI.Loader.registerPlugin(exports.glTFLoader);
var glTFExternalResourceLoader = /** @class */ (function () {
    function glTFExternalResourceLoader(_loader, _resource) {
        this._loader = _loader;
        this._resource = _resource;
    }
    glTFExternalResourceLoader.prototype.load = function (uri, onComplete) {
        var url = this._resource.url.substring(0, this._resource.url.lastIndexOf("/") + 1) + uri;
        if (!this._loader.resources[url]) {
            // The resource does not exists and needs to be loaded.
            // @ts-ignore
            this._loader.add({ parentResource: this._resource, url: url, onComplete: onComplete });
        }
        else if (this._loader.resources[url].data) {
            // The resource already exists, just use that one.
            onComplete(this._loader.resources[url]);
        }
        else {
            // The resource is in queue to be loaded, wait for it.
            var binding_1 = this._loader.onProgress.add(function (l, resource) {
                if (resource.url === url) {
                    onComplete(resource);
                    binding_1.detach();
                }
            });
        }
    };
    return glTFExternalResourceLoader;
}());


/***/ }),

/***/ "./src/loader/shader-source-loader.ts":
/*!********************************************!*\
  !*** ./src/loader/shader-source-loader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShaderSourceLoader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var EXTENSIONS = ["glsl", "vert", "frag"];
exports.ShaderSourceLoader = {
    use: function (resource, next) {
        if (!EXTENSIONS.includes(resource.extension)) {
            return next();
        }
        next();
    },
    add: function () {
        var e_1, _a;
        try {
            for (var EXTENSIONS_1 = tslib_1.__values(EXTENSIONS), EXTENSIONS_1_1 = EXTENSIONS_1.next(); !EXTENSIONS_1_1.done; EXTENSIONS_1_1 = EXTENSIONS_1.next()) {
                var ext = EXTENSIONS_1_1.value;
                PIXI.LoaderResource.setExtensionXhrType(ext, PIXI.LoaderResource.XHR_RESPONSE_TYPE.TEXT);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (EXTENSIONS_1_1 && !EXTENSIONS_1_1.done && (_a = EXTENSIONS_1.return)) _a.call(EXTENSIONS_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
};
PIXI.Loader.registerPlugin(exports.ShaderSourceLoader);


/***/ }),

/***/ "./src/material/material-render-sort-type.ts":
/*!***************************************************!*\
  !*** ./src/material/material-render-sort-type.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MaterialRenderSortType = void 0;
var MaterialRenderSortType;
(function (MaterialRenderSortType) {
    MaterialRenderSortType["opaque"] = "opaque";
    MaterialRenderSortType["transparent"] = "transparent";
})(MaterialRenderSortType = exports.MaterialRenderSortType || (exports.MaterialRenderSortType = {}));


/***/ }),

/***/ "./src/material/material.ts":
/*!**********************************!*\
  !*** ./src/material/material.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Material = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var material_render_sort_type_1 = __webpack_require__(/*! ./material-render-sort-type */ "./src/material/material-render-sort-type.ts");
/**
 * Materials are used to render a mesh with a specific visual appearance.
 */
var Material = /** @class */ (function () {
    function Material() {
        this._renderSortType = material_render_sort_type_1.MaterialRenderSortType.opaque;
        /** State used to render a mesh. */
        this.state = Object.assign(new PIXI.State(), {
            culling: true, clockwiseFrontFace: false, depthTest: true
        });
        /** Draw mode used to render a mesh. */
        this.drawMode = PIXI.DRAW_MODES.TRIANGLES;
    }
    Object.defineProperty(Material.prototype, "renderSortType", {
        /**
         * Sort type used to render a mesh. This will determine in which order the
         * material is being rendered compared to other materials. Setting this to
         * "transparent" will also disable writing to depth buffer (only available
         * in PixiJS 6.0+).
         */
        get: function () {
            return this._renderSortType;
        },
        set: function (value) {
            this._renderSortType = value;
            // Depth mask feature is only available in PixiJS 6.0+ and won't have
            // any effects in previous versions.
            if (value === material_render_sort_type_1.MaterialRenderSortType.opaque) {
                this.state.depthMask = true;
            }
            else {
                this.state.depthMask = false;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "doubleSided", {
        /** Value indicating if the material is double sided. */
        get: function () {
            return !this.state.culling;
        },
        set: function (value) {
            this.state.culling = !value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendMode", {
        /** Blend mode used to render a mesh. */
        get: function () {
            return this.state.blendMode;
        },
        set: function (value) {
            this.state.blendMode = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Destroys the material and it's used resources.
     */
    Material.prototype.destroy = function () { };
    Object.defineProperty(Material.prototype, "isInstancingSupported", {
        /**
         * Returns a value indicating if this material supports instancing.
         */
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new instanced version of this material.
     */
    Material.prototype.createInstance = function () {
        return undefined;
    };
    /**
     * Renders the specified mesh.
     * @param mesh The mesh to render.
     * @param renderer The renderer to use.
     */
    Material.prototype.render = function (mesh, renderer) {
        if (!this._shader) {
            this._shader = this.createShader(mesh, renderer);
            if (!this._shader) {
                // The shader couldn't be created for some reason. Just ignore it and 
                // try again at next render. The required assets may not have been loaded 
                // yet, so maybe we are waiting for those.
                return;
            }
        }
        if (this.updateUniforms) {
            this.updateUniforms(mesh, this._shader);
        }
        this._shader.render(mesh, renderer, this.state, this.drawMode);
    };
    return Material;
}());
exports.Material = Material;


/***/ }),

/***/ "./src/material/standard/instanced-standard-material.ts":
/*!**************************************************************!*\
  !*** ./src/material/standard/instanced-standard-material.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InstancedStandardMaterial = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var color_1 = __webpack_require__(/*! ../../color */ "./src/color.ts");
var InstancedStandardMaterial = /** @class */ (function () {
    function InstancedStandardMaterial(material) {
        this.baseColor = new (color_1.Color.bind.apply(color_1.Color, tslib_1.__spreadArray([void 0], tslib_1.__read(material.baseColor.rgba))))();
    }
    return InstancedStandardMaterial;
}());
exports.InstancedStandardMaterial = InstancedStandardMaterial;


/***/ }),

/***/ "./src/material/standard/shader/metallic-roughness.frag":
/*!**************************************************************!*\
  !*** ./src/material/standard/shader/metallic-roughness.frag ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#version VERSION\n\n//\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n\n#define FEATURES\n\n#if defined(WEBGL1) //&& defined(USE_TEX_LOD)\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n\n#if defined(WEBGL1)\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#if defined(WEBGL1) && defined(USE_HDR)\n#extension GL_OES_texture_float : enable\n#extension GL_OES_texture_float_linear : enable\n#endif\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvec4 _texture(sampler2D sampler, vec2 coord)\n{\n#ifdef WEBGL2\n    return texture(sampler, coord);\n#else\n    return texture2D(sampler, coord);\n#endif\n}\n\nvec4 _texture(samplerCube sampler, vec3 coord)\n{\n#ifdef WEBGL2\n    return texture(sampler, coord);\n#else\n    return textureCube(sampler, coord);\n#endif\n}\nvec4 _textureLod(sampler2D sampler, vec2 coord, float lod)\n{\n#ifdef WEBGL2\n    return textureLod(sampler, coord, lod);\n#endif\n#if defined(WEBGL1) && defined(GL_EXT_shader_texture_lod) \n    return texture2DLodEXT(sampler, coord, lod);\n#endif\n    return vec4(0.0);\n}\n\nvec4 _textureLod(samplerCube sampler, vec3 coord, float lod)\n{\n#ifdef WEBGL2\n    return textureLod(sampler, coord, lod);\n#endif\n#if defined(WEBGL1) && defined(GL_EXT_shader_texture_lod) \n    return textureCubeLodEXT(sampler, coord, lod);\n#endif\n    return vec4(0.0);\n}\nvec3 _dFdx(vec3 coord)\n{\n#if defined(WEBGL2) || defined(GL_OES_standard_derivatives)\n    return dFdx(coord);\n#endif\n    return vec3(0.0);\n}\n\nvec3 _dFdy(vec3 coord)\n{\n#if defined(WEBGL2) || defined(GL_OES_standard_derivatives)\n    return dFdy(coord);\n#endif\n    return vec3(0.0);\n}\nFRAG_IN vec2 v_UVCoord1;\nFRAG_IN vec2 v_UVCoord2;\n\n// General Material\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\nuniform int u_NormalUVSet;\nuniform mat3 u_NormalUVTransform;\n#endif\n\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D u_EmissiveSampler;\nuniform int u_EmissiveUVSet;\nuniform vec3 u_EmissiveFactor;\nuniform mat3 u_EmissiveUVTransform;\n#endif\n\n#ifdef HAS_OCCLUSION_MAP\nuniform sampler2D u_OcclusionSampler;\nuniform int u_OcclusionUVSet;\nuniform float u_OcclusionStrength;\nuniform mat3 u_OcclusionUVTransform;\n#endif\n\n// Metallic Roughness Material\n#ifdef HAS_BASE_COLOR_MAP\nuniform sampler2D u_BaseColorSampler;\nuniform int u_BaseColorUVSet;\nuniform mat3 u_BaseColorUVTransform;\n#endif\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\nuniform sampler2D u_MetallicRoughnessSampler;\nuniform int u_MetallicRoughnessUVSet;\nuniform mat3 u_MetallicRoughnessUVTransform;\n#endif\n\n// Specular Glossiness Material\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D u_DiffuseSampler;\nuniform int u_DiffuseUVSet;\nuniform mat3 u_DiffuseUVTransform;\n#endif\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\nuniform sampler2D u_SpecularGlossinessSampler;\nuniform int u_SpecularGlossinessUVSet;\nuniform mat3 u_SpecularGlossinessUVTransform;\n#endif\n\n// IBL\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\n#endif\n\n#ifdef USE_SHADOW_MAPPING\nuniform sampler2D u_ShadowSampler;\n#endif\n\nvec2 getNormalUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_NORMAL_MAP\n    uv.xy = u_NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_NORMAL_UV_TRANSFORM\n    uv *= u_NormalUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getEmissiveUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_EMISSIVE_MAP\n    uv.xy = u_EmissiveUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_EMISSIVE_UV_TRANSFORM\n    uv *= u_EmissiveUVTransform;\n    #endif\n#endif\n\n    return uv.xy;\n}\n\nvec2 getOcclusionUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_OCCLUSION_MAP\n    uv.xy = u_OcclusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_OCCLUSION_UV_TRANSFORM\n    uv *= u_OcclusionUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getBaseColorUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_BASE_COLOR_MAP\n    uv.xy = u_BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_BASECOLOR_UV_TRANSFORM\n    uv *= u_BaseColorUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getMetallicRoughnessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    uv.xy = u_MetallicRoughnessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM\n    uv *= u_MetallicRoughnessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getSpecularGlossinessUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    uv.xy = u_SpecularGlossinessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\n    uv *= u_SpecularGlossinessUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\nvec2 getDiffuseUV()\n{\n    vec3 uv = vec3(v_UVCoord1, 1.0);\n#ifdef HAS_DIFFUSE_MAP\n    uv.xy = u_DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\n    #ifdef HAS_DIFFUSE_UV_TRANSFORM\n    uv *= u_DiffuseUVTransform;\n    #endif\n#endif\n    return uv.xy;\n}\n\n// textures.glsl needs to be included\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinReflectance = 0.04;\n\nFRAG_IN vec3 v_Position;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nFRAG_IN mat3 v_TBN;\n#else\nFRAG_IN vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nFRAG_IN vec3 v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\nFRAG_IN vec4 v_Color;\n#endif\n\nstruct AngularInfo\n{\n    float NdotL;                  // cos angle between normal and light direction\n    float NdotV;                  // cos angle between normal and view direction\n    float NdotH;                  // cos angle between normal and half vector\n    float LdotH;                  // cos angle between light direction and half vector\n\n    float VdotH;                  // cos angle between view direction and half vector\n\n    vec3 padding;\n};\n\nvec4 getVertexColor()\n{\n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef HAS_VERTEX_COLOR_VEC3\n    color.rgb = v_Color;\n#endif\n#ifdef HAS_VERTEX_COLOR_VEC4\n    color = v_Color;\n#endif\n\n   return color;\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n    vec2 UV = getNormalUV();\n\n    // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n    vec3 pos_dx = _dFdx(v_Position);\n    vec3 pos_dy = _dFdy(v_Position);\n    vec3 tex_dx = _dFdx(vec3(UV, 0.0));\n    vec3 tex_dy = _dFdy(vec3(UV, 0.0));\n    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n    vec3 ng = normalize(v_Normal);\n#else\n    vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n    t = normalize(t - ng * dot(ng, t));\n    vec3 b = normalize(cross(ng, t));\n    mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n    mat3 tbn = v_TBN;\n#endif\n\n#ifdef HAS_NORMAL_MAP\n    vec3 n = _texture(u_NormalSampler, UV).rgb;\n    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n    // The tbn matrix is linearly interpolated, so we need to re-normalize\n    vec3 n = normalize(tbn[2].xyz);\n#endif\n\n    return n;\n}\n\nfloat getPerceivedBrightness(vec3 vector)\n{\n    return sqrt(0.299 * vector.r * vector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34\nfloat solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecularStrength) {\n    float specularBrightness = getPerceivedBrightness(specular);\n\n    if (specularBrightness < c_MinReflectance) {\n        return 0.0;\n    }\n\n    float diffuseBrightness = getPerceivedBrightness(diffuse);\n\n    float a = c_MinReflectance;\n    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;\n    float c = c_MinReflectance - specularBrightness;\n    float D = b * b - 4.0 * a * c;\n\n    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);\n}\n\nAngularInfo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)\n{\n    // Standard one-letter names\n    vec3 n = normalize(normal);           // Outward direction of surface point\n    vec3 v = normalize(view);             // Direction from surface point to view\n    vec3 l = normalize(pointToLight);     // Direction from surface point to light\n    vec3 h = normalize(l + v);            // Direction of the vector between l and v\n\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    return AngularInfo(\n        NdotL,\n        NdotV,\n        NdotH,\n        LdotH,\n        VdotH,\n        vec3(0, 0, 0)\n    );\n}\n\n#ifdef USE_SHADOW_MAPPING\nFRAG_IN vec4 v_PositionLightSpace;\n#endif\n\nfloat linstep(float low, float high, float v)\n{\n    return clamp((v-low) / (high-low), 0.0, 1.0);\n}\n\n#ifdef USE_SHADOW_MAPPING\nfloat getShadowContribution()\n{\n    vec3 coords = v_PositionLightSpace.xyz / v_PositionLightSpace.w * 0.5 + 0.5;\n    if (coords.z < 0.01 || coords.z > 0.99 || coords.x < 0.01 || coords.x > 0.99 || coords.y < 0.01 || coords.y > 0.99) {\n        return 1.0;\n    }\n    vec2 moments = vec2(1.0) - _texture(u_ShadowSampler, coords.xy).xy;\n    float p = step(coords.z, moments.x);\n    float variance = max(moments.y - moments.x * moments.x, 0.00002);\n    float d = coords.z - moments.x;\n    float pMax = linstep(0.2, 1.0, variance / (variance + d*d));\n    return min(max(p, pMax), 1.0);\n}\n#endif\nuniform float u_Exposure;\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\n// linear to sRGB approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec3 LINEARtoSRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\n// sRGB to linear approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\n// Uncharted 2 tone map\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapUncharted2Impl(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;\n}\n\nvec3 toneMapUncharted(vec3 color)\n{\n    const float W = 11.2;\n    color = toneMapUncharted2Impl(color * 2.0);\n    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\n    return LINEARtoSRGB(color * whiteScale);\n}\n\n// Hejl Richard tone map\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 toneMapHejlRichard(vec3 color)\n{\n    color = max(vec3(0.0), color - vec3(0.004));\n    return (color*(6.2*color+.5))/(color*(6.2*color+1.7)+0.06);\n}\n\n// ACES tone map\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return LINEARtoSRGB(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0));\n}\n\nvec3 toneMap(vec3 color)\n{\n    color *= u_Exposure;\n\n#ifdef TONEMAP_UNCHARTED\n    return toneMapUncharted(color);\n#endif\n\n#ifdef TONEMAP_HEJLRICHARD\n    return toneMapHejlRichard(color);\n#endif\n\n#ifdef TONEMAP_ACES\n    return toneMapACES(color);\n#endif\n\n    return LINEARtoSRGB(color);\n}\n\n\n// KHR_lights_punctual extension.\n// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nstruct Light\n{\n    vec3 direction;\n    float range;\n\n    vec3 color;\n    float intensity;\n\n    vec3 position;\n    float innerConeCos;\n\n    float outerConeCos;\n    int type;\n\n    vec2 padding;\n};\n\nconst int LightType_Directional = 0;\nconst int LightType_Point = 1;\nconst int LightType_Spot = 2;\nconst int LightType_Ambient = 3;\n\n#ifdef USE_PUNCTUAL\nuniform Light u_Lights[LIGHT_COUNT];\n#endif\n\n#if defined(MATERIAL_SPECULARGLOSSINESS) || defined(MATERIAL_METALLICROUGHNESS)\nuniform float u_MetallicFactor;\nuniform float u_RoughnessFactor;\nuniform vec4 u_BaseColorFactor;\n#endif\n\n#ifdef USE_INSTANCING\nFRAG_IN vec4 v_BaseColorFactor;\n#endif\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\nuniform vec3 u_SpecularFactor;\nuniform vec4 u_DiffuseFactor;\nuniform float u_GlossinessFactor;\n#endif\n\n#ifdef ALPHAMODE_MASK\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec3 u_Camera;\n\nuniform int u_MipCount;\n\nstruct MaterialInfo\n{\n    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n    vec3 reflectance0;            // full reflectance color (normal incidence angle)\n\n    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n    vec3 diffuseColor;            // color contribution from diffuse lighting\n\n    vec3 reflectance90;           // reflectance color at grazing angle\n    vec3 specularColor;           // color contribution from specular lighting\n};\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)\n{\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\n\n    float lod = clamp(materialInfo.perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    // retrieve a scale and bias to F0. See [1], Figure 3\n    vec2 brdf = _texture(u_brdfLUT, brdfSamplePoint).rg;\n\n    vec4 diffuseSample = _texture(u_DiffuseEnvSampler, n);\n\n#ifdef USE_TEX_LOD\n    vec4 specularSample = _textureLod(u_SpecularEnvSampler, reflection, lod);\n#else\n    vec4 specularSample = _texture(u_SpecularEnvSampler, reflection);\n#endif\n\n#ifdef USE_HDR\n    // Already linear.\n    vec3 diffuseLight = diffuseSample.rgb;\n    vec3 specularLight = specularSample.rgb;\n#else\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\n    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;\n#endif\n\n    vec3 diffuse = diffuseLight * materialInfo.diffuseColor;\n    vec3 specular = specularLight * (materialInfo.specularColor * brdf.x + brdf.y);\n\n    return diffuse + specular;\n}\n#endif\n\n// Lambert lighting\n// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\nvec3 diffuse(MaterialInfo materialInfo)\n{\n    return materialInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    return materialInfo.reflectance0 + (materialInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat visibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float NdotL = angularInfo.NdotL;\n    float NdotV = angularInfo.NdotV;\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(MaterialInfo materialInfo, AngularInfo angularInfo)\n{\n    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\n    float f = (angularInfo.NdotH * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nvec3 getPointShade(vec3 pointToLight, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    AngularInfo angularInfo = getAngularInfo(pointToLight, normal, view);\n\n    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)\n    {\n        // Calculate the shading terms for the microfacet specular shading model\n        vec3 F = specularReflection(materialInfo, angularInfo);\n        float Vis = visibilityOcclusion(materialInfo, angularInfo);\n        float D = microfacetDistribution(materialInfo, angularInfo);\n\n        // Calculation of analytical lighting contribution\n        vec3 diffuseContrib = (1.0 - F) * diffuse(materialInfo);\n        vec3 specContrib = F * Vis * D;\n\n        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n        return angularInfo.NdotL * (diffuseContrib + specContrib);\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(float range, float distance)\n{\n    if (range <= 0.0)\n    {\n        // negative range means unlimited\n        return 1.0;\n    }\n    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)\n{\n    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));\n    if (actualCos > outerConeCos)\n    {\n        if (actualCos < innerConeCos)\n        {\n            return smoothstep(outerConeCos, innerConeCos, actualCos);\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 applyDirectionalLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = -light.direction;\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return light.intensity * light.color * shade;\n}\n\nvec3 applyPointLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float attenuation = getRangeAttenuation(light.range, distance);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);\n    return attenuation * light.intensity * light.color * shade;\n}\n\nvec3 applySpotLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)\n{\n    vec3 pointToLight = light.position - v_Position;\n    float distance = length(pointToLight);\n    float rangeAttenuation = getRangeAttenuation(light.range, distance);\n    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;\n    return rangeAttenuation * spotAttenuation * light.intensity * light.color * shade;\n}\n\nvec3 applyAmbientLight(Light light, MaterialInfo materialInfo)\n{\n    return light.intensity * light.color * diffuse(materialInfo);\n}\n\n#ifdef WEBGL2\n    out vec4 FRAG_COLOR;\n#endif\n\nvoid main()\n{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = 0.0;\n    float metallic = 0.0;\n    vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 specularColor= vec3(0.0);\n    vec3 f0 = vec3(0.04);\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    vec4 sgSample = SRGBtoLINEAR(_texture(u_SpecularGlossinessSampler, getSpecularGlossinessUV()));\n    perceptualRoughness = (1.0 - sgSample.a * u_GlossinessFactor); // glossiness to roughness\n    f0 = sgSample.rgb * u_SpecularFactor; // specular\n#else\n    f0 = u_SpecularFactor;\n    perceptualRoughness = 1.0 - u_GlossinessFactor;\n#endif // ! HAS_SPECULAR_GLOSSINESS_MAP\n\n#ifdef HAS_DIFFUSE_MAP\n    baseColor = SRGBtoLINEAR(_texture(u_DiffuseSampler, getDiffuseUV())) * u_DiffuseFactor;\n#else\n    baseColor = u_DiffuseFactor;\n#endif // !HAS_DIFFUSE_MAP\n\n    baseColor *= getVertexColor();\n\n    // f0 = specular\n    specularColor = f0;\n    float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);\n    diffuseColor = baseColor.rgb * oneMinusSpecularStrength;\n\n#ifdef DEBUG_METALLIC\n    // do conversion between metallic M-R and S-G metallic\n    metallic = solveMetallic(baseColor.rgb, specularColor, oneMinusSpecularStrength);\n#endif // ! DEBUG_METALLIC\n\n#endif // ! MATERIAL_SPECULARGLOSSINESS\n\n#ifdef MATERIAL_METALLICROUGHNESS\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = _texture(u_MetallicRoughnessSampler, getMetallicRoughnessUV());\n    perceptualRoughness = mrSample.g * u_RoughnessFactor;\n    metallic = mrSample.b * u_MetallicFactor;\n#else\n    metallic = u_MetallicFactor;\n    perceptualRoughness = u_RoughnessFactor;\n#endif\n\n    vec4 baseColorFactor = u_BaseColorFactor;\n#ifdef USE_INSTANCING\n    baseColorFactor = v_BaseColorFactor;\n#endif\n\n    // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASE_COLOR_MAP\n    baseColor = SRGBtoLINEAR(_texture(u_BaseColorSampler, getBaseColorUV())) * baseColorFactor;\n#else\n    baseColor = baseColorFactor;\n#endif\n\n    baseColor *= getVertexColor();\n\n    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);\n\n    specularColor = mix(f0, baseColor.rgb, metallic);\n\n#endif // ! MATERIAL_METALLICROUGHNESS\n\n#ifdef ALPHAMODE_MASK\n    if(baseColor.a < u_AlphaCutoff)\n    {\n        discard;\n    }\n    baseColor.a = 1.0;\n#endif\n\n#ifdef ALPHAMODE_OPAQUE\n    baseColor.a = 1.0;\n#endif\n\n#ifdef MATERIAL_UNLIT\n    FRAG_COLOR = vec4(LINEARtoSRGB(baseColor.rgb) * baseColor.a, baseColor.a);\n    return;\n#endif\n\n    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));\n\n    MaterialInfo materialInfo = MaterialInfo(\n        perceptualRoughness,\n        specularEnvironmentR0,\n        alphaRoughness,\n        diffuseColor,\n        specularEnvironmentR90,\n        specularColor\n    );\n\n    // LIGHTING\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 normal = getNormal();\n    vec3 view = normalize(u_Camera - v_Position);\n\n    float shadow = 1.0;\n    #ifdef USE_SHADOW_MAPPING\n        shadow = getShadowContribution();\n    #endif\n\n#ifdef USE_PUNCTUAL\n    for (int i = 0; i < LIGHT_COUNT; ++i)\n    {\n        Light light = u_Lights[i];\n        if (light.type == LightType_Directional)\n        {\n            color += applyDirectionalLight(light, materialInfo, normal, view, shadow);\n        }\n        else if (light.type == LightType_Point)\n        {\n            color += applyPointLight(light, materialInfo, normal, view);\n        }\n        else if (light.type == LightType_Spot)\n        {\n            color += applySpotLight(light, materialInfo, normal, view, shadow);\n        }\n        else if (light.type == LightType_Ambient) \n        {\n \t\t\tcolor += applyAmbientLight(light, materialInfo);\n \t\t}\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    color += getIBLContribution(materialInfo, normal, view);\n#endif\n\n    float ao = 1.0;\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSION_MAP\n    ao = _texture(u_OcclusionSampler,  getOcclusionUV()).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n    vec3 emissive = vec3(0);\n#ifdef HAS_EMISSIVE_MAP\n    emissive = SRGBtoLINEAR(_texture(u_EmissiveSampler, getEmissiveUV())).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifndef DEBUG_OUTPUT // no debug\n\n   // regular shading\n    FRAG_COLOR = vec4(toneMap(color) * baseColor.a, baseColor.a);\n\n#else // debug output\n\n    #ifdef DEBUG_METALLIC\n        FRAG_COLOR.rgb = vec3(metallic);\n    #endif\n\n    #ifdef DEBUG_ROUGHNESS\n        FRAG_COLOR.rgb = vec3(perceptualRoughness);\n    #endif\n\n    #ifdef DEBUG_NORMAL\n        #ifdef HAS_NORMAL_MAP\n            FRAG_COLOR.rgb = _texture(u_NormalSampler, getNormalUV()).rgb;\n        #else\n            FRAG_COLOR.rgb = vec3(0.5, 0.5, 1.0);\n        #endif\n    #endif\n\n    #ifdef DEBUG_BASECOLOR\n        FRAG_COLOR.rgb = LINEARtoSRGB(baseColor.rgb);\n    #endif\n\n    #ifdef DEBUG_OCCLUSION\n        FRAG_COLOR.rgb = vec3(ao);\n    #endif\n\n    #ifdef DEBUG_EMISSIVE\n        FRAG_COLOR.rgb = LINEARtoSRGB(emissive);\n    #endif\n\n    #ifdef DEBUG_F0\n        FRAG_COLOR.rgb = vec3(f0);\n    #endif\n\n    #ifdef DEBUG_ALPHA\n        FRAG_COLOR.rgb = vec3(baseColor.a);\n    #endif\n\n    FRAG_COLOR.a = 1.0;\n\n#endif // !DEBUG_OUTPUT\n}\n"

/***/ }),

/***/ "./src/material/standard/shader/primitive.vert":
/*!*****************************************************!*\
  !*** ./src/material/standard/shader/primitive.vert ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#version VERSION\n\n#define FEATURES\n\nvec4 _texture(sampler2D sampler, vec2 coord)\n{\n#ifdef WEBGL2\n    return texture(sampler, coord);\n#else\n    return texture2D(sampler, coord);\n#endif\n}\n\nvec4 _texture(samplerCube sampler, vec3 coord)\n{\n#ifdef WEBGL2\n    return texture(sampler, coord);\n#else\n    return textureCube(sampler, coord);\n#endif\n}\n#ifdef HAS_TARGET_POSITION0\nVERT_IN vec3 a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\nVERT_IN vec3 a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\nVERT_IN vec3 a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\nVERT_IN vec3 a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\nVERT_IN vec3 a_Target_Position4;\n#endif\n\n#ifdef HAS_TARGET_POSITION5\nVERT_IN vec3 a_Target_Position5;\n#endif\n\n#ifdef HAS_TARGET_POSITION6\nVERT_IN vec3 a_Target_Position6;\n#endif\n\n#ifdef HAS_TARGET_POSITION7\nVERT_IN vec3 a_Target_Position7;\n#endif\n\n#ifdef HAS_TARGET_NORMAL0\nVERT_IN vec3 a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\nVERT_IN vec3 a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\nVERT_IN vec3 a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\nVERT_IN vec3 a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT0\nVERT_IN vec3 a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\nVERT_IN vec3 a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\nVERT_IN vec3 a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\nVERT_IN vec3 a_Target_Tangent3;\n#endif\n\n#ifdef USE_MORPHING\nuniform float u_morphWeights[WEIGHT_COUNT];\n#endif\n\n#ifdef HAS_JOINT_SET1\nVERT_IN vec4 a_Joint1;\n#endif\n\n#ifdef HAS_JOINT_SET2\nVERT_IN vec4 a_Joint2;\n#endif\n\n#ifdef HAS_WEIGHT_SET1\nVERT_IN vec4 a_Weight1;\n#endif\n\n#ifdef HAS_WEIGHT_SET2\nVERT_IN vec4 a_Weight2;\n#endif\n\n#ifdef USE_SKINNING\n#ifdef USE_SKINNING_TEXTURE\nuniform sampler2D u_jointMatrixSampler;\nuniform sampler2D u_jointNormalMatrixSampler;\n#else\nuniform mat4 u_jointMatrix[JOINT_COUNT];\nuniform mat4 u_jointNormalMatrix[JOINT_COUNT];\n#endif\n#endif\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.0)\n#define ROW1_U ((0.5 + 1.0) / 4.0)\n#define ROW2_U ((0.5 + 2.0) / 4.0)\n#define ROW3_U ((0.5 + 3.0) / 4.0)\n\n#ifdef USE_SKINNING\nmat4 getJointMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(JOINT_COUNT);\n    return mat4(\n        _texture(u_jointMatrixSampler, vec2(ROW0_U, v)) * 2.0 - 1.0,\n        _texture(u_jointMatrixSampler, vec2(ROW1_U, v)) * 2.0 - 1.0,\n        _texture(u_jointMatrixSampler, vec2(ROW2_U, v)) * 2.0 - 1.0,\n        _texture(u_jointMatrixSampler, vec2(ROW3_U, v)) * 2.0 - 1.0\n    );\n    #else\n    return u_jointMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getJointNormalMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(JOINT_COUNT);\n    return mat4(\n        _texture(u_jointNormalMatrixSampler, vec2(ROW0_U, v)) * 2.0 - 1.0,\n        _texture(u_jointNormalMatrixSampler, vec2(ROW1_U, v)) * 2.0 - 1.0,\n        _texture(u_jointNormalMatrixSampler, vec2(ROW2_U, v)) * 2.0 - 1.0,\n        _texture(u_jointNormalMatrixSampler, vec2(ROW3_U, v)) * 2.0 - 1.0\n    );\n    #else\n    return u_jointNormalMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * getJointMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointMatrix(a_Joint1.w);\n    #endif\n\n    return skin;\n}\n\nmat4 getSkinningNormalMatrix()\n{\n    mat4 skin = mat4(0);\n\n    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)\n    skin +=\n        a_Weight1.x * getJointNormalMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointNormalMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointNormalMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointNormalMatrix(a_Joint1.w);\n    #endif\n\n    return skin;\n}\n#endif // !USE_SKINNING\n\n#ifdef USE_MORPHING\nvec4 getTargetPosition()\n{\n    vec4 pos = vec4(0);\n\n#ifdef HAS_TARGET_POSITION0\n    pos.xyz += u_morphWeights[0] * a_Target_Position0;\n#endif\n\n#ifdef HAS_TARGET_POSITION1\n    pos.xyz += u_morphWeights[1] * a_Target_Position1;\n#endif\n\n#ifdef HAS_TARGET_POSITION2\n    pos.xyz += u_morphWeights[2] * a_Target_Position2;\n#endif\n\n#ifdef HAS_TARGET_POSITION3\n    pos.xyz += u_morphWeights[3] * a_Target_Position3;\n#endif\n\n#ifdef HAS_TARGET_POSITION4\n    pos.xyz += u_morphWeights[4] * a_Target_Position4;\n#endif\n\n    return pos;\n}\n\nvec4 getTargetNormal()\n{\n    vec4 normal = vec4(0);\n\n#ifdef HAS_TARGET_NORMAL0\n    normal.xyz += u_morphWeights[0] * a_Target_Normal0;\n#endif\n\n#ifdef HAS_TARGET_NORMAL1\n    normal.xyz += u_morphWeights[1] * a_Target_Normal1;\n#endif\n\n#ifdef HAS_TARGET_NORMAL2\n    normal.xyz += u_morphWeights[2] * a_Target_Normal2;\n#endif\n\n#ifdef HAS_TARGET_NORMAL3\n    normal.xyz += u_morphWeights[3] * a_Target_Normal3;\n#endif\n\n#ifdef HAS_TARGET_NORMAL4\n    normal.xyz += u_morphWeights[4] * a_Target_Normal4;\n#endif\n\n    return normal;\n}\n\nvec4 getTargetTangent()\n{\n    vec4 tangent = vec4(0);\n\n#ifdef HAS_TARGET_TANGENT0\n    tangent.xyz += u_morphWeights[0] * a_Target_Tangent0;\n#endif\n\n#ifdef HAS_TARGET_TANGENT1\n    tangent.xyz += u_morphWeights[1] * a_Target_Tangent1;\n#endif\n\n#ifdef HAS_TARGET_TANGENT2\n    tangent.xyz += u_morphWeights[2] * a_Target_Tangent2;\n#endif\n\n#ifdef HAS_TARGET_TANGENT3\n    tangent.xyz += u_morphWeights[3] * a_Target_Tangent3;\n#endif\n\n#ifdef HAS_TARGET_TANGENT4\n    tangent.xyz += u_morphWeights[4] * a_Target_Tangent4;\n#endif\n\n    return tangent;\n}\n\n#endif // !USE_MORPHING\n\n\nVERT_IN vec4 a_Position;\nVERT_OUT vec3 v_Position;\n\n#ifdef USE_INSTANCING\nVERT_IN vec4 a_ModelMatrix0;\nVERT_IN vec4 a_ModelMatrix1;\nVERT_IN vec4 a_ModelMatrix2;\nVERT_IN vec4 a_ModelMatrix3;\n#endif\n\n#ifdef USE_INSTANCING\nVERT_IN vec4 a_BaseColorFactor;\nVERT_OUT vec4 v_BaseColorFactor;\n#endif\n\n#ifdef USE_INSTANCING\nVERT_IN vec4 a_NormalMatrix0;\nVERT_IN vec4 a_NormalMatrix1;\nVERT_IN vec4 a_NormalMatrix2;\nVERT_IN vec4 a_NormalMatrix3;\n#endif\n\n#ifdef HAS_NORMALS\nVERT_IN vec4 a_Normal;\n#endif\n\n#ifdef HAS_TANGENTS\nVERT_IN vec4 a_Tangent;\n#endif\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nVERT_OUT mat3 v_TBN;\n#else\nVERT_OUT vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_UV_SET1\nVERT_IN vec2 a_UV1;\n#endif\n\n#ifdef HAS_UV_SET2\nVERT_IN vec2 a_UV2;\n#endif\n\nVERT_OUT vec2 v_UVCoord1;\nVERT_OUT vec2 v_UVCoord2;\n\n#ifdef HAS_VERTEX_COLOR_VEC3\nVERT_IN vec3 a_Color;\nVERT_OUT vec3 v_Color;\n#endif\n\n#ifdef HAS_VERTEX_COLOR_VEC4\nVERT_IN vec4 a_Color;\nVERT_OUT vec4 v_Color;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\n#ifdef USE_SHADOW_MAPPING\nuniform mat4 u_LightViewProjectionMatrix;\nVERT_OUT vec4 v_PositionLightSpace;\n#endif\n\nvec4 getPosition()\n{\n    vec4 pos = a_Position;\n\n#ifdef USE_MORPHING\n    pos += getTargetPosition();\n#endif\n\n#ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n#endif\n\n    return pos;\n}\n\n#ifdef HAS_NORMALS\nvec4 getNormal()\n{\n    vec4 normal = a_Normal;\n\n#ifdef USE_MORPHING\n    normal += getTargetNormal();\n#endif\n\n#ifdef USE_SKINNING\n    normal = getSkinningNormalMatrix() * normal;\n#endif\n\n    return normalize(normal);\n}\n#endif\n\n#ifdef HAS_TANGENTS\nvec4 getTangent()\n{\n    vec4 tangent = a_Tangent;\n\n#ifdef USE_MORPHING\n    tangent += getTargetTangent();\n#endif\n\n#ifdef USE_SKINNING\n    tangent = getSkinningMatrix() * tangent;\n#endif\n\n    return normalize(tangent);\n}\n#endif\n\nvoid main()\n{\n    mat4 modelMatrix = u_ModelMatrix;\n    #ifdef USE_INSTANCING\n        modelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\n    #endif\n    vec4 pos = modelMatrix * getPosition();\n    v_Position = vec3(pos.xyz) / pos.w;\n\n    mat4 normalMatrix = u_NormalMatrix;\n    #ifdef USE_INSTANCING\n        normalMatrix = mat4(a_NormalMatrix0, a_NormalMatrix1, a_NormalMatrix2, a_NormalMatrix3);\n    #endif\n\n    #ifdef HAS_NORMALS\n    #ifdef HAS_TANGENTS\n    vec4 tangent = getTangent();\n    vec3 normalW = normalize(vec3(normalMatrix * vec4(getNormal().xyz, 0.0)));\n    vec3 tangentW = normalize(vec3(modelMatrix * vec4(tangent.xyz, 0.0)));\n    vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n    v_TBN = mat3(tangentW, bitangentW, normalW);\n    #else // !HAS_TANGENTS\n    v_Normal = normalize(vec3(normalMatrix * vec4(getNormal().xyz, 0.0)));\n    #endif\n    #endif // !HAS_NORMALS\n\n    v_UVCoord1 = vec2(0.0, 0.0);\n    v_UVCoord2 = vec2(0.0, 0.0);\n\n    #ifdef HAS_UV_SET1\n    v_UVCoord1 = a_UV1;\n    #endif\n\n    #ifdef HAS_UV_SET2\n    v_UVCoord2 = a_UV2;\n    #endif\n\n    #if defined(HAS_VERTEX_COLOR_VEC3) || defined(HAS_VERTEX_COLOR_VEC4)\n    v_Color = a_Color;\n    #endif\n\n    #ifdef USE_SHADOW_MAPPING\n    v_PositionLightSpace = u_LightViewProjectionMatrix * pos;\n    #endif\n\n    #ifdef USE_INSTANCING\n    v_BaseColorFactor = a_BaseColorFactor;\n    #endif\n\n    gl_Position = u_ViewProjectionMatrix * pos;\n}\n"

/***/ }),

/***/ "./src/material/standard/standard-material-alpha-mode.ts":
/*!***************************************************************!*\
  !*** ./src/material/standard/standard-material-alpha-mode.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMaterialAlphaMode = void 0;
var StandardMaterialAlphaMode;
(function (StandardMaterialAlphaMode) {
    /**
     * The rendered output is fully opaque and any alpha value is ignored.
     */
    StandardMaterialAlphaMode["opaque"] = "opaque";
    /**
     * The rendered output is either fully opaque or fully transparent depending
     * on the alpha value and the specified alpha cutoff value. This mode is used
     * to simulate geometry such as tree leaves or wire fences.
     */
    StandardMaterialAlphaMode["mask"] = "mask";
    /**
     * The rendered output is combined with the background using the normal
     * painting operation (i.e. the Porter and Duff over operator). This mode is
     * used to simulate geometry such as guaze cloth or animal fur.
     */
    StandardMaterialAlphaMode["blend"] = "blend";
})(StandardMaterialAlphaMode = exports.StandardMaterialAlphaMode || (exports.StandardMaterialAlphaMode = {}));


/***/ }),

/***/ "./src/material/standard/standard-material-debug-mode.ts":
/*!***************************************************************!*\
  !*** ./src/material/standard/standard-material-debug-mode.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMaterialDebugMode = void 0;
var StandardMaterialDebugMode;
(function (StandardMaterialDebugMode) {
    StandardMaterialDebugMode["alpha"] = "alpha";
    StandardMaterialDebugMode["emissive"] = "emissive";
    StandardMaterialDebugMode["f0"] = "f0";
    StandardMaterialDebugMode["metallic"] = "metallic";
    StandardMaterialDebugMode["normal"] = "normal";
    StandardMaterialDebugMode["occlusion"] = "occlusion";
    StandardMaterialDebugMode["roughness"] = "roughness";
})(StandardMaterialDebugMode = exports.StandardMaterialDebugMode || (exports.StandardMaterialDebugMode = {}));


/***/ }),

/***/ "./src/material/standard/standard-material-feature-set.ts":
/*!****************************************************************!*\
  !*** ./src/material/standard/standard-material-feature-set.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMaterialFeatureSet = void 0;
var standard_material_alpha_mode_1 = __webpack_require__(/*! ./standard-material-alpha-mode */ "./src/material/standard/standard-material-alpha-mode.ts");
var standard_material_debug_mode_1 = __webpack_require__(/*! ./standard-material-debug-mode */ "./src/material/standard/standard-material-debug-mode.ts");
var platform_1 = __webpack_require__(/*! ../../platform */ "./src/platform.ts");
var standard_material_matrix_texture_1 = __webpack_require__(/*! ./standard-material-matrix-texture */ "./src/material/standard/standard-material-matrix-texture.ts");
var console_1 = __webpack_require__(/*! ../../console */ "./src/console.ts");
var StandardMaterialFeatureSet;
(function (StandardMaterialFeatureSet) {
    function build(renderer, mesh, geometry, material, lightingEnvironment) {
        var features = [];
        if (mesh.instances.length > 0) {
            features.push("USE_INSTANCING 1");
        }
        if (renderer.context.webGLVersion === 1) {
            features.push("WEBGL1 1");
        }
        if (renderer.context.webGLVersion === 2) {
            features.push("WEBGL2 1");
        }
        if (geometry.normals) {
            features.push("HAS_NORMALS 1");
        }
        if (geometry.uvs) {
            features.push("HAS_UV_SET1 1");
        }
        if (geometry.tangents) {
            features.push("HAS_TANGENTS 1");
        }
        if (geometry.targets) {
            for (var i = 0; i < geometry.targets.length; i++) {
                if (geometry.targets[i].positions) {
                    features.push("HAS_TARGET_POSITION" + i);
                }
                if (geometry.targets[i].normals) {
                    features.push("HAS_TARGET_NORMAL" + i);
                }
                if (geometry.targets[i].tangents) {
                    features.push("HAS_TARGET_TANGENT" + i);
                }
            }
            if (mesh.morphWeights) {
                features.push("WEIGHT_COUNT " + mesh.morphWeights.length);
                features.push("USE_MORPHING 1");
            }
        }
        if (geometry.joints) {
            features.push("HAS_JOINT_SET1 1");
        }
        if (geometry.weights) {
            features.push("HAS_WEIGHT_SET1 1");
        }
        if (mesh.skin) {
            if (isJointMatrixTextureRequired(mesh.skin.joints.length, renderer)) {
                if (standard_material_matrix_texture_1.StandardMaterialMatrixTexture.isSupported(renderer)) {
                    features.push("USE_SKINNING 1");
                    features.push("USE_SKINNING_TEXTURE 1");
                }
                else {
                    console_1.Console.error("PIXI3D: Mesh contains " + mesh.skin.joints.length + " joints, which is more than supported on this device. Skinning will be disabled and result may not be as expected.");
                }
            }
            else {
                features.push("USE_SKINNING 1");
            }
            features.push("JOINT_COUNT " + mesh.skin.joints.length);
        }
        if (material.unlit) {
            features.push("MATERIAL_UNLIT 1");
        }
        features.push("MATERIAL_METALLICROUGHNESS 1");
        if (lightingEnvironment.lights.length > 0) {
            features.push("LIGHT_COUNT " + lightingEnvironment.lights.length);
            features.push("USE_PUNCTUAL 1");
        }
        if (lightingEnvironment.imageBasedLighting) {
            if (!lightingEnvironment.imageBasedLighting.valid) {
                return undefined;
            }
            if (platform_1.Platform.isShaderTextureLodSupported(renderer)) {
                features.push("USE_TEX_LOD 1");
            }
            features.push("USE_IBL 1");
        }
        if (material.shadowCastingLight) {
            features.push("USE_SHADOW_MAPPING 1");
        }
        if (material.baseColorTexture) {
            if (!material.baseColorTexture.valid) {
                return undefined;
            }
            if (material.baseColorTexture.uvTransform) {
                features.push("HAS_BASECOLOR_UV_TRANSFORM 1");
            }
            features.push("HAS_BASE_COLOR_MAP 1");
        }
        if (material.emissiveTexture) {
            if (!material.emissiveTexture.valid) {
                return undefined;
            }
            if (material.emissiveTexture.uvTransform) {
                features.push("HAS_EMISSIVE_UV_TRANSFORM 1");
            }
            features.push("HAS_EMISSIVE_MAP 1");
        }
        if (material.normalTexture) {
            if (!material.normalTexture.valid) {
                return undefined;
            }
            if (material.normalTexture.uvTransform) {
                features.push("HAS_NORMAL_UV_TRANSFORM 1");
            }
            features.push("HAS_NORMAL_MAP 1");
        }
        if (material.metallicRoughnessTexture) {
            if (!material.metallicRoughnessTexture.valid) {
                return undefined;
            }
            if (material.metallicRoughnessTexture.uvTransform) {
                features.push("HAS_METALLICROUGHNESS_UV_TRANSFORM 1");
            }
            features.push("HAS_METALLIC_ROUGHNESS_MAP 1");
        }
        if (material.occlusionTexture) {
            if (!material.occlusionTexture.valid) {
                return undefined;
            }
            if (material.occlusionTexture.uvTransform) {
                features.push("HAS_OCCLUSION_UV_TRANSFORM 1");
            }
            features.push("HAS_OCCLUSION_MAP 1");
        }
        switch (material.alphaMode) {
            case standard_material_alpha_mode_1.StandardMaterialAlphaMode.opaque: {
                features.push("ALPHAMODE_OPAQUE 1");
                break;
            }
            case standard_material_alpha_mode_1.StandardMaterialAlphaMode.mask: {
                features.push("ALPHAMODE_MASK 1");
                break;
            }
        }
        if (material.debugMode) {
            features.push("DEBUG_OUTPUT 1");
        }
        switch (material.debugMode) {
            case standard_material_debug_mode_1.StandardMaterialDebugMode.alpha: {
                features.push("DEBUG_ALPHA 1");
                break;
            }
            case standard_material_debug_mode_1.StandardMaterialDebugMode.emissive: {
                features.push("DEBUG_EMISSIVE 1");
                break;
            }
            case standard_material_debug_mode_1.StandardMaterialDebugMode.f0: {
                features.push("DEBUG_F0 1");
                break;
            }
            case standard_material_debug_mode_1.StandardMaterialDebugMode.metallic: {
                features.push("DEBUG_METALLIC 1");
                break;
            }
            case standard_material_debug_mode_1.StandardMaterialDebugMode.normal: {
                features.push("DEBUG_NORMAL 1");
                break;
            }
            case standard_material_debug_mode_1.StandardMaterialDebugMode.occlusion: {
                features.push("DEBUG_OCCLUSION 1");
                break;
            }
            case standard_material_debug_mode_1.StandardMaterialDebugMode.roughness: {
                features.push("DEBUG_ROUGHNESS 1");
                break;
            }
        }
        return features;
    }
    StandardMaterialFeatureSet.build = build;
    function isJointMatrixTextureRequired(jointsCount, renderer) {
        var uniformsRequiredForMostFeatures = 25;
        var availableJointUniforms = platform_1.Platform.getMaxVertexUniformVectors(renderer) - uniformsRequiredForMostFeatures;
        var uniformsRequiredPerJoint = 8;
        return jointsCount > Math.floor(availableJointUniforms / uniformsRequiredPerJoint);
    }
    function hasSkinningTextureFeature(features) {
        return features.includes("USE_SKINNING_TEXTURE 1");
    }
    StandardMaterialFeatureSet.hasSkinningTextureFeature = hasSkinningTextureFeature;
})(StandardMaterialFeatureSet = exports.StandardMaterialFeatureSet || (exports.StandardMaterialFeatureSet = {}));


/***/ }),

/***/ "./src/material/standard/standard-material-matrix-texture.ts":
/*!*******************************************************************!*\
  !*** ./src/material/standard/standard-material-matrix-texture.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMaterialMatrixTexture = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var buffer_resource_1 = __webpack_require__(/*! ../../pixi/buffer-resource */ "./src/pixi/buffer-resource.ts");
var platform_1 = __webpack_require__(/*! ../../platform */ "./src/platform.ts");
var StandardMaterialMatrixTexture = /** @class */ (function (_super) {
    tslib_1.__extends(StandardMaterialMatrixTexture, _super);
    function StandardMaterialMatrixTexture(matrixCount) {
        var _this = this;
        var buffer = new Float32Array(matrixCount * 16);
        var resource = new buffer_resource_1.BufferResource(buffer, { width: 4, height: matrixCount });
        _this = _super.call(this, new PIXI.BaseTexture(resource, {
            mipmap: PIXI.MIPMAP_MODES.OFF,
            wrapMode: PIXI.WRAP_MODES.CLAMP,
            scaleMode: PIXI.SCALE_MODES.NEAREST,
            format: PIXI.FORMATS.RGBA,
            type: PIXI.TYPES.FLOAT,
            alphaMode: PIXI.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA
        })) || this;
        _this._buffer = buffer;
        return _this;
    }
    StandardMaterialMatrixTexture.isSupported = function (renderer) {
        return platform_1.Platform.isFloatTextureSupported(renderer);
    };
    StandardMaterialMatrixTexture.prototype.updateBuffer = function (buffer) {
        for (var i = 0; i < buffer.length; i++) {
            // Normalize the values between 0 and 1 because textures can't have negative values
            this._buffer[i] = (buffer[i] + 1) / 2;
        }
        this.baseTexture.resource.update();
    };
    return StandardMaterialMatrixTexture;
}(PIXI.Texture));
exports.StandardMaterialMatrixTexture = StandardMaterialMatrixTexture;


/***/ }),

/***/ "./src/material/standard/standard-material-skin-uniforms.ts":
/*!******************************************************************!*\
  !*** ./src/material/standard/standard-material-skin-uniforms.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMaterialSkinUniforms = void 0;
var standard_material_matrix_texture_1 = __webpack_require__(/*! ./standard-material-matrix-texture */ "./src/material/standard/standard-material-matrix-texture.ts");
var StandardMaterialSkinUniforms = /** @class */ (function () {
    function StandardMaterialSkinUniforms() {
    }
    StandardMaterialSkinUniforms.prototype.enableJointMatrixTextures = function (jointsCount) {
        if (!this._jointMatrixTexture) {
            this._jointMatrixTexture = new standard_material_matrix_texture_1.StandardMaterialMatrixTexture(jointsCount);
        }
        if (!this._jointNormalTexture) {
            this._jointNormalTexture = new standard_material_matrix_texture_1.StandardMaterialMatrixTexture(jointsCount);
        }
    };
    StandardMaterialSkinUniforms.prototype.destroy = function () {
        var _a, _b;
        (_a = this._jointNormalTexture) === null || _a === void 0 ? void 0 : _a.destroy(true);
        (_b = this._jointMatrixTexture) === null || _b === void 0 ? void 0 : _b.destroy(true);
    };
    StandardMaterialSkinUniforms.prototype.update = function (mesh, shader) {
        if (!mesh.skin) {
            return;
        }
        var _a = mesh.skin.calculateJointMatrices(), jointVertexMatrices = _a.jointVertexMatrices, jointNormalMatrices = _a.jointNormalMatrices;
        if (this._jointMatrixTexture) {
            this._jointMatrixTexture.updateBuffer(jointVertexMatrices);
            shader.uniforms.u_jointMatrixSampler = this._jointMatrixTexture;
        }
        else {
            shader.uniforms.u_jointMatrix = jointVertexMatrices;
        }
        if (this._jointNormalTexture) {
            this._jointNormalTexture.updateBuffer(jointNormalMatrices);
            shader.uniforms.u_jointNormalMatrixSampler = this._jointNormalTexture;
        }
        else {
            shader.uniforms.u_jointNormalMatrix = jointNormalMatrices;
        }
    };
    return StandardMaterialSkinUniforms;
}());
exports.StandardMaterialSkinUniforms = StandardMaterialSkinUniforms;


/***/ }),

/***/ "./src/material/standard/standard-material.ts":
/*!****************************************************!*\
  !*** ./src/material/standard/standard-material.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMaterial = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var light_type_1 = __webpack_require__(/*! ../../lighting/light-type */ "./src/lighting/light-type.ts");
var standard_material_feature_set_1 = __webpack_require__(/*! ./standard-material-feature-set */ "./src/material/standard/standard-material-feature-set.ts");
var standard_shader_1 = __webpack_require__(/*! ./standard-shader */ "./src/material/standard/standard-shader.ts");
var material_1 = __webpack_require__(/*! ../material */ "./src/material/material.ts");
var camera_1 = __webpack_require__(/*! ../../camera/camera */ "./src/camera/camera.ts");
var gltf_material_1 = __webpack_require__(/*! ../../gltf/gltf-material */ "./src/gltf/gltf-material.ts");
var lighting_environment_1 = __webpack_require__(/*! ../../lighting/lighting-environment */ "./src/lighting/lighting-environment.ts");
var standard_material_alpha_mode_1 = __webpack_require__(/*! ./standard-material-alpha-mode */ "./src/material/standard/standard-material-alpha-mode.ts");
var standard_material_skin_uniforms_1 = __webpack_require__(/*! ./standard-material-skin-uniforms */ "./src/material/standard/standard-material-skin-uniforms.ts");
var material_render_sort_type_1 = __webpack_require__(/*! ../material-render-sort-type */ "./src/material/material-render-sort-type.ts");
var color_1 = __webpack_require__(/*! ../../color */ "./src/color.ts");
var instanced_standard_material_1 = __webpack_require__(/*! ./instanced-standard-material */ "./src/material/standard/instanced-standard-material.ts");
var shaders = {};
/**
 * The standard material is using Physically-Based Rendering (PBR) which makes
 * it suitable to represent a wide range of different surfaces. It's the default
 * material when loading models from file.
 */
var StandardMaterial = /** @class */ (function (_super) {
    tslib_1.__extends(StandardMaterial, _super);
    function StandardMaterial() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._unlit = false;
        _this._alphaMode = standard_material_alpha_mode_1.StandardMaterialAlphaMode.opaque;
        _this._baseColor = new Float32Array(4);
        _this._instancingEnabled = false;
        _this._skinUniforms = new standard_material_skin_uniforms_1.StandardMaterialSkinUniforms();
        /** The roughness of the material. */
        _this.roughness = 1;
        /** The metalness of the material. */
        _this.metallic = 1;
        /** The base color of the material. */
        _this.baseColor = new color_1.Color(1, 1, 1, 1);
        /** The cutoff threshold when alpha mode is set to "mask". */
        _this.alphaCutoff = 0.5;
        /** The emissive color of the material. */
        _this.emissive = new color_1.Color(0, 0, 0, 0);
        /** The exposure (brightness) of the material. */
        _this.exposure = 3;
        return _this;
    }
    Object.defineProperty(StandardMaterial.prototype, "baseColorTexture", {
        /** The base color texture. */
        get: function () {
            return this._baseColorTexture;
        },
        set: function (value) {
            if (value !== this._baseColorTexture) {
                this.invalidateShader();
                this._baseColorTexture = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "metallicRoughnessTexture", {
        /** The metallic-roughness texture. */
        get: function () {
            return this._metallicRoughnessTexture;
        },
        set: function (value) {
            if (value !== this._metallicRoughnessTexture) {
                this.invalidateShader();
                this._metallicRoughnessTexture = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "normalTexture", {
        /** The normal map texture. */
        get: function () {
            return this._normalTexture;
        },
        set: function (value) {
            if (value !== this._normalTexture) {
                this.invalidateShader();
                this._normalTexture = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "occlusionTexture", {
        /** The occlusion map texture. */
        get: function () {
            return this._occlusionTexture;
        },
        set: function (value) {
            if (value !== this._occlusionTexture) {
                this.invalidateShader();
                this._occlusionTexture = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "emissiveTexture", {
        /** The emissive map texture. */
        get: function () {
            return this._emissiveTexture;
        },
        set: function (value) {
            if (value !== this._emissiveTexture) {
                this.invalidateShader();
                this._emissiveTexture = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "alphaMode", {
        /** The alpha rendering mode of the material. */
        get: function () {
            return this._alphaMode;
        },
        set: function (value) {
            if (this._alphaMode !== value) {
                this._alphaMode = value;
                this.invalidateShader();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "shadowCastingLight", {
        /** The shadow casting light of the material. */
        get: function () {
            return this._shadowCastingLight;
        },
        set: function (value) {
            if (value !== this._shadowCastingLight) {
                this.invalidateShader();
                this._shadowCastingLight = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "debugMode", {
        /** The debug rendering mode of the material. */
        get: function () {
            return this._debugMode;
        },
        set: function (value) {
            if (this._debugMode !== value) {
                this.invalidateShader();
                this._debugMode = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "lightingEnvironment", {
        /**
         * Lighting environment used when rendering a mesh. If this value is not set,
         * the main lighting environment will be used by default.
         */
        get: function () {
            return this._lightingEnvironment;
        },
        set: function (value) {
            if (value !== this._lightingEnvironment) {
                this.invalidateShader();
                this._lightingEnvironment = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardMaterial.prototype, "unlit", {
        /**
         * Value indicating if the material is unlit. If this value if set to true,
         * all lighting is disabled and only the base color will be used.
         */
        get: function () {
            return this._unlit;
        },
        set: function (value) {
            if (this._unlit !== value) {
                this._unlit = value;
                this.invalidateShader();
            }
        },
        enumerable: false,
        configurable: true
    });
    StandardMaterial.prototype.destroy = function () {
        var _a, _b, _c, _d, _e;
        (_a = this._baseColorTexture) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this._normalTexture) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this._emissiveTexture) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this._occlusionTexture) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this._metallicRoughnessTexture) === null || _e === void 0 ? void 0 : _e.destroy();
        this._skinUniforms.destroy();
    };
    /**
     * Invalidates the shader so it can be rebuilt with the current features.
     */
    StandardMaterial.prototype.invalidateShader = function () {
        this._shader = undefined;
    };
    /**
     * Creates a standard material factory which can be used when loading models.
     * @param props Properties to set on the material when created.
     */
    StandardMaterial.factory = function (props) {
        if (props === void 0) { props = {}; }
        return {
            create: function (source) {
                return Object.assign(StandardMaterial.create(source), props);
            }
        };
    };
    /**
     * Creates a new standard material from the specified source.
     * @param source Source from which the material is created.
     */
    StandardMaterial.create = function (source) {
        var _a, _b, _c, _d, _e;
        var material = new StandardMaterial();
        if (source instanceof gltf_material_1.glTFMaterial) {
            material.baseColor = color_1.Color.from(source.baseColor);
            material.baseColorTexture = (_a = source.baseColorTexture) === null || _a === void 0 ? void 0 : _a.clone();
            material.metallic = source.metallic;
            material.roughness = source.roughness;
            material.metallicRoughnessTexture = (_b = source.metallicRoughnessTexture) === null || _b === void 0 ? void 0 : _b.clone();
            switch (source.alphaMode) {
                case "BLEND": {
                    material.alphaMode = standard_material_alpha_mode_1.StandardMaterialAlphaMode.blend;
                    material.renderSortType = material_render_sort_type_1.MaterialRenderSortType.transparent;
                    break;
                }
                case "MASK": {
                    material.alphaMode = standard_material_alpha_mode_1.StandardMaterialAlphaMode.mask;
                    break;
                }
                case "OPAQUE": {
                    material.alphaMode = standard_material_alpha_mode_1.StandardMaterialAlphaMode.opaque;
                    break;
                }
            }
            material.unlit = source.unlit;
            material.emissiveTexture = (_c = source.emissiveTexture) === null || _c === void 0 ? void 0 : _c.clone();
            material.emissive = color_1.Color.from(source.emissive);
            material.normalTexture = (_d = source.normalTexture) === null || _d === void 0 ? void 0 : _d.clone();
            material.occlusionTexture = (_e = source.occlusionTexture) === null || _e === void 0 ? void 0 : _e.clone();
            material.doubleSided = source.doubleSided;
            material.alphaCutoff = source.alphaCutoff;
            if (source.baseColorTexture && source.baseColorTexture.uvTransform) {
                material.baseColorTexture.uvTransform = source.baseColorTexture.uvTransform;
            }
            if (source.normalTexture && source.normalTexture.uvTransform) {
                material.normalTexture.uvTransform = source.normalTexture.uvTransform;
            }
            if (source.emissiveTexture && source.emissiveTexture.uvTransform) {
                material.emissiveTexture.uvTransform = source.emissiveTexture.uvTransform;
            }
            if (source.occlusionTexture && source.occlusionTexture.uvTransform) {
                material.occlusionTexture.uvTransform = source.occlusionTexture.uvTransform;
            }
            if (source.metallicRoughnessTexture && source.metallicRoughnessTexture.uvTransform) {
                material.metallicRoughnessTexture.uvTransform = source.metallicRoughnessTexture.uvTransform;
            }
        }
        return material;
    };
    StandardMaterial.prototype.render = function (mesh, renderer) {
        if (!this._instancingEnabled && mesh.instances.length > 0) {
            // Invalidate shader when instacing was enabled.
            this.invalidateShader();
            this._instancingEnabled = mesh.instances.length > 0;
        }
        var lightingEnvironment = this.lightingEnvironment || lighting_environment_1.LightingEnvironment.main;
        if (lightingEnvironment.lights.length !== this._lightsCount) {
            // Invalidate shader when the number of punctual lights has changed.
            this.invalidateShader();
            this._lightsCount = lightingEnvironment.lights.length;
        }
        _super.prototype.render.call(this, mesh, renderer);
    };
    Object.defineProperty(StandardMaterial.prototype, "isInstancingSupported", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    StandardMaterial.prototype.createInstance = function () {
        return new instanced_standard_material_1.InstancedStandardMaterial(this);
    };
    StandardMaterial.prototype.createShader = function (mesh, renderer) {
        var e_1, _a;
        if (renderer.context.webGLVersion === 1) {
            var extensions = ["EXT_shader_texture_lod", "OES_standard_derivatives"];
            try {
                for (var extensions_1 = tslib_1.__values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {
                    var ext = extensions_1_1.value;
                    if (!renderer.gl.getExtension(ext)) {
                        console.warn("PIXI3D: Extension \"" + ext + "\" is not supported by current platform, the material may not be displayed correctly.");
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var lightingEnvironment = this.lightingEnvironment || lighting_environment_1.LightingEnvironment.main;
        var features = standard_material_feature_set_1.StandardMaterialFeatureSet.build(renderer, mesh, mesh.geometry, this, lightingEnvironment);
        if (!features) {
            // The shader features couldn't be built, some resources may still be 
            // loading. Don't worry, we will retry creating shader at next render.
            return undefined;
        }
        if (mesh.skin && standard_material_feature_set_1.StandardMaterialFeatureSet.hasSkinningTextureFeature(features)) {
            this._skinUniforms.enableJointMatrixTextures(mesh.skin.joints.length);
        }
        var checksum = features.join(",");
        if (!shaders[checksum]) {
            shaders[checksum] = standard_shader_1.StandardShader.build(renderer, features);
        }
        return shaders[checksum];
    };
    StandardMaterial.prototype.updateUniforms = function (mesh, shader) {
        var _a, _b, _c, _d, _e;
        this._baseColor.set(this.baseColor.rgb);
        this._baseColor[3] = this.baseColor.a * mesh.worldAlpha;
        var camera = this.camera || camera_1.Camera.main;
        if (mesh.skin) {
            this._skinUniforms.update(mesh, shader);
        }
        shader.uniforms.u_Camera = camera.worldTransform.position;
        shader.uniforms.u_ViewProjectionMatrix = camera.viewProjection;
        shader.uniforms.u_Exposure = this.exposure;
        shader.uniforms.u_MetallicFactor = this.metallic;
        shader.uniforms.u_RoughnessFactor = this.roughness;
        shader.uniforms.u_BaseColorFactor = this._baseColor;
        shader.uniforms.u_EmissiveFactor = this.emissive.rgb;
        shader.uniforms.u_ModelMatrix = mesh.worldTransform.array;
        shader.uniforms.u_NormalMatrix = mesh.transform.normalTransform.array;
        if (this._shadowCastingLight) {
            shader.uniforms.u_ShadowSampler = this._shadowCastingLight.shadowTexture;
            shader.uniforms.u_LightViewProjectionMatrix = this._shadowCastingLight.lightViewProjection;
        }
        if (this._alphaMode === standard_material_alpha_mode_1.StandardMaterialAlphaMode.mask) {
            shader.uniforms.u_AlphaCutoff = this.alphaCutoff;
        }
        if (mesh.morphWeights) {
            shader.uniforms.u_morphWeights = mesh.morphWeights;
        }
        if ((_a = this.baseColorTexture) === null || _a === void 0 ? void 0 : _a.valid) {
            shader.uniforms.u_BaseColorSampler = this.baseColorTexture;
            shader.uniforms.u_BaseColorUVSet = 0;
            if (this.baseColorTexture.uvTransform) {
                shader.uniforms.u_BaseColorUVTransform = this.baseColorTexture.uvTransform;
            }
        }
        var lightingEnvironment = this.lightingEnvironment || lighting_environment_1.LightingEnvironment.main;
        for (var i = 0; i < lightingEnvironment.lights.length; i++) {
            var light = lightingEnvironment.lights[i];
            var type = 0;
            switch (light.type) {
                case light_type_1.LightType.point:
                    type = 1;
                    break;
                case light_type_1.LightType.directional:
                    type = 0;
                    break;
                case light_type_1.LightType.spot:
                    type = 2;
                    break;
                case light_type_1.LightType.ambient:
                    type = 3;
                    break;
            }
            shader.uniforms["u_Lights[" + i + "].type"] = type;
            shader.uniforms["u_Lights[" + i + "].position"] = light.worldTransform.position;
            shader.uniforms["u_Lights[" + i + "].direction"] = light.worldTransform.forward;
            shader.uniforms["u_Lights[" + i + "].range"] = light.range;
            shader.uniforms["u_Lights[" + i + "].color"] = light.color.rgb;
            shader.uniforms["u_Lights[" + i + "].intensity"] = light.intensity;
            shader.uniforms["u_Lights[" + i + "].innerConeCos"] = Math.cos(light.innerConeAngle * PIXI.DEG_TO_RAD);
            shader.uniforms["u_Lights[" + i + "].outerConeCos"] = Math.cos(light.outerConeAngle * PIXI.DEG_TO_RAD);
        }
        var imageBasedLighting = lightingEnvironment.imageBasedLighting;
        if (imageBasedLighting === null || imageBasedLighting === void 0 ? void 0 : imageBasedLighting.valid) {
            shader.uniforms.u_DiffuseEnvSampler = imageBasedLighting.diffuse;
            shader.uniforms.u_SpecularEnvSampler = imageBasedLighting.specular;
            shader.uniforms.u_brdfLUT = imageBasedLighting.brdf;
            shader.uniforms.u_MipCount = imageBasedLighting.specular.levels - 1;
        }
        if ((_b = this.emissiveTexture) === null || _b === void 0 ? void 0 : _b.valid) {
            shader.uniforms.u_EmissiveSampler = this.emissiveTexture;
            shader.uniforms.u_EmissiveUVSet = 0;
            shader.uniforms.u_EmissiveFactor = [1, 1, 1];
            if (this.emissiveTexture.uvTransform) {
                shader.uniforms.u_EmissiveUVTransform = this.emissiveTexture.uvTransform;
            }
        }
        if ((_c = this.normalTexture) === null || _c === void 0 ? void 0 : _c.valid) {
            shader.uniforms.u_NormalSampler = this.normalTexture;
            shader.uniforms.u_NormalScale = 1;
            shader.uniforms.u_NormalUVSet = 0;
            if (this.normalTexture.uvTransform) {
                shader.uniforms.u_NormalUVTransform = this.normalTexture.uvTransform;
            }
        }
        if ((_d = this.metallicRoughnessTexture) === null || _d === void 0 ? void 0 : _d.valid) {
            shader.uniforms.u_MetallicRoughnessSampler = this.metallicRoughnessTexture;
            shader.uniforms.u_MetallicRoughnessUVSet = 0;
            if (this.metallicRoughnessTexture.uvTransform) {
                shader.uniforms.u_MetallicRoughnessUVTransform = this.metallicRoughnessTexture.uvTransform;
            }
        }
        if ((_e = this.occlusionTexture) === null || _e === void 0 ? void 0 : _e.valid) {
            shader.uniforms.u_OcclusionSampler = this.occlusionTexture;
            shader.uniforms.u_OcclusionStrength = 1;
            shader.uniforms.u_OcclusionUVSet = 0;
            if (this.occlusionTexture.uvTransform) {
                shader.uniforms.u_OcclusionUVTransform = this.occlusionTexture.uvTransform;
            }
        }
    };
    return StandardMaterial;
}(material_1.Material));
exports.StandardMaterial = StandardMaterial;


/***/ }),

/***/ "./src/material/standard/standard-shader-instancing.ts":
/*!*************************************************************!*\
  !*** ./src/material/standard/standard-shader-instancing.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardShaderInstancing = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var StandardShaderInstancing = /** @class */ (function () {
    function StandardShaderInstancing() {
        this._maxInstances = 200;
        this._modelMatrix = [
            new PIXI.Buffer(), new PIXI.Buffer(), new PIXI.Buffer(), new PIXI.Buffer()
        ];
        this._normalMatrix = [
            new PIXI.Buffer(), new PIXI.Buffer(), new PIXI.Buffer(), new PIXI.Buffer()
        ];
        this._baseColor = new PIXI.Buffer();
        this.expandBuffers(this._maxInstances);
    }
    StandardShaderInstancing.prototype.expandBuffers = function (instanceCount) {
        while (instanceCount > this._maxInstances) {
            this._maxInstances += Math.floor(this._maxInstances * 0.5);
        }
        for (var i = 0; i < 4; i++) {
            this._modelMatrix[i].update(new Float32Array(4 * this._maxInstances));
            this._normalMatrix[i].update(new Float32Array(4 * this._maxInstances));
        }
        this._baseColor.update(new Float32Array(4 * this._maxInstances));
    };
    StandardShaderInstancing.prototype.updateBuffers = function (instances) {
        if (instances.length > this._maxInstances) {
            this.expandBuffers(instances.length);
        }
        var bufferIndex = 0;
        for (var i = 0; i < instances.length; i++) {
            if (!instances[i].worldVisible || !instances[i].renderable) {
                continue;
            }
            var normal = instances[i].transform.normalTransform.array;
            for (var j = 0; j < 4; j++) {
                this._normalMatrix[j].data
                    .set(normal.slice(j * 4, j * 4 + 4), bufferIndex * 4);
            }
            var model = instances[i].worldTransform.array;
            for (var j = 0; j < 4; j++) {
                this._modelMatrix[j].data
                    .set(model.slice(j * 4, j * 4 + 4), bufferIndex * 4);
            }
            var material = instances[i].material;
            this._baseColor.data
                .set(material.baseColor.rgba, bufferIndex * 4);
            bufferIndex++;
        }
        for (var i = 0; i < 4; i++) {
            this._modelMatrix[i].update();
            this._normalMatrix[i].update();
        }
        this._baseColor.update();
    };
    StandardShaderInstancing.prototype.addGeometryAttributes = function (geometry) {
        for (var i = 0; i < 4; i++) {
            geometry.addAttribute("a_ModelMatrix" + i, this._modelMatrix[i], 4, false, undefined, 0, undefined, true);
        }
        for (var i = 0; i < 4; i++) {
            geometry.addAttribute("a_NormalMatrix" + i, this._normalMatrix[i], 4, false, undefined, 0, undefined, true);
        }
        geometry.addAttribute("a_BaseColorFactor", this._baseColor, 4, false, undefined, 0, undefined, true);
    };
    return StandardShaderInstancing;
}());
exports.StandardShaderInstancing = StandardShaderInstancing;


/***/ }),

/***/ "./src/material/standard/standard-shader-source.ts":
/*!*********************************************************!*\
  !*** ./src/material/standard/standard-shader-source.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardShaderSource = void 0;
var StandardShaderSource;
(function (StandardShaderSource) {
    function build(source, features, renderer) {
        if (renderer.context.webGLVersion === 1) {
            source = source.replace(/VERSION/, "100")
                .replace(/VERT_IN/g, "attribute")
                .replace(/VERT_OUT/g, "varying")
                .replace(/FRAG_COLOR/g, "gl_FragColor")
                .replace(/FRAG_IN/g, "varying");
        }
        if (renderer.context.webGLVersion === 2) {
            source = source.replace(/VERSION/, "300 es")
                .replace(/VERT_IN/g, "in")
                .replace(/VERT_OUT/g, "out")
                .replace(/FRAG_COLOR/g, "g_finalColor")
                .replace(/FRAG_IN/g, "in");
        }
        return source.replace(/#define FEATURES/, features.map(function (value) { return "#define " + value; }).join("\n"));
    }
    StandardShaderSource.build = build;
})(StandardShaderSource = exports.StandardShaderSource || (exports.StandardShaderSource = {}));


/***/ }),

/***/ "./src/material/standard/standard-shader.ts":
/*!**************************************************!*\
  !*** ./src/material/standard/standard-shader.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardShader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var mesh_shader_1 = __webpack_require__(/*! ../../mesh/mesh-shader */ "./src/mesh/mesh-shader.ts");
var standard_shader_instancing_1 = __webpack_require__(/*! ./standard-shader-instancing */ "./src/material/standard/standard-shader-instancing.ts");
var standard_shader_source_1 = __webpack_require__(/*! ./standard-shader-source */ "./src/material/standard/standard-shader-source.ts");
var StandardShader = /** @class */ (function (_super) {
    tslib_1.__extends(StandardShader, _super);
    function StandardShader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._instancing = new standard_shader_instancing_1.StandardShaderInstancing();
        return _this;
    }
    StandardShader.build = function (renderer, features) {
        var vert = __webpack_require__(/*! ./shader/primitive.vert */ "./src/material/standard/shader/primitive.vert");
        var frag = __webpack_require__(/*! ./shader/metallic-roughness.frag */ "./src/material/standard/shader/metallic-roughness.frag");
        var program = PIXI.Program.from(standard_shader_source_1.StandardShaderSource.build(vert, features, renderer), standard_shader_source_1.StandardShaderSource.build(frag, features, renderer));
        return new StandardShader(program);
    };
    Object.defineProperty(StandardShader.prototype, "name", {
        get: function () {
            return "standard-shader";
        },
        enumerable: false,
        configurable: true
    });
    StandardShader.prototype.createShaderGeometry = function (geometry, instanced) {
        var result = _super.prototype.createShaderGeometry.call(this, geometry, instanced);
        if (instanced) {
            this._instancing.addGeometryAttributes(result);
        }
        if (geometry.targets) {
            for (var i = 0; i < geometry.targets.length; i++) {
                var positions = geometry.targets[i].positions;
                if (positions) {
                    result.addAttribute("a_Target_Position" + i, new PIXI.Buffer(positions.buffer), 3, false, positions.componentType, positions.stride);
                }
                var normals = geometry.targets[i].normals;
                if (normals) {
                    result.addAttribute("a_Target_Normal" + i, new PIXI.Buffer(normals.buffer), 3, false, normals.componentType, normals.stride);
                }
                var tangents = geometry.targets[i].tangents;
                if (tangents) {
                    result.addAttribute("a_Target_Tangent" + i, new PIXI.Buffer(tangents.buffer), 3, false, tangents.componentType, tangents.stride);
                }
            }
        }
        if (geometry.joints) {
            result.addAttribute("a_Joint1", new PIXI.Buffer(geometry.joints.buffer), 4, false, geometry.joints.componentType, geometry.joints.stride);
        }
        if (geometry.weights) {
            result.addAttribute("a_Weight1", new PIXI.Buffer(geometry.weights.buffer), 4, false, geometry.weights.componentType, geometry.weights.stride);
        }
        return result;
    };
    StandardShader.prototype.render = function (mesh, renderer, state, drawMode) {
        if (mesh.instances.length > 0) {
            this._instancing.updateBuffers(mesh.instances);
        }
        _super.prototype.render.call(this, mesh, renderer, state, drawMode);
    };
    return StandardShader;
}(mesh_shader_1.MeshShader));
exports.StandardShader = StandardShader;


/***/ }),

/***/ "./src/math/mat3.ts":
/*!**************************!*\
  !*** ./src/math/mat3.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Mat3 = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
var Mat3 = /** @class */ (function () {
    function Mat3() {
    }
    Mat3.multiply = function (a, b, out) {
        return gl_matrix_1.mat3.multiply(out, a, b);
    };
    return Mat3;
}());
exports.Mat3 = Mat3;


/***/ }),

/***/ "./src/math/mat4.ts":
/*!**************************!*\
  !*** ./src/math/mat4.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Mat4 = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
var Mat4 = /** @class */ (function () {
    function Mat4() {
    }
    Mat4.getTranslation = function (mat, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.mat4.getTranslation(out, mat);
    };
    Mat4.create = function () {
        return gl_matrix_1.mat4.create();
    };
    Mat4.translate = function (mat, v, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.translate(out, mat, v);
    };
    Mat4.getScaling = function (mat, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.mat4.getScaling(out, mat);
    };
    Mat4.getRotation = function (mat, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.mat4.getRotation(out, mat);
    };
    Mat4.copy = function (a, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.copy(out, a);
    };
    Mat4.fromQuat = function (q, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.fromQuat(out, q);
    };
    Mat4.fromRotationTranslationScale = function (q, v, s, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.fromRotationTranslationScale(out, q, v, s);
    };
    Mat4.fromRotation = function (rad, axis, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.fromRotation(out, rad, axis);
    };
    Mat4.fromScaling = function (v, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.fromScaling(out, v);
    };
    Mat4.fromTranslation = function (v, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.fromTranslation(out, v);
    };
    Mat4.multiply = function (a, b, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.multiply(out, a, b);
    };
    Mat4.lookAt = function (eye, center, up, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.lookAt(out, eye, center, up);
    };
    Mat4.identity = function (out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.identity(out);
    };
    Mat4.perspective = function (fovy, aspect, near, far, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.perspective(out, fovy, aspect, near, far);
    };
    Mat4.ortho = function (left, right, bottom, top, near, far, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.ortho(out, left, right, bottom, top, near, far);
    };
    Mat4.invert = function (a, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.invert(out, a);
    };
    Mat4.transpose = function (a, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.transpose(out, a);
    };
    Mat4.targetTo = function (eye, target, up, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.targetTo(out, eye, target, up);
    };
    Mat4.rotateX = function (a, rad, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.rotateX(out, a, rad);
    };
    Mat4.rotateY = function (a, rad, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.rotateY(out, a, rad);
    };
    Mat4.rotateZ = function (a, rad, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.rotateZ(out, a, rad);
    };
    Mat4.rotate = function (a, rad, axis, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.rotate(out, a, rad, axis);
    };
    Mat4.scale = function (a, v, out) {
        if (out === void 0) { out = new Float32Array(16); }
        return gl_matrix_1.mat4.scale(out, a, v);
    };
    return Mat4;
}());
exports.Mat4 = Mat4;


/***/ }),

/***/ "./src/math/plane.ts":
/*!***************************!*\
  !*** ./src/math/plane.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Plane = void 0;
var vec3_1 = __webpack_require__(/*! ./vec3 */ "./src/math/vec3.ts");
function approximately(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
var EPSILON = 0.000001;
var Plane = /** @class */ (function () {
    function Plane(normal, distance) {
        this.distance = distance;
        this._normal = new Float32Array(3);
        vec3_1.Vec3.normalize(normal, this._normal);
    }
    Object.defineProperty(Plane.prototype, "normal", {
        get: function () {
            return this._normal;
        },
        enumerable: false,
        configurable: true
    });
    Plane.prototype.rayCast = function (ray) {
        var vdot = vec3_1.Vec3.dot(ray.direction, this.normal);
        if (approximately(vdot, 0)) {
            return 0;
        }
        var ndot = -vec3_1.Vec3.dot(ray.origin, this.normal) - this.distance;
        return ndot / vdot;
    };
    return Plane;
}());
exports.Plane = Plane;


/***/ }),

/***/ "./src/math/quat.ts":
/*!**************************!*\
  !*** ./src/math/quat.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Quat = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
var Quat = /** @class */ (function () {
    function Quat() {
    }
    Quat.set = function (x, y, z, w, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.quat.set(out, x, y, z, w);
    };
    Quat.fromValues = function (x, y, z, w) {
        return gl_matrix_1.quat.fromValues(x, y, z, w);
    };
    Quat.create = function () {
        return gl_matrix_1.quat.create();
    };
    Quat.normalize = function (a, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.quat.normalize(out, a);
    };
    Quat.slerp = function (a, b, t, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.quat.slerp(out, a, b, t);
    };
    Quat.fromEuler = function (x, y, z, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.quat.fromEuler(out, x, y, z);
    };
    Quat.conjugate = function (a, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.quat.conjugate(out, a);
    };
    Quat.rotateX = function (a, rad, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.quat.rotateX(out, a, rad);
    };
    Quat.rotateY = function (a, rad, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.quat.rotateY(out, a, rad);
    };
    Quat.rotateZ = function (a, rad, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.quat.rotateZ(out, a, rad);
    };
    return Quat;
}());
exports.Quat = Quat;


/***/ }),

/***/ "./src/math/ray.ts":
/*!*************************!*\
  !*** ./src/math/ray.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Ray = void 0;
var vec3_1 = __webpack_require__(/*! ./vec3 */ "./src/math/vec3.ts");
var Ray = /** @class */ (function () {
    function Ray(origin, direction) {
        this._direction = new Float32Array(3);
        this._origin = new Float32Array(3);
        vec3_1.Vec3.copy(origin, this._origin);
        vec3_1.Vec3.normalize(direction, this._direction);
    }
    Object.defineProperty(Ray.prototype, "origin", {
        get: function () {
            return this._origin;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ray.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        enumerable: false,
        configurable: true
    });
    Ray.prototype.getPoint = function (distance, point) {
        if (point === void 0) { point = new Float32Array(3); }
        return vec3_1.Vec3.add(this._origin, vec3_1.Vec3.scale(this._direction, distance, point), point);
    };
    return Ray;
}());
exports.Ray = Ray;


/***/ }),

/***/ "./src/math/vec3.ts":
/*!**************************!*\
  !*** ./src/math/vec3.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Vec3 = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
var Vec3 = /** @class */ (function () {
    function Vec3() {
    }
    Vec3.set = function (x, y, z, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.set(out, x, y, z);
    };
    Vec3.fromValues = function (x, y, z) {
        return gl_matrix_1.vec3.fromValues(x, y, z);
    };
    Vec3.create = function () {
        return gl_matrix_1.vec3.create();
    };
    Vec3.add = function (a, b, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.add(out, a, b);
    };
    Vec3.transformQuat = function (a, q, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.transformQuat(out, a, q);
    };
    Vec3.subtract = function (a, b, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.subtract(out, a, b);
    };
    Vec3.scale = function (a, b, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.scale(out, a, b);
    };
    Vec3.dot = function (a, b) {
        return gl_matrix_1.vec3.dot(a, b);
    };
    Vec3.normalize = function (a, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.normalize(out, a);
    };
    Vec3.cross = function (a, b, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.cross(out, a, b);
    };
    Vec3.transformMat4 = function (a, m, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.transformMat4(out, a, m);
    };
    Vec3.copy = function (a, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.copy(out, a);
    };
    Vec3.magnitude = function (a) {
        return gl_matrix_1.vec3.length(a);
    };
    Vec3.inverse = function (a, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.inverse(out, a);
    };
    Vec3.negate = function (a, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.negate(out, a);
    };
    Vec3.multiply = function (a, b, out) {
        if (out === void 0) { out = new Float32Array(3); }
        return gl_matrix_1.vec3.multiply(out, a, b);
    };
    Vec3.distance = function (a, b) {
        return gl_matrix_1.vec3.distance(a, b);
    };
    Vec3.squaredDistance = function (a, b) {
        return gl_matrix_1.vec3.squaredDistance(a, b);
    };
    return Vec3;
}());
exports.Vec3 = Vec3;


/***/ }),

/***/ "./src/math/vec4.ts":
/*!**************************!*\
  !*** ./src/math/vec4.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Vec4 = void 0;
var gl_matrix_1 = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
var Vec4 = /** @class */ (function () {
    function Vec4() {
    }
    Vec4.set = function (x, y, z, w, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.vec4.set(out, x, y, z, w);
    };
    Vec4.transformMat4 = function (a, m, out) {
        if (out === void 0) { out = new Float32Array(4); }
        return gl_matrix_1.vec4.transformMat4(out, a, m);
    };
    Vec4.fromValues = function (x, y, z, w) {
        return gl_matrix_1.vec4.fromValues(x, y, z, w);
    };
    return Vec4;
}());
exports.Vec4 = Vec4;


/***/ }),

/***/ "./src/mesh/geometry/cube-geometry.ts":
/*!********************************************!*\
  !*** ./src/mesh/geometry/cube-geometry.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CubeGeometry = void 0;
var mesh_geometry_1 = __webpack_require__(/*! ./mesh-geometry */ "./src/mesh/geometry/mesh-geometry.ts");
var CubeGeometry;
(function (CubeGeometry) {
    function create() {
        return Object.assign(new mesh_geometry_1.MeshGeometry3D(), {
            positions: {
                buffer: new Float32Array([-1, 1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1])
            },
            indices: {
                buffer: new Uint8Array([0, 1, 2, 0, 3, 1, 4, 5, 6, 4, 7, 5, 8, 9, 10, 8, 11, 9, 12, 13, 14, 12, 15, 13, 16, 17, 18, 16, 19, 17, 20, 21, 22, 20, 23, 21])
            },
            normals: {
                buffer: new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0])
            },
            uvs: [{
                    buffer: new Float32Array([0.625, 1, 0.375, 0.75, 0.375, 1, 0.625, 0.75, 0.625, 0.75, 0.375, 0.5, 0.375, 0.75, 0.625, 0.5, 0.625, 0.5, 0.375, 0.25, 0.375, 0.5, 0.625, 0.25, 0.625, 0.25, 0.375, 0, 0.375, 0.25, 0.625, 0, 0.375, 0.25, 0.125, 0.5, 0.375, 0.5, 0.125, 0.25, 0.875, 0.25, 0.625, 0.5, 0.875, 0.5, 0.625, 0.25])
                }],
            tangents: {
                buffer: new Float32Array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1])
            }
        });
    }
    CubeGeometry.create = create;
})(CubeGeometry = exports.CubeGeometry || (exports.CubeGeometry = {}));


/***/ }),

/***/ "./src/mesh/geometry/mesh-geometry.ts":
/*!********************************************!*\
  !*** ./src/mesh/geometry/mesh-geometry.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MeshGeometry3D = void 0;
/**
 * Geometry with mesh data (i.e. positions, normals, uvs).
 */
var MeshGeometry3D = /** @class */ (function () {
    function MeshGeometry3D() {
        this._shaderGeometry = {};
    }
    /**
     * Returns geometry with attributes required by the specified shader.
     * @param shader The shader to use.
     */
    MeshGeometry3D.prototype.getShaderGeometry = function (shader) {
        return this._shaderGeometry[shader.name];
    };
    /**
     * Creates geometry with attributes required by the specified shader.
     * @param shader The shader to use.
     * @param instanced Value indicating if the geometry will be instanced.
     */
    MeshGeometry3D.prototype.addShaderGeometry = function (shader, instanced) {
        this._shaderGeometry[shader.name] = shader.createShaderGeometry(this, instanced);
    };
    /**
     * Returns a value indicating if geometry with required attributes has been created the specified shader.
     * @param shader The shader to test.
     * @param instanced Value indicating if the geometry is instanced.
     */
    MeshGeometry3D.prototype.hasShaderGeometry = function (shader, instanced) {
        if (this._shaderGeometry[shader.name]) {
            return !instanced || (instanced && this._shaderGeometry[shader.name].instanced);
        }
        return false;
    };
    /**
     * Destroys the geometry and it's used resources.
     */
    MeshGeometry3D.prototype.destroy = function () {
        for (var name_1 in this._shaderGeometry) {
            this._shaderGeometry[name_1].destroy();
        }
        this._shaderGeometry = {};
    };
    return MeshGeometry3D;
}());
exports.MeshGeometry3D = MeshGeometry3D;


/***/ }),

/***/ "./src/mesh/geometry/plane-geometry.ts":
/*!*********************************************!*\
  !*** ./src/mesh/geometry/plane-geometry.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaneGeometry = void 0;
var mesh_geometry_1 = __webpack_require__(/*! ./mesh-geometry */ "./src/mesh/geometry/mesh-geometry.ts");
var PlaneGeometry;
(function (PlaneGeometry) {
    function create() {
        return Object.assign(new mesh_geometry_1.MeshGeometry3D(), {
            positions: {
                buffer: new Float32Array([-1, 0, 1, 1, 0, -1, -1, 0, -1, 1, 0, 1])
            },
            indices: {
                buffer: new Uint8Array([0, 1, 2, 0, 3, 1])
            },
            normals: {
                buffer: new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0])
            },
            uvs: [{
                    buffer: new Float32Array([0, 1, 1, 0, 0, 0, 1, 1])
                }]
        });
    }
    PlaneGeometry.create = create;
})(PlaneGeometry = exports.PlaneGeometry || (exports.PlaneGeometry = {}));


/***/ }),

/***/ "./src/mesh/geometry/quad-geometry.ts":
/*!********************************************!*\
  !*** ./src/mesh/geometry/quad-geometry.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadGeometry = void 0;
var mesh_geometry_1 = __webpack_require__(/*! ./mesh-geometry */ "./src/mesh/geometry/mesh-geometry.ts");
var QuadGeometry;
(function (QuadGeometry) {
    function create() {
        return Object.assign(new mesh_geometry_1.MeshGeometry3D(), {
            positions: {
                buffer: new Float32Array([-1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 1, 0])
            },
            indices: {
                buffer: new Uint8Array([0, 2, 1, 0, 1, 3])
            },
            normals: {
                buffer: new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1])
            },
            uvs: [{
                    buffer: new Float32Array([0, 0, 1, 1, 0, 1, 1, 0])
                }]
        });
    }
    QuadGeometry.create = create;
})(QuadGeometry = exports.QuadGeometry || (exports.QuadGeometry = {}));


/***/ }),

/***/ "./src/mesh/instanced-mesh.ts":
/*!************************************!*\
  !*** ./src/mesh/instanced-mesh.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InstancedMesh3D = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var container_1 = __webpack_require__(/*! ../container */ "./src/container.ts");
var InstancedMesh3D = /** @class */ (function (_super) {
    tslib_1.__extends(InstancedMesh3D, _super);
    function InstancedMesh3D(mesh, material) {
        var _this = _super.call(this) || this;
        _this.mesh = mesh;
        _this.material = material;
        return _this;
    }
    InstancedMesh3D.prototype.destroy = function (options) {
        _super.prototype.destroy.call(this, options);
        this.mesh.removeInstance(this);
    };
    return InstancedMesh3D;
}(container_1.Container3D));
exports.InstancedMesh3D = InstancedMesh3D;


/***/ }),

/***/ "./src/mesh/mesh-shader.ts":
/*!*********************************!*\
  !*** ./src/mesh/mesh-shader.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MeshShader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
/**
 * Shader used specifically to render a mesh.
 */
var MeshShader = /** @class */ (function (_super) {
    tslib_1.__extends(MeshShader, _super);
    function MeshShader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._state = Object.assign(new PIXI.State(), {
            culling: true, clockwiseFrontFace: false, depthTest: true
        });
        return _this;
    }
    Object.defineProperty(MeshShader.prototype, "name", {
        /** The name of the mesh shader. Used for figuring out if geometry attributesis compatible with the shader. This needs to be set to something different than default value when custom attributes is used. */
        get: function () {
            return "mesh-shader";
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates geometry with required attributes used by this shader. Override when using custom attributes.
     * @param geometry The geometry with mesh data.
     * @param instanced Value indicating if the geometry will be instanced.
     */
    MeshShader.prototype.createShaderGeometry = function (geometry, instanced) {
        var result = new PIXI.Geometry();
        if (geometry.indices) {
            if (geometry.indices.buffer.BYTES_PER_ELEMENT === 1) {
                // PIXI seems to have problems with Uint8Array, let's convert to UNSIGNED_SHORT.
                result.addIndex(new PIXI.Buffer(new Uint16Array(geometry.indices.buffer)));
            }
            else {
                result.addIndex(new PIXI.Buffer(geometry.indices.buffer));
            }
        }
        if (geometry.positions) {
            result.addAttribute("a_Position", new PIXI.Buffer(geometry.positions.buffer), 3, false, geometry.positions.componentType, geometry.positions.stride);
        }
        if (geometry.uvs && geometry.uvs[0]) {
            result.addAttribute("a_UV1", new PIXI.Buffer(geometry.uvs[0].buffer), 2, false, geometry.uvs[0].componentType, geometry.uvs[0].stride);
        }
        if (geometry.normals) {
            result.addAttribute("a_Normal", new PIXI.Buffer(geometry.normals.buffer), 3, false, geometry.normals.componentType, geometry.normals.stride);
        }
        if (geometry.tangents) {
            result.addAttribute("a_Tangent", new PIXI.Buffer(geometry.tangents.buffer), 4, false, geometry.tangents.componentType, geometry.tangents.stride);
        }
        return result;
    };
    /**
     * Renders the geometry of the specified mesh.
     * @param mesh Mesh to render.
     * @param renderer Renderer to use.
     * @param state Rendering state to use.
     * @param drawMode Draw mode to use.
     */
    MeshShader.prototype.render = function (mesh, renderer, state, drawMode) {
        if (state === void 0) { state = this._state; }
        if (drawMode === void 0) { drawMode = PIXI.DRAW_MODES.TRIANGLES; }
        var instanceCount = mesh.instances.filter(function (i) {
            return i.worldVisible && i.renderable;
        }).length;
        var instancing = mesh.instances.length > 0;
        if (!mesh.geometry.hasShaderGeometry(this, instancing)) {
            mesh.geometry.addShaderGeometry(this, instancing);
        }
        var geometry = mesh.geometry.getShaderGeometry(this);
        renderer.shader.bind(this, false);
        renderer.state.set(state);
        renderer.geometry.bind(geometry, this);
        renderer.geometry.draw(drawMode, undefined, undefined, instanceCount);
    };
    return MeshShader;
}(PIXI.Shader));
exports.MeshShader = MeshShader;


/***/ }),

/***/ "./src/mesh/mesh.ts":
/*!**************************!*\
  !*** ./src/mesh/mesh.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Mesh3D = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var plane_geometry_1 = __webpack_require__(/*! ./geometry/plane-geometry */ "./src/mesh/geometry/plane-geometry.ts");
var cube_geometry_1 = __webpack_require__(/*! ./geometry/cube-geometry */ "./src/mesh/geometry/cube-geometry.ts");
var standard_material_1 = __webpack_require__(/*! ../material/standard/standard-material */ "./src/material/standard/standard-material.ts");
var container_1 = __webpack_require__(/*! ../container */ "./src/container.ts");
var quad_geometry_1 = __webpack_require__(/*! ./geometry/quad-geometry */ "./src/mesh/geometry/quad-geometry.ts");
var instanced_mesh_1 = __webpack_require__(/*! ./instanced-mesh */ "./src/mesh/instanced-mesh.ts");
var platform_1 = __webpack_require__(/*! ../platform */ "./src/platform.ts");
/**
 * Represents a mesh which contains geometry and has a material.
 */
var Mesh3D = /** @class */ (function (_super) {
    tslib_1.__extends(Mesh3D, _super);
    /**
     * Creates a new mesh with the specified geometry and material.
     * @param geometry The geometry for the mesh.
     * @param material The material for the mesh. If the material is empty the mesh won't be rendered.
     */
    function Mesh3D(geometry, material) {
        var _this = _super.call(this) || this;
        _this.geometry = geometry;
        _this.material = material;
        /** The name of the plugin used for rendering the mesh. */
        _this.pluginName = "pipeline";
        /** The enabled render passes for this mesh. */
        _this.enabledRenderPasses = ["material"];
        _this._instances = [];
        if (!geometry) {
            throw new Error("PIXI3D: Geometry is required when creating a mesh.");
        }
        return _this;
    }
    /**
     * Returns a value indicating if specified renderer supports instancing.
     * @param renderer The renderer.
     */
    Mesh3D.isInstancingSupported = function (renderer) {
        return platform_1.Platform.isInstancingSupported(renderer);
    };
    Object.defineProperty(Mesh3D.prototype, "instances", {
        /** An array of instances created from this mesh. */
        get: function () {
            return this._instances;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new instance of this mesh.
     */
    Mesh3D.prototype.createInstance = function () {
        var _a;
        if (this.material && !this.material.isInstancingSupported) {
            throw new Error("PIXI3D: Can't create instance of mesh, material does not supported instancing.");
        }
        return this._instances[this._instances.push(new instanced_mesh_1.InstancedMesh3D(this, (_a = this.material) === null || _a === void 0 ? void 0 : _a.createInstance())) - 1];
    };
    /**
     * Removes a instanced mesh from this mesh.
     * @param instance The instance to remove.
     */
    Mesh3D.prototype.removeInstance = function (instance) {
        var index = this._instances.indexOf(instance);
        if (index >= 0) {
            this._instances.splice(index, 1);
        }
    };
    /**
     * Enables the render pass with the specified name.
     * @param name The name of the render pass to enable.
     */
    Mesh3D.prototype.enableRenderPass = function (name) {
        if (this.enabledRenderPasses.indexOf(name) < 0) {
            this.enabledRenderPasses.push(name);
        }
    };
    /**
     * Disables the render pass with the specified name.
     * @param name The name of the render pass to disable.
     */
    Mesh3D.prototype.disableRenderPass = function (name) {
        var index = this.enabledRenderPasses.indexOf(name);
        if (index >= 0) {
            this.enabledRenderPasses.splice(index, 1);
        }
    };
    /**
     * Returns a value indicating if the specified render pass is enabled.
     * @param name The name of the render pass to check.
     */
    Mesh3D.prototype.isRenderPassEnabled = function (name) {
        return this.enabledRenderPasses.indexOf(name) >= 0;
    };
    /**
     * Destroys the mesh and it's used resources.
     */
    Mesh3D.prototype.destroy = function () {
        this.geometry.destroy();
        if (this.material) {
            this.material.destroy();
        }
        _super.prototype.destroy.call(this);
    };
    Mesh3D.prototype._render = function (renderer) {
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    };
    /**
     * Creates a new quad (flat square) mesh with the specified material.
     * @param material The material to use.
     */
    Mesh3D.createQuad = function (material) {
        if (material === void 0) { material = new standard_material_1.StandardMaterial(); }
        return new Mesh3D(quad_geometry_1.QuadGeometry.create(), material);
    };
    /**
     * Creates a new cube (six faces) mesh with the specified material.
     * @param material The material to use.
     */
    Mesh3D.createCube = function (material) {
        if (material === void 0) { material = new standard_material_1.StandardMaterial(); }
        return new Mesh3D(cube_geometry_1.CubeGeometry.create(), material);
    };
    /**
     * Creates a new plane (flat square) mesh with the specified material.
     * @param material The material to use.
     */
    Mesh3D.createPlane = function (material) {
        if (material === void 0) { material = new standard_material_1.StandardMaterial(); }
        return new Mesh3D(plane_geometry_1.PlaneGeometry.create(), material);
    };
    return Mesh3D;
}(container_1.Container3D));
exports.Mesh3D = Mesh3D;


/***/ }),

/***/ "./src/model.ts":
/*!**********************!*\
  !*** ./src/model.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Model = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var gltf_parser_1 = __webpack_require__(/*! ./gltf/gltf-parser */ "./src/gltf/gltf-parser.ts");
var container_1 = __webpack_require__(/*! ./container */ "./src/container.ts");
var instanced_model_1 = __webpack_require__(/*! ./instanced-model */ "./src/instanced-model.ts");
/**
 * Represents a model which includes a hierarchy of meshes and animations.
 */
var Model = /** @class */ (function (_super) {
    tslib_1.__extends(Model, _super);
    function Model() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The animations included in the model. */
        _this.animations = [];
        /**
         * The meshes included in the model. Note that this array and the actual
         * childen are not automatically synchronized after the model has been loaded.
         */
        _this.meshes = [];
        return _this;
    }
    /**
     * Creates a new model from a source.
     * @param source The source to create the model from.
     * @param materialFactory The factory to use for creating materials.
     */
    Model.from = function (source, materialFactory) {
        return gltf_parser_1.glTFParser.createModel(source, materialFactory);
    };
    /**
     * Creates a new instance of this model.
     */
    Model.prototype.createInstance = function () {
        return instanced_model_1.InstancedModel.from(this);
    };
    return Model;
}(container_1.Container3D));
exports.Model = Model;


/***/ }),

/***/ "./src/picking/picking-hitarea.ts":
/*!****************************************!*\
  !*** ./src/picking/picking-hitarea.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PickingHitArea = void 0;
var picking_id_1 = __webpack_require__(/*! ./picking-id */ "./src/picking/picking-id.ts");
/**
 * Hit area which uses the shape of an object to determine interaction.
 */
var PickingHitArea = /** @class */ (function () {
    /**
     * Creates a new hitarea using the specified object.
     * @param renderer The renderer to use.
     * @param object The model or mesh to test for interaction.
     * @param camera The camera to use when rendering the object.
     */
    function PickingHitArea(renderer, object, camera) {
        this.object = object;
        this.camera = camera;
        /** The id which maps to the object. */
        this.id = picking_id_1.PickingId.next();
        this._manager = renderer.plugins.picking;
    }
    PickingHitArea.prototype.contains = function (x, y) {
        return this._manager.containsHitArea(x, y, this);
    };
    return PickingHitArea;
}());
exports.PickingHitArea = PickingHitArea;


/***/ }),

/***/ "./src/picking/picking-id.ts":
/*!***********************************!*\
  !*** ./src/picking/picking-id.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PickingId = void 0;
var PickingId;
(function (PickingId) {
    var id = 0;
    function next() {
        id++;
        return new Uint8Array([
            (id >> 16) & 255, (id >> 8) & 255, id & 255
        ]);
    }
    PickingId.next = next;
})(PickingId = exports.PickingId || (exports.PickingId = {}));


/***/ }),

/***/ "./src/picking/picking-manager.ts":
/*!****************************************!*\
  !*** ./src/picking/picking-manager.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PickingManager = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var picking_map_1 = __webpack_require__(/*! ./picking-map */ "./src/picking/picking-map.ts");
/**
 * Manages the picking hit areas by keeping track on which hit areas needs to
 * be checked for interaction. Renders the hit area meshes to a texture which
 * is then used to map a mesh to a x/y coordinate. The picking manager is
 * registered as a renderer plugin.
 */
var PickingManager = /** @class */ (function () {
    /**
     * Creates a new picking manager using the specified renderer.
     * @param renderer The renderer to use.
     */
    function PickingManager(renderer) {
        var _this = this;
        this.renderer = renderer;
        this._hitAreas = [];
        this._map = new picking_map_1.PickingMap(this.renderer, 128 * Math.floor(this.renderer.width / this.renderer.height), 128);
        renderer.on("postrender", function () {
            // Because of how PixiJS interaction works and the design of the picking,
            // the "hitTest" function needs to be called. Otherwise, in some 
            // circumstances; the picking is affected by in which order the interaction 
            // object was added to the heirarchy.
            _this.renderer.plugins.interaction.hitTest(new PIXI.Point(0, 0));
            if (_this._hitAreas.length === 0) {
                return;
            }
            var width = Math.floor(_this._map.height * (_this.renderer.width / _this.renderer.height));
            if (_this._map.width !== width) {
                _this._map.resize(width, _this._map.height);
            }
            _this._map.update(_this._hitAreas);
            _this._hitAreas = [];
        });
    }
    PickingManager.prototype.destroy = function () {
    };
    /**
     * Hit tests a area using the specified x/y coordinates.
     * @param x The x coordinate.
     * @param y The y coordinate.
     * @param hitArea The hit area to test.
     */
    PickingManager.prototype.containsHitArea = function (x, y, hitArea) {
        if (this._hitAreas.indexOf(hitArea) < 0) {
            this._hitAreas.push(hitArea);
        }
        return this._map.containsId(x, y, hitArea.id);
    };
    return PickingManager;
}());
exports.PickingManager = PickingManager;
PIXI.Renderer.registerPlugin("picking", PickingManager);


/***/ }),

/***/ "./src/picking/picking-map.ts":
/*!************************************!*\
  !*** ./src/picking/picking-map.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PickingMap = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var camera_1 = __webpack_require__(/*! ../camera/camera */ "./src/camera/camera.ts");
var mesh_1 = __webpack_require__(/*! ../mesh/mesh */ "./src/mesh/mesh.ts");
var mesh_shader_1 = __webpack_require__(/*! ../mesh/mesh-shader */ "./src/mesh/mesh-shader.ts");
var PickingMap = /** @class */ (function () {
    function PickingMap(_renderer, width, height) {
        this._renderer = _renderer;
        this._update = 0;
        this._pixels = new Uint8Array(width * height * 4);
        this._output = PIXI.RenderTexture.create({ width: width, height: height });
        this._shader = new mesh_shader_1.MeshShader(PIXI.Program.from(__webpack_require__(/*! ./shader/picking.vert */ "./src/picking/shader/picking.vert"), __webpack_require__(/*! ./shader/picking.frag */ "./src/picking/shader/picking.frag")));
        this._output.framebuffer.addDepthTexture();
    }
    PickingMap.prototype.destroy = function () {
        this._output.destroy(true);
        this._shader.destroy();
    };
    PickingMap.prototype.resize = function (width, height) {
        this._pixels = new Uint8Array(width * height * 4);
        this._output.resize(width, height);
    };
    PickingMap.prototype.containsId = function (x, y, id) {
        var _a = this._renderer.screen, width = _a.width, height = _a.height;
        x = Math.floor(x / width * this._output.width);
        y = Math.floor((height - y) / height * this._output.height);
        for (var i = 0; i < 3; i++) {
            if (id[i] !== this._pixels[(y * this._output.width + x) * 4 + i]) {
                return false;
            }
        }
        return true;
    };
    Object.defineProperty(PickingMap.prototype, "width", {
        get: function () { return this._output.width; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PickingMap.prototype, "height", {
        get: function () { return this._output.height; },
        enumerable: false,
        configurable: true
    });
    PickingMap.prototype.update = function (hitAreas) {
        var e_1, _a, e_2, _b;
        this._renderer.renderTexture.bind(this._output);
        if (this._update++ % 2 === 0) {
            // For performance reasons, the update method alternates between rendering 
            // the meshes and reading the pixels from the rendered texture.
            this._renderer.renderTexture.clear();
            try {
                for (var hitAreas_1 = tslib_1.__values(hitAreas), hitAreas_1_1 = hitAreas_1.next(); !hitAreas_1_1.done; hitAreas_1_1 = hitAreas_1.next()) {
                    var hitArea = hitAreas_1_1.value;
                    var meshes = hitArea.object instanceof mesh_1.Mesh3D ? [hitArea.object] : hitArea.object.meshes;
                    var camera = hitArea.camera || camera_1.Camera.main;
                    try {
                        for (var meshes_1 = (e_2 = void 0, tslib_1.__values(meshes)), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                            var mesh = meshes_1_1.value;
                            this._shader.uniforms.u_World = mesh.transform.worldTransform.array;
                            this._shader.uniforms.u_Id = hitArea.id;
                            this._shader.uniforms.u_ViewProjection = camera.viewProjection;
                            this._shader.render(mesh, this._renderer);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (meshes_1_1 && !meshes_1_1.done && (_b = meshes_1.return)) _b.call(meshes_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (hitAreas_1_1 && !hitAreas_1_1.done && (_a = hitAreas_1.return)) _a.call(hitAreas_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else {
            var gl = this._renderer.gl;
            gl.readPixels(0, 0, this._output.width, this._output.height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixels);
        }
        this._renderer.renderTexture.bind(undefined);
    };
    return PickingMap;
}());
exports.PickingMap = PickingMap;


/***/ }),

/***/ "./src/picking/shader/picking.frag":
/*!*****************************************!*\
  !*** ./src/picking/shader/picking.frag ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform vec3 u_Id;\n\nvoid main() {\n  gl_FragColor = vec4(u_Id / 255.0, 1.0);\n}"

/***/ }),

/***/ "./src/picking/shader/picking.vert":
/*!*****************************************!*\
  !*** ./src/picking/shader/picking.vert ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec3 a_Position;\n\nuniform mat4 u_World;\nuniform mat4 u_ViewProjection;\n\nvoid main() {\n  gl_Position = u_ViewProjection * u_World * vec4(a_Position, 1.0);\n}"

/***/ }),

/***/ "./src/pipeline/material-render-pass.ts":
/*!**********************************************!*\
  !*** ./src/pipeline/material-render-pass.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MaterialRenderPass = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var color_1 = __webpack_require__(/*! ../color */ "./src/color.ts");
/**
 * Pass used for rendering materials.
 */
var MaterialRenderPass = /** @class */ (function () {
    /**
     * Creates a new material render pass.
     * @param renderer The renderer to use.
     * @param name The name of the render pass.
     */
    function MaterialRenderPass(renderer, name) {
        this.renderer = renderer;
        this.name = name;
        /** The color (r,g,b,a) used for clearing the render texture. If this value is empty, the render texture will not be cleared. */
        this.clearColor = new color_1.Color(0, 0, 0, 0);
    }
    Object.defineProperty(MaterialRenderPass.prototype, "renderTexture", {
        /** The texture used when rendering to a texture. */
        get: function () {
            return this._renderTexture;
        },
        set: function (value) {
            this._renderTexture = value;
        },
        enumerable: false,
        configurable: true
    });
    MaterialRenderPass.prototype.clear = function () {
        if (this._renderTexture && this.clearColor) {
            var current = this.renderer.renderTexture.current;
            this.renderer.renderTexture.bind(this._renderTexture);
            this.renderer.renderTexture.clear(Array.from(this.clearColor.rgba));
            this.renderer.renderTexture.bind(current);
        }
    };
    MaterialRenderPass.prototype.render = function (meshes) {
        var e_1, _a;
        var current = this.renderer.renderTexture.current;
        if (this._renderTexture) {
            this.renderer.renderTexture.bind(this._renderTexture);
        }
        try {
            for (var meshes_1 = tslib_1.__values(meshes), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                var mesh = meshes_1_1.value;
                if (mesh.material) {
                    mesh.material.render(mesh, this.renderer);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (meshes_1_1 && !meshes_1_1.done && (_a = meshes_1.return)) _a.call(meshes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (this._renderTexture) {
            this.renderer.renderTexture.bind(current);
        }
    };
    return MaterialRenderPass;
}());
exports.MaterialRenderPass = MaterialRenderPass;


/***/ }),

/***/ "./src/pipeline/standard-pipeline.ts":
/*!*******************************************!*\
  !*** ./src/pipeline/standard-pipeline.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardPipeline = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var material_render_pass_1 = __webpack_require__(/*! ./material-render-pass */ "./src/pipeline/material-render-pass.ts");
var shadow_render_pass_1 = __webpack_require__(/*! ../shadow/shadow-render-pass */ "./src/shadow/shadow-render-pass.ts");
var post_processing_sprite_1 = __webpack_require__(/*! ../sprite/post-processing-sprite */ "./src/sprite/post-processing-sprite.ts");
var model_1 = __webpack_require__(/*! ../model */ "./src/model.ts");
var standard_material_1 = __webpack_require__(/*! ../material/standard/standard-material */ "./src/material/standard/standard-material.ts");
var material_render_sort_type_1 = __webpack_require__(/*! ../material/material-render-sort-type */ "./src/material/material-render-sort-type.ts");
/**
 * The standard pipeline renders meshes using the specified render passes. The
 * standard pipeline is created and used by default.
 */
var StandardPipeline = /** @class */ (function (_super) {
    tslib_1.__extends(StandardPipeline, _super);
    /**
     * Creates a new standard pipeline using the specified renderer.
     * @param renderer The renderer to use.
     */
    function StandardPipeline(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.renderer = renderer;
        _this._renderPasses = [];
        _this._meshes = [];
        _this._shadowPass = _this.addRenderPass(new shadow_render_pass_1.ShadowRenderPass(renderer, "shadow"));
        _this._materialPass = _this.addRenderPass(new material_render_pass_1.MaterialRenderPass(renderer, "material"));
        renderer.on("prerender", function () {
            var e_1, _a;
            try {
                for (var _b = tslib_1.__values(_this._renderPasses), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var pass = _c.value;
                    if (pass.clear) {
                        pass.clear();
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        return _this;
    }
    /**
     * Returns the standard pipeline from the specified renderer.
     * @param renderer The renderer to use.
     */
    StandardPipeline.from = function (renderer) {
        return renderer.plugins.pipeline;
    };
    /**
     * Adds a render pass.
     * @param renderPass The pass to add.
     */
    StandardPipeline.prototype.addRenderPass = function (renderPass) {
        if (this._renderPasses.indexOf(renderPass) < 0) {
            this._renderPasses.push(renderPass);
        }
        return renderPass;
    };
    /**
     * Removes a render pass.
     * @param renderPass The pass to remove.
     */
    StandardPipeline.prototype.removeRenderPass = function (renderPass) {
        var index = this._renderPasses.indexOf(renderPass);
        if (index >= 0) {
            this._renderPasses.splice(index, 1);
        }
    };
    /**
     * Creates a new post processing sprite and uses that to render to it's
     * texture.
     * @param options The options when creating the sprite.
     */
    StandardPipeline.prototype.createPostProcessingSprite = function (options) {
        var sprite = new post_processing_sprite_1.PostProcessingSprite(this.renderer, options);
        this._materialPass.renderTexture = sprite.renderTexture;
        return sprite;
    };
    /**
     * Adds a mesh to be rendered.
     * @param mesh Mesh to add.
     */
    StandardPipeline.prototype.render = function (mesh) {
        this._meshes.push(mesh);
    };
    /**
     * Renders the added meshes using the specified render passes.
     */
    StandardPipeline.prototype.flush = function () {
        var e_2, _a;
        this.sort();
        var _loop_1 = function (pass) {
            pass.render(this_1._meshes.filter(function (mesh) { return mesh.isRenderPassEnabled(pass.name); }));
        };
        var this_1 = this;
        try {
            for (var _b = tslib_1.__values(this._renderPasses), _c = _b.next(); !_c.done; _c = _b.next()) {
                var pass = _c.value;
                _loop_1(pass);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this._meshes = [];
    };
    /**
     * Sorts the meshes by rendering order.
     */
    StandardPipeline.prototype.sort = function () {
        this._meshes.sort(function (a, b) {
            if (!a.material || !b.material) {
                return 0;
            }
            if (a.material.renderSortType !== b.material.renderSortType) {
                return a.material.renderSortType === material_render_sort_type_1.MaterialRenderSortType.transparent ? 1 : -1;
            }
            return 0;
        });
    };
    Object.defineProperty(StandardPipeline.prototype, "shadowPass", {
        /** The pass used for rendering shadows. */
        get: function () {
            return this._shadowPass;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandardPipeline.prototype, "materialPass", {
        /** The pass used for rendering materials. */
        get: function () {
            return this._materialPass;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Enables shadows for the specified object. Adds the shadow render pass to
     * the specified object and enables the standard material to use the casting
     * light.
     * @param object The mesh or model to enable shadows for.
     * @param light The shadow casting light to associate with the
     * object when using the standard material.
     */
    StandardPipeline.prototype.enableShadows = function (object, light) {
        var e_3, _a;
        var meshes = object instanceof model_1.Model ? object.meshes : [object];
        try {
            for (var meshes_1 = tslib_1.__values(meshes), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                var mesh = meshes_1_1.value;
                if (light && mesh.material instanceof standard_material_1.StandardMaterial) {
                    mesh.material.shadowCastingLight = light;
                }
                mesh.enableRenderPass(this._shadowPass.name);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (meshes_1_1 && !meshes_1_1.done && (_a = meshes_1.return)) _a.call(meshes_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (light) {
            this._shadowPass.addShadowCastingLight(light);
        }
    };
    /**
     * Disables shadows for the specified object.
     * @param object The mesh or model to disable shadows for.
     */
    StandardPipeline.prototype.disableShadows = function (object) {
        var e_4, _a;
        var meshes = object instanceof model_1.Model ? object.meshes : [object];
        try {
            for (var meshes_2 = tslib_1.__values(meshes), meshes_2_1 = meshes_2.next(); !meshes_2_1.done; meshes_2_1 = meshes_2.next()) {
                var mesh = meshes_2_1.value;
                if (mesh.material instanceof standard_material_1.StandardMaterial) {
                    mesh.material.shadowCastingLight = undefined;
                }
                mesh.disableRenderPass(this._shadowPass.name);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (meshes_2_1 && !meshes_2_1.done && (_a = meshes_2.return)) _a.call(meshes_2);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    return StandardPipeline;
}(PIXI.ObjectRenderer));
exports.StandardPipeline = StandardPipeline;
PIXI.Renderer.registerPlugin("pipeline", StandardPipeline);


/***/ }),

/***/ "./src/pixi/array-resource.ts":
/*!************************************!*\
  !*** ./src/pixi/array-resource.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayResource = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
// @ts-ignore
exports.ArrayResource = PIXI.ArrayResource || PIXI.resources.ArrayResource;


/***/ }),

/***/ "./src/pixi/base-image-resource.ts":
/*!*****************************************!*\
  !*** ./src/pixi/base-image-resource.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseImageResource = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
// @ts-ignore
exports.BaseImageResource = PIXI.BaseImageResource || PIXI.resources.BaseImageResource;


/***/ }),

/***/ "./src/pixi/buffer-resource.ts":
/*!*************************************!*\
  !*** ./src/pixi/buffer-resource.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferResource = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
// @ts-ignore
exports.BufferResource = PIXI.BufferResource || PIXI.resources.BufferResource;


/***/ }),

/***/ "./src/pixi/cube-resource.ts":
/*!***********************************!*\
  !*** ./src/pixi/cube-resource.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CubeResource = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
// @ts-ignore
exports.CubeResource = PIXI.CubeResource || PIXI.resources.CubeResource;


/***/ }),

/***/ "./src/platform.ts":
/*!*************************!*\
  !*** ./src/platform.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Platform = void 0;
var Platform;
(function (Platform) {
    var _maxVertexUniformVectors;
    function getMaxVertexUniformVectors(renderer) {
        if (_maxVertexUniformVectors !== undefined) {
            return _maxVertexUniformVectors;
        }
        var gl = renderer.gl;
        _maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        return _maxVertexUniformVectors;
    }
    Platform.getMaxVertexUniformVectors = getMaxVertexUniformVectors;
    var _isFloatTextureSupported;
    function isFloatTextureSupported(renderer) {
        if (renderer.context.webGLVersion === 2) {
            return true;
        }
        if (_isFloatTextureSupported !== undefined) {
            return _isFloatTextureSupported;
        }
        var gl = renderer.gl;
        var ext = gl.getExtension("OES_texture_float");
        if (ext) {
            return true;
        }
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 8, 8, 0, gl.RGBA, gl.FLOAT, null);
        _isFloatTextureSupported = gl.getError() === gl.NO_ERROR;
        gl.deleteTexture(texture);
        return _isFloatTextureSupported;
    }
    Platform.isFloatTextureSupported = isFloatTextureSupported;
    var _isHalfFloatFramebufferSupported;
    function isHalfFloatFramebufferSupported(renderer) {
        if (renderer.context.webGLVersion === 2) {
            return true;
        }
        if (_isHalfFloatFramebufferSupported !== undefined) {
            return _isHalfFloatFramebufferSupported;
        }
        var gl = renderer.gl;
        var ext = gl.getExtension("OES_texture_half_float");
        if (!ext) {
            return false;
        }
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 8, 8, 0, gl.RGBA, ext.HALF_FLOAT_OES, null);
        var fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        var attachmentPoint = gl.COLOR_ATTACHMENT0;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, texture, 0);
        _isHalfFloatFramebufferSupported = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
        return _isHalfFloatFramebufferSupported;
    }
    Platform.isHalfFloatFramebufferSupported = isHalfFloatFramebufferSupported;
    var _isFloatFramebufferSupported;
    function isFloatFramebufferSupported(renderer) {
        if (renderer.context.webGLVersion === 2) {
            return true;
        }
        if (_isFloatFramebufferSupported !== undefined) {
            return _isFloatFramebufferSupported;
        }
        var gl = renderer.gl;
        var ext = gl.getExtension("OES_texture_float");
        if (!ext) {
            return false;
        }
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 8, 8, 0, gl.RGBA, gl.FLOAT, null);
        var fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        var attachmentPoint = gl.COLOR_ATTACHMENT0;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, texture, 0);
        _isFloatFramebufferSupported = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
        return _isFloatFramebufferSupported;
    }
    Platform.isFloatFramebufferSupported = isFloatFramebufferSupported;
    var _isFloatLinearSupported;
    function supportsFloatLinear(renderer) {
        if (_isFloatLinearSupported !== undefined) {
            return _isFloatLinearSupported;
        }
        var gl = renderer.gl;
        _isFloatLinearSupported = gl.getExtension("OES_texture_float_linear") !== null;
        return _isFloatLinearSupported;
    }
    Platform.supportsFloatLinear = supportsFloatLinear;
    function isShaderTextureLodSupported(renderer) {
        if (renderer.context.webGLVersion === 2) {
            return true;
        }
        return renderer.gl.getExtension("EXT_shader_texture_lod") !== null;
    }
    Platform.isShaderTextureLodSupported = isShaderTextureLodSupported;
    var _isInstancingSupported;
    function isInstancingSupported(renderer) {
        if (_isInstancingSupported !== undefined) {
            return _isInstancingSupported;
        }
        var gl = renderer.gl;
        _isInstancingSupported = gl.getExtension('ANGLE_instanced_arrays') !== undefined;
        return _isInstancingSupported;
    }
    Platform.isInstancingSupported = isInstancingSupported;
})(Platform = exports.Platform || (exports.Platform = {}));


/***/ }),

/***/ "./src/shadow/shader/gaussian-blur.frag":
/*!**********************************************!*\
  !*** ./src/shadow/shader/gaussian-blur.frag ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying vec2 v_UV1;\n\nuniform vec2 u_BlurScale;\nuniform sampler2D u_FilterSampler;\n\nvoid main() {\n  vec4 color = vec4(0.0);\n\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-3.0) * u_BlurScale.xy)) * (1.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-2.0) * u_BlurScale.xy)) * (6.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-1.0) * u_BlurScale.xy)) * (15.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+0.0) * u_BlurScale.xy)) * (20.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+1.0) * u_BlurScale.xy)) * (15.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+2.0) * u_BlurScale.xy)) * (6.0/64.0);\n  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+3.0) * u_BlurScale.xy)) * (1.0/64.0);\n\n  gl_FragColor = color;\n}"

/***/ }),

/***/ "./src/shadow/shader/gaussian-blur.vert":
/*!**********************************************!*\
  !*** ./src/shadow/shader/gaussian-blur.vert ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nattribute vec3 a_Position;\nattribute vec2 a_UV1;\n\nvarying vec2 v_UV1;\n\nvoid main() {\n  v_UV1 = a_UV1;\n  gl_Position = vec4(a_Position, 1.0);\n}"

/***/ }),

/***/ "./src/shadow/shader/shadow.frag":
/*!***************************************!*\
  !*** ./src/shadow/shader/shadow.frag ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvoid main() {\n  float depth = gl_FragCoord.z;\n  float dx = 0.0;\n  float dy = 0.0;\n\n  #ifdef GL_OES_standard_derivatives\n    dx = dFdx(depth);\n    dy = dFdy(depth);\n  #endif\n\n  float moment2 = depth * depth + 0.25 * (dx * dx + dy * dy);\n  gl_FragColor = vec4(1.0 - depth, 1.0 - moment2, 0.0, 0.0);\n}"

/***/ }),

/***/ "./src/shadow/shader/shadow.vert":
/*!***************************************!*\
  !*** ./src/shadow/shader/shadow.vert ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#define FEATURES\n\nattribute vec3 a_Position;\n\n#ifdef USE_SKINNING\nattribute vec4 a_Joint1;\nattribute vec4 a_Weight1;\n#endif\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\n\n#ifdef USE_SKINNING\n  #ifdef USE_SKINNING_TEXTURE\n    uniform sampler2D u_jointMatrixSampler;\n  #else\n    uniform mat4 u_jointMatrix[MAX_JOINT_COUNT];\n  #endif\n#endif\n\n// these offsets assume the texture is 4 pixels across\n#define ROW0_U ((0.5 + 0.0) / 4.0)\n#define ROW1_U ((0.5 + 1.0) / 4.0)\n#define ROW2_U ((0.5 + 2.0) / 4.0)\n#define ROW3_U ((0.5 + 3.0) / 4.0)\n\n#ifdef USE_SKINNING\nmat4 getJointMatrix(float boneNdx) {\n    #ifdef USE_SKINNING_TEXTURE\n    float v = (boneNdx + 0.5) / float(MAX_JOINT_COUNT);\n    return mat4(\n        texture2D(u_jointMatrixSampler, vec2(ROW0_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW1_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW2_U, v)) * 2.0 - 1.0,\n        texture2D(u_jointMatrixSampler, vec2(ROW3_U, v)) * 2.0 - 1.0\n    );\n    #else\n    return u_jointMatrix[int(boneNdx)];\n    #endif\n}\n\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n    skin +=\n        a_Weight1.x * getJointMatrix(a_Joint1.x) +\n        a_Weight1.y * getJointMatrix(a_Joint1.y) +\n        a_Weight1.z * getJointMatrix(a_Joint1.z) +\n        a_Weight1.w * getJointMatrix(a_Joint1.w);\n    return skin;\n}\n#endif\n\nvoid main() {\n  vec4 pos = vec4(a_Position, 1.0);\n  #ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n  #endif\n  gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * pos;\n}"

/***/ }),

/***/ "./src/shadow/shadow-casting-light.ts":
/*!********************************************!*\
  !*** ./src/shadow/shadow-casting-light.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowCastingLight = void 0;
var light_type_1 = __webpack_require__(/*! ../lighting/light-type */ "./src/lighting/light-type.ts");
var platform_1 = __webpack_require__(/*! ../platform */ "./src/platform.ts");
var shadow_texture_1 = __webpack_require__(/*! ./shadow-texture */ "./src/shadow/shadow-texture.ts");
var shadow_quality_1 = __webpack_require__(/*! ./shadow-quality */ "./src/shadow/shadow-quality.ts");
var shadow_math_1 = __webpack_require__(/*! ./shadow-math */ "./src/shadow/shadow-math.ts");
/**
 * Contains the required components used for rendering a shadow casted by a light.
 */
var ShadowCastingLight = /** @class */ (function () {
    /**
     * Creates a new shadow casting light used for rendering a shadow texture.
     * @param renderer The renderer to use.
     * @param light The light which is casting the shadow.
     * @param shadowTextureSize The size (width/height) in pixels for the shadow
     * texture. Increasing the size will improve the quality of the shadow.
     * @param shadowArea The area in units of the shadow when using directional
     * lights. Reducing the area will improve the quality of the shadow.
     * @param softness The softness of the edges of the shadow.
     * @param quality The quality (precision) of the shadow. If the quality is not
     * supported by current platform, a lower quality will be selected instead.
     */
    function ShadowCastingLight(renderer, light, shadowTextureSize, shadowArea, softness, quality) {
        if (softness === void 0) { softness = 0; }
        if (quality === void 0) { quality = shadow_quality_1.ShadowQuality.medium; }
        this.renderer = renderer;
        this.light = light;
        this.shadowArea = shadowArea;
        this.softness = softness;
        this._lightViewProjection = new Float32Array(16);
        /**
         * Value indicating if the shadow should follow the specified camera. If the
         * camera is not set, the main camera will be used as default. Only available
         * when using directional lights.
         */
        this.followCamera = true;
        if (light.type === light_type_1.LightType.point) {
            throw new Error("PIXI3D: Only directional and spot lights are supported as shadow casters.");
        }
        this._shadowTexture = shadow_texture_1.ShadowTexture.create(renderer, shadowTextureSize, quality);
        this._shadowTexture.baseTexture.framebuffer.addDepthTexture();
        this._filterTexture = shadow_texture_1.ShadowTexture.create(renderer, shadowTextureSize, quality);
    }
    Object.defineProperty(ShadowCastingLight.prototype, "lightViewProjection", {
        /** The light view projection matrix. */
        get: function () {
            return this._lightViewProjection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowCastingLight.prototype, "shadowTexture", {
        /**
         * The rendered shadow texture.
         */
        get: function () {
            return this._shadowTexture;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ShadowCastingLight.prototype, "filterTexture", {
        /**
         * The rendered filter texture.
         */
        get: function () {
            return this._filterTexture;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Destroys the shadow casting light and it's used resources.
     */
    ShadowCastingLight.prototype.destroy = function () {
        this._shadowTexture.destroy(true);
        this._filterTexture.destroy(true);
    };
    /**
     * Clears the rendered shadow texture.
     */
    ShadowCastingLight.prototype.clear = function () {
        this.renderer.renderTexture.bind(this._shadowTexture);
        this.renderer.renderTexture.clear([0, 0, 0, 0], this.renderer.gl.COLOR_BUFFER_BIT | this.renderer.gl.DEPTH_BUFFER_BIT);
        this.renderer.renderTexture.bind(undefined);
    };
    /**
     * Updates the light view projection matrix.
     */
    ShadowCastingLight.prototype.updateLightViewProjection = function () {
        if (this.light.type === light_type_1.LightType.directional) {
            shadow_math_1.ShadowMath.calculateDirectionalLightViewProjection(this);
        }
        else if (this.light.type === light_type_1.LightType.spot) {
            shadow_math_1.ShadowMath.calculateSpotLightViewProjection(this);
        }
    };
    /**
     * Returns a value indicating if medium quality (16-bit precision) shadows is
     * supported by current platform.
     * @param renderer The renderer to use.
     */
    ShadowCastingLight.isMediumQualitySupported = function (renderer) {
        return platform_1.Platform.isHalfFloatFramebufferSupported(renderer);
    };
    /**
     * Returns a value indicating if high quality (32-bit precision) shadows is
     * supported by current platform.
     * @param renderer The renderer to use.
     */
    ShadowCastingLight.isHighQualitySupported = function (renderer) {
        return platform_1.Platform.isFloatFramebufferSupported(renderer);
    };
    return ShadowCastingLight;
}());
exports.ShadowCastingLight = ShadowCastingLight;


/***/ }),

/***/ "./src/shadow/shadow-filter.ts":
/*!*************************************!*\
  !*** ./src/shadow/shadow-filter.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowFilter = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var mesh_shader_1 = __webpack_require__(/*! ../mesh/mesh-shader */ "./src/mesh/mesh-shader.ts");
var mesh_1 = __webpack_require__(/*! ../mesh/mesh */ "./src/mesh/mesh.ts");
var ShadowFilter = /** @class */ (function () {
    function ShadowFilter(renderer) {
        this.renderer = renderer;
        this._mesh = mesh_1.Mesh3D.createQuad();
        this._gaussianBlurShader = new mesh_shader_1.MeshShader(PIXI.Program.from(__webpack_require__(/*! ./shader/gaussian-blur.vert */ "./src/shadow/shader/gaussian-blur.vert"), __webpack_require__(/*! ./shader/gaussian-blur.frag */ "./src/shadow/shader/gaussian-blur.frag")));
    }
    ShadowFilter.prototype.applyGaussianBlur = function (light) {
        this.applyBlurScale(light.shadowTexture, light.filterTexture, new Float32Array([0, light.softness / light.shadowTexture.height]));
        this.applyBlurScale(light.filterTexture, light.shadowTexture, new Float32Array([light.softness / light.shadowTexture.width, 0]));
    };
    ShadowFilter.prototype.applyBlurScale = function (input, output, scale) {
        this.renderer.renderTexture.bind(output);
        this.renderer.renderTexture.clear();
        this._gaussianBlurShader.uniforms.u_FilterSampler = input;
        this._gaussianBlurShader.uniforms.u_BlurScale = scale;
        this._gaussianBlurShader.render(this._mesh, this.renderer);
        this.renderer.renderTexture.bind(undefined);
    };
    return ShadowFilter;
}());
exports.ShadowFilter = ShadowFilter;


/***/ }),

/***/ "./src/shadow/shadow-math.ts":
/*!***********************************!*\
  !*** ./src/shadow/shadow-math.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowMath = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var mat4_1 = __webpack_require__(/*! ../math/mat4 */ "./src/math/mat4.ts");
var light_type_1 = __webpack_require__(/*! ../lighting/light-type */ "./src/lighting/light-type.ts");
var vec3_1 = __webpack_require__(/*! ../math/vec3 */ "./src/math/vec3.ts");
var quat_1 = __webpack_require__(/*! ../math/quat */ "./src/math/quat.ts");
var camera_1 = __webpack_require__(/*! ../camera/camera */ "./src/camera/camera.ts");
var ShadowMath;
(function (ShadowMath) {
    var _lightProjection = new Float32Array(16);
    var _lightView = new Float32Array(16);
    var _up = new Float32Array([0, 1, 0]);
    var _conjugateRotation = new Float32Array(4);
    var _lightSpacePosition = new Float32Array(3);
    var _lightSpaceForward = new Float32Array(3);
    var _cameraTarget = new Float32Array(3);
    var _cameraForward = new Float32Array(3);
    function calculateDirectionalLightViewProjection(shadowCastingLight) {
        if (shadowCastingLight.light.type !== light_type_1.LightType.directional) {
            return;
        }
        var halfShadowArea = shadowCastingLight.shadowArea / 2;
        var worldTexelSize = (halfShadowArea * 2) / shadowCastingLight.shadowArea;
        var lightProjection = mat4_1.Mat4.ortho(-halfShadowArea, halfShadowArea, -halfShadowArea, halfShadowArea, -halfShadowArea, halfShadowArea, _lightProjection);
        var light = shadowCastingLight.light;
        var camera = shadowCastingLight.camera || camera_1.Camera.main;
        if (camera && shadowCastingLight.followCamera) {
            vec3_1.Vec3.scale(camera.worldTransform.forward, halfShadowArea, _cameraForward);
            vec3_1.Vec3.add(camera.worldTransform.position, _cameraForward, _cameraTarget);
            vec3_1.Vec3.transformQuat(_cameraTarget, quat_1.Quat.conjugate(shadowCastingLight.light.worldTransform.rotation, _conjugateRotation), _lightSpacePosition);
            _lightSpacePosition[0] = worldTexelSize *
                Math.floor(_lightSpacePosition[0] / worldTexelSize);
            _lightSpacePosition[1] = worldTexelSize *
                Math.floor(_lightSpacePosition[1] / worldTexelSize);
            vec3_1.Vec3.transformQuat(_lightSpacePosition, light.worldTransform.rotation, _lightSpacePosition);
            vec3_1.Vec3.add(_lightSpacePosition, light.worldTransform.forward, _lightSpaceForward);
            mat4_1.Mat4.lookAt(_lightSpacePosition, _lightSpaceForward, light.worldTransform.up, _lightView);
            mat4_1.Mat4.multiply(lightProjection, _lightView, shadowCastingLight.lightViewProjection);
        }
        else {
            vec3_1.Vec3.add(light.worldTransform.position, shadowCastingLight.light.worldTransform.forward, _cameraTarget);
            mat4_1.Mat4.lookAt(light.worldTransform.position, _cameraTarget, light.worldTransform.up, _lightView);
            mat4_1.Mat4.multiply(lightProjection, _lightView, shadowCastingLight.lightViewProjection);
        }
    }
    ShadowMath.calculateDirectionalLightViewProjection = calculateDirectionalLightViewProjection;
    function calculateSpotLightViewProjection(shadowCastingLight) {
        if (shadowCastingLight.light.type !== light_type_1.LightType.spot) {
            return;
        }
        var light = shadowCastingLight.light;
        mat4_1.Mat4.perspective(light.outerConeAngle * PIXI.DEG_TO_RAD * 2, 1, 2, light.range, _lightProjection);
        vec3_1.Vec3.add(light.worldTransform.position, light.worldTransform.forward, _cameraTarget);
        mat4_1.Mat4.lookAt(light.worldTransform.position, _cameraTarget, light.worldTransform.up, _lightView);
        mat4_1.Mat4.multiply(_lightProjection, _lightView, shadowCastingLight.lightViewProjection);
    }
    ShadowMath.calculateSpotLightViewProjection = calculateSpotLightViewProjection;
})(ShadowMath = exports.ShadowMath || (exports.ShadowMath = {}));


/***/ }),

/***/ "./src/shadow/shadow-quality.ts":
/*!**************************************!*\
  !*** ./src/shadow/shadow-quality.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowQuality = void 0;
var ShadowQuality;
(function (ShadowQuality) {
    /**
     * Low quality (8-bit) shadows.
     */
    ShadowQuality["low"] = "low";
    /**
     * Medium quality (16-bit) shadows.
     */
    ShadowQuality["medium"] = "medium";
    /**
     * High quality (32-bit) shadows.
     */
    ShadowQuality["high"] = "high";
})(ShadowQuality = exports.ShadowQuality || (exports.ShadowQuality = {}));


/***/ }),

/***/ "./src/shadow/shadow-render-pass.ts":
/*!******************************************!*\
  !*** ./src/shadow/shadow-render-pass.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowRenderPass = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var shadow_filter_1 = __webpack_require__(/*! ./shadow-filter */ "./src/shadow/shadow-filter.ts");
var shadow_renderer_1 = __webpack_require__(/*! ./shadow-renderer */ "./src/shadow/shadow-renderer.ts");
/**
 * Pass used for rendering shadows.
 */
var ShadowRenderPass = /** @class */ (function () {
    /**
     * Creates a new shadow render pass using the specified renderer.
     * @param renderer The renderer to use.
     * @param name The name for the render pass.
     */
    function ShadowRenderPass(renderer, name) {
        if (name === void 0) { name = "shadow"; }
        this.renderer = renderer;
        this.name = name;
        this._lights = [];
        this._filter = new shadow_filter_1.ShadowFilter(renderer);
        this._shadow = new shadow_renderer_1.ShadowRenderer(renderer);
    }
    /**
     * Adds a shadow casting light.
     * @param shadowCastingLight The light to add.
     */
    ShadowRenderPass.prototype.addShadowCastingLight = function (shadowCastingLight) {
        if (this._lights.indexOf(shadowCastingLight) < 0) {
            this._lights.push(shadowCastingLight);
        }
    };
    /**
     * Removes a shadow casting light.
     * @param shadowCastingLight The light to remove.
     */
    ShadowRenderPass.prototype.removeShadowCastingLight = function (shadowCastingLight) {
        var index = this._lights.indexOf(shadowCastingLight);
        if (index >= 0) {
            this._lights.splice(index, 1);
        }
    };
    ShadowRenderPass.prototype.clear = function () {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this._lights), _c = _b.next(); !_c.done; _c = _b.next()) {
                var shadowCastingLight = _c.value;
                shadowCastingLight.clear();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    ShadowRenderPass.prototype.render = function (meshes) {
        var e_2, _a, e_3, _b;
        if (meshes.length === 0 || this._lights.length === 0) {
            return;
        }
        var current = this.renderer.renderTexture.current;
        try {
            for (var _c = tslib_1.__values(this._lights), _d = _c.next(); !_d.done; _d = _c.next()) {
                var shadowCastingLight = _d.value;
                this.renderer.renderTexture.bind(shadowCastingLight.shadowTexture);
                shadowCastingLight.updateLightViewProjection();
                try {
                    for (var meshes_1 = (e_3 = void 0, tslib_1.__values(meshes)), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                        var mesh = meshes_1_1.value;
                        this._shadow.render(mesh, shadowCastingLight);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (meshes_1_1 && !meshes_1_1.done && (_b = meshes_1.return)) _b.call(meshes_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                if (shadowCastingLight.softness > 0) {
                    this._filter.applyGaussianBlur(shadowCastingLight);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.renderer.renderTexture.bind(current);
    };
    return ShadowRenderPass;
}());
exports.ShadowRenderPass = ShadowRenderPass;


/***/ }),

/***/ "./src/shadow/shadow-renderer.ts":
/*!***************************************!*\
  !*** ./src/shadow/shadow-renderer.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowRenderer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var shadow_shader_1 = __webpack_require__(/*! ./shadow-shader */ "./src/shadow/shadow-shader.ts");
var skinning_shader_1 = __webpack_require__(/*! ./skinning-shader */ "./src/shadow/skinning-shader.ts");
var texture_shader_1 = __webpack_require__(/*! ./texture-shader */ "./src/shadow/texture-shader.ts");
var ShadowRenderer = /** @class */ (function () {
    function ShadowRenderer(renderer) {
        this.renderer = renderer;
        this._state = Object.assign(new PIXI.State(), {
            depthTest: true, clockwiseFrontFace: false, culling: true, blendMode: PIXI.BLEND_MODES.NONE
        });
        this._shadowShader = new shadow_shader_1.ShadowShader(this.renderer);
    }
    ShadowRenderer.prototype.render = function (mesh, shadowCastingLight) {
        var shader = this._shadowShader;
        if (mesh.skin && mesh.geometry.joints && mesh.geometry.weights) {
            if (!this._skinningShader) {
                this._skinningShader = new skinning_shader_1.SkinningShader(this.renderer);
            }
            shader = this._skinningShader;
            if (mesh.skin.joints.length > this._skinningShader.maxSupportedJoints) {
                if (!this._textureShader) {
                    if (texture_shader_1.TextureShader.isSupported(this.renderer)) {
                        this._textureShader = new texture_shader_1.TextureShader(this.renderer);
                    }
                }
                shader = this._textureShader;
            }
        }
        if (shader) {
            shader.updateUniforms(mesh, shadowCastingLight);
            shader.render(mesh, this.renderer, this._state);
        }
    };
    return ShadowRenderer;
}());
exports.ShadowRenderer = ShadowRenderer;


/***/ }),

/***/ "./src/shadow/shadow-shader.ts":
/*!*************************************!*\
  !*** ./src/shadow/shadow-shader.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowShader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var mesh_shader_1 = __webpack_require__(/*! ../mesh/mesh-shader */ "./src/mesh/mesh-shader.ts");
var standard_shader_source_1 = __webpack_require__(/*! ../material/standard/standard-shader-source */ "./src/material/standard/standard-shader-source.ts");
var ShadowShader = /** @class */ (function (_super) {
    tslib_1.__extends(ShadowShader, _super);
    function ShadowShader(renderer, features) {
        if (features === void 0) { features = []; }
        var _this = this;
        var vert = __webpack_require__(/*! ./shader/shadow.vert */ "./src/shadow/shader/shadow.vert");
        var frag = __webpack_require__(/*! ./shader/shadow.frag */ "./src/shadow/shader/shadow.frag");
        _this = _super.call(this, PIXI.Program.from(standard_shader_source_1.StandardShaderSource.build(vert, features, renderer), standard_shader_source_1.StandardShaderSource.build(frag, features, renderer))) || this;
        return _this;
    }
    ShadowShader.prototype.createShaderGeometry = function (geometry) {
        var result = new PIXI.Geometry();
        if (geometry.indices) {
            if (geometry.indices.buffer.BYTES_PER_ELEMENT === 1) {
                // PIXI seems to have problems with Uint8Array, let's convert to UNSIGNED_SHORT.
                result.addIndex(new PIXI.Buffer(new Uint16Array(geometry.indices.buffer)));
            }
            else {
                result.addIndex(new PIXI.Buffer(geometry.indices.buffer));
            }
        }
        if (geometry.positions) {
            result.addAttribute("a_Position", new PIXI.Buffer(geometry.positions.buffer), 3, false, geometry.positions.componentType, geometry.positions.stride);
        }
        return result;
    };
    Object.defineProperty(ShadowShader.prototype, "name", {
        get: function () {
            return "shadow-shader";
        },
        enumerable: false,
        configurable: true
    });
    ShadowShader.prototype.updateUniforms = function (mesh, shadowCastingLight) {
        this.uniforms.u_ModelMatrix = mesh.worldTransform.array;
        this.uniforms.u_ViewProjectionMatrix = shadowCastingLight.lightViewProjection;
    };
    return ShadowShader;
}(mesh_shader_1.MeshShader));
exports.ShadowShader = ShadowShader;


/***/ }),

/***/ "./src/shadow/shadow-texture.ts":
/*!**************************************!*\
  !*** ./src/shadow/shadow-texture.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowTexture = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var shadow_quality_1 = __webpack_require__(/*! ./shadow-quality */ "./src/shadow/shadow-quality.ts");
var platform_1 = __webpack_require__(/*! ../platform */ "./src/platform.ts");
var ShadowTexture;
(function (ShadowTexture) {
    function create(renderer, size, quality) {
        var type = getSupportedType(renderer, quality);
        return PIXI.RenderTexture.create({
            width: size, height: size, type: type, scaleMode: getSupportedScaleMode(renderer)
        });
    }
    ShadowTexture.create = create;
    function getSupportedScaleMode(renderer) {
        if (platform_1.Platform.supportsFloatLinear(renderer)) {
            return PIXI.SCALE_MODES.LINEAR;
        }
        return PIXI.SCALE_MODES.NEAREST;
    }
    function getSupportedType(renderer, quality) {
        if (quality === shadow_quality_1.ShadowQuality.high) {
            if (platform_1.Platform.isFloatFramebufferSupported(renderer)) {
                return PIXI.TYPES.FLOAT;
            }
            if (platform_1.Platform.isHalfFloatFramebufferSupported(renderer)) {
                return PIXI.TYPES.HALF_FLOAT;
            }
        }
        if (quality === shadow_quality_1.ShadowQuality.medium && platform_1.Platform.isHalfFloatFramebufferSupported(renderer)) {
            return PIXI.TYPES.HALF_FLOAT;
        }
        return PIXI.TYPES.UNSIGNED_BYTE;
    }
})(ShadowTexture = exports.ShadowTexture || (exports.ShadowTexture = {}));


/***/ }),

/***/ "./src/shadow/skinning-shader.ts":
/*!***************************************!*\
  !*** ./src/shadow/skinning-shader.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SkinningShader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var platform_1 = __webpack_require__(/*! ../platform */ "./src/platform.ts");
var shadow_shader_1 = __webpack_require__(/*! ./shadow-shader */ "./src/shadow/shadow-shader.ts");
var SkinningShader = /** @class */ (function (_super) {
    tslib_1.__extends(SkinningShader, _super);
    function SkinningShader(renderer) {
        var _this = this;
        var uniformsRequiredForOtherFeatures = 8;
        var availableVertexUniforms = platform_1.Platform.getMaxVertexUniformVectors(renderer) - uniformsRequiredForOtherFeatures;
        var uniformsRequiredPerJoint = 4;
        var maxJointCount = Math.floor(availableVertexUniforms / uniformsRequiredPerJoint);
        _this = _super.call(this, renderer, ["USE_SKINNING 1", "MAX_JOINT_COUNT " + maxJointCount]) || this;
        _this._maxSupportedJoints = maxJointCount;
        return _this;
    }
    Object.defineProperty(SkinningShader.prototype, "maxSupportedJoints", {
        get: function () {
            return this._maxSupportedJoints;
        },
        enumerable: false,
        configurable: true
    });
    SkinningShader.prototype.createShaderGeometry = function (geometry) {
        var result = _super.prototype.createShaderGeometry.call(this, geometry);
        if (geometry.joints) {
            result.addAttribute("a_Joint1", new PIXI.Buffer(geometry.joints.buffer), 4, false, geometry.joints.componentType, geometry.joints.stride);
        }
        if (geometry.weights) {
            result.addAttribute("a_Weight1", new PIXI.Buffer(geometry.weights.buffer), 4, false, geometry.weights.componentType, geometry.weights.stride);
        }
        return result;
    };
    Object.defineProperty(SkinningShader.prototype, "name", {
        get: function () {
            return "skinned-shadow-shader";
        },
        enumerable: false,
        configurable: true
    });
    SkinningShader.prototype.updateUniforms = function (mesh, shadowCastingLight) {
        _super.prototype.updateUniforms.call(this, mesh, shadowCastingLight);
        if (!mesh.skin) {
            return;
        }
        var jointVertexMatrices = mesh.skin.calculateJointMatrices().jointVertexMatrices;
        this.uniforms.u_jointMatrix = jointVertexMatrices;
    };
    return SkinningShader;
}(shadow_shader_1.ShadowShader));
exports.SkinningShader = SkinningShader;


/***/ }),

/***/ "./src/shadow/texture-shader.ts":
/*!**************************************!*\
  !*** ./src/shadow/texture-shader.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TextureShader = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var shadow_shader_1 = __webpack_require__(/*! ./shadow-shader */ "./src/shadow/shadow-shader.ts");
var standard_material_matrix_texture_1 = __webpack_require__(/*! ../material/standard/standard-material-matrix-texture */ "./src/material/standard/standard-material-matrix-texture.ts");
var MAX_SUPPORTED_JOINTS = 256;
var TextureShader = /** @class */ (function (_super) {
    tslib_1.__extends(TextureShader, _super);
    function TextureShader(renderer) {
        var _this = _super.call(this, renderer, [
            "USE_SKINNING 1", "USE_SKINNING_TEXTURE 1", "MAX_JOINT_COUNT " + MAX_SUPPORTED_JOINTS
        ]) || this;
        _this._jointMatrixTexture =
            new standard_material_matrix_texture_1.StandardMaterialMatrixTexture(MAX_SUPPORTED_JOINTS);
        return _this;
    }
    Object.defineProperty(TextureShader.prototype, "maxSupportedJoints", {
        get: function () {
            return MAX_SUPPORTED_JOINTS;
        },
        enumerable: false,
        configurable: true
    });
    TextureShader.isSupported = function (renderer) {
        return standard_material_matrix_texture_1.StandardMaterialMatrixTexture.isSupported(renderer);
    };
    TextureShader.prototype.createShaderGeometry = function (geometry) {
        var result = _super.prototype.createShaderGeometry.call(this, geometry);
        if (geometry.joints) {
            result.addAttribute("a_Joint1", new PIXI.Buffer(geometry.joints.buffer), 4, false, geometry.joints.componentType, geometry.joints.stride);
        }
        if (geometry.weights) {
            result.addAttribute("a_Weight1", new PIXI.Buffer(geometry.weights.buffer), 4, false, geometry.weights.componentType, geometry.weights.stride);
        }
        return result;
    };
    Object.defineProperty(TextureShader.prototype, "name", {
        get: function () {
            return "skinned-shadow-shader";
        },
        enumerable: false,
        configurable: true
    });
    TextureShader.prototype.updateUniforms = function (mesh, shadowCastingLight) {
        _super.prototype.updateUniforms.call(this, mesh, shadowCastingLight);
        if (!mesh.skin) {
            return;
        }
        var jointVertexMatrices = mesh.skin.calculateJointMatrices().jointVertexMatrices;
        this._jointMatrixTexture.updateBuffer(jointVertexMatrices);
        this.uniforms.u_jointMatrixSampler = this._jointMatrixTexture;
    };
    return TextureShader;
}(shadow_shader_1.ShadowShader));
exports.TextureShader = TextureShader;


/***/ }),

/***/ "./src/skinning/joint.ts":
/*!*******************************!*\
  !*** ./src/skinning/joint.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Joint = void 0;
/**
 * Represents a joint used for vertex skinning.
 */
var Joint = /** @class */ (function () {
    /**
     * Creates a new joint.
     * @param node The node container using this skin.
     * @param inverseBindMatrix The inverse of the global transform matrix.
     */
    function Joint(node, inverseBindMatrix) {
        this.node = node;
        this.inverseBindMatrix = inverseBindMatrix;
    }
    return Joint;
}());
exports.Joint = Joint;


/***/ }),

/***/ "./src/skinning/skin.ts":
/*!******************************!*\
  !*** ./src/skinning/skin.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Skin = void 0;
var mat4_1 = __webpack_require__(/*! ../math/mat4 */ "./src/math/mat4.ts");
/**
 * Represents a skin used for vertex skinning.
 */
var Skin = /** @class */ (function () {
    /**
     * Creates a new skin.
     * @param parent The parent container node for the skin.
     * @param joints The array of joints included in the skin.
     */
    function Skin(parent, joints) {
        this.parent = parent;
        this.joints = joints;
        this._arrayVertexMatrices = [];
        this._arrayNormalMatrices = [];
        this._jointVertexMatrices = new Float32Array(joints.length * 16);
        this._jointNormalMatrices = new Float32Array(joints.length * 16);
        for (var i = 0; i < joints.length; i++) {
            this._arrayVertexMatrices.push(new Float32Array(this._jointVertexMatrices.buffer, 16 * 4 * i, 16));
            this._arrayNormalMatrices.push(new Float32Array(this._jointNormalMatrices.buffer, 16 * 4 * i, 16));
        }
    }
    /**
     * Calculates the joint matrices.
     */
    Skin.prototype.calculateJointMatrices = function () {
        for (var i = 0; i < this.joints.length; i++) {
            /* The vertices have to be transformed with the current global transform
            of the joint node. Together with the transformation from the
            inverseBindMatrix, this will cause the vertices to be transformed only
            based on the current transform of the node, in the coordinate space of the
            current joint node. */
            mat4_1.Mat4.multiply(this.joints[i].node.worldTransform.array, this.joints[i].inverseBindMatrix, this._arrayVertexMatrices[i]);
            /* The vertices have to be transformed with inverse of the global
            transform of the node that the mesh is attached to, because this transform
            is already done using the model-view-matrix, and thus has to be cancelled
            out from the skinning computation. */
            mat4_1.Mat4.multiply(this.parent.transform.inverseWorldTransform.array, this._arrayVertexMatrices[i], this._arrayVertexMatrices[i]);
            mat4_1.Mat4.invert(this._arrayVertexMatrices[i], this._arrayNormalMatrices[i]);
            mat4_1.Mat4.transpose(this._arrayNormalMatrices[i], this._arrayNormalMatrices[i]);
        }
        return {
            jointVertexMatrices: this._jointVertexMatrices,
            jointNormalMatrices: this._jointNormalMatrices
        };
    };
    return Skin;
}());
exports.Skin = Skin;


/***/ }),

/***/ "./src/skybox/shader/skybox.frag":
/*!***************************************!*\
  !*** ./src/skybox/shader/skybox.frag ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_Position;\n\nuniform samplerCube u_EnvironmentSampler;\n\nvoid main() {\n  gl_FragColor = vec4(textureCube(u_EnvironmentSampler, v_Position).rgb, 1.0);\n}"

/***/ }),

/***/ "./src/skybox/shader/skybox.vert":
/*!***************************************!*\
  !*** ./src/skybox/shader/skybox.vert ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "attribute vec3 a_Position;\n\nvarying vec3 v_Position;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\nvoid main() {\n  v_Position = a_Position.xyz;\n\n  // Converting the view to 3x3 matrix and then back to 4x4 matrix \n  // removes the translation. We do this because we want the skybox to \n  // be centered around the camera.\n  gl_Position = u_Projection * mat4(mat3(u_View)) * u_ModelMatrix * vec4(a_Position, 1.0);\n}"

/***/ }),

/***/ "./src/skybox/skybox-material.ts":
/*!***************************************!*\
  !*** ./src/skybox/skybox-material.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SkyboxMaterial = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var mesh_shader_1 = __webpack_require__(/*! ../mesh/mesh-shader */ "./src/mesh/mesh-shader.ts");
var camera_1 = __webpack_require__(/*! ../camera/camera */ "./src/camera/camera.ts");
var material_1 = __webpack_require__(/*! ../material/material */ "./src/material/material.ts");
var SkyboxMaterial = /** @class */ (function (_super) {
    tslib_1.__extends(SkyboxMaterial, _super);
    function SkyboxMaterial(cubemap) {
        var _this = _super.call(this) || this;
        _this._cubemap = cubemap;
        _this.state = Object.assign(new PIXI.State(), {
            culling: true, clockwiseFrontFace: true, depthTest: true
        });
        return _this;
    }
    Object.defineProperty(SkyboxMaterial.prototype, "cubemap", {
        get: function () {
            return this._cubemap;
        },
        set: function (value) {
            if (value !== this._cubemap) {
                if (!this._cubemap.valid) {
                    // Remove the shader so it can be rebuilt with the current features. 
                    // It may happen that we set a texture which is not yet valid, in that 
                    // case we don't want to render the skybox until it has become valid.
                    this._shader = undefined;
                }
                this._cubemap = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    SkyboxMaterial.prototype.updateUniforms = function (mesh, shader) {
        var camera = this.camera || camera_1.Camera.main;
        shader.uniforms.u_ModelMatrix = mesh.worldTransform.array;
        shader.uniforms.u_View = camera.view;
        shader.uniforms.u_Projection = camera.projection;
        shader.uniforms.u_EnvironmentSampler = this.cubemap;
    };
    SkyboxMaterial.prototype.render = function (mesh, renderer) {
        // Disable writing to the depth buffer. This is because we want all other 
        // objects to be in-front of the skybox.
        renderer.gl.depthMask(false);
        _super.prototype.render.call(this, mesh, renderer);
        renderer.gl.depthMask(true);
    };
    SkyboxMaterial.prototype.createShader = function () {
        var vert = __webpack_require__(/*! ./shader/skybox.vert */ "./src/skybox/shader/skybox.vert");
        var frag = __webpack_require__(/*! ./shader/skybox.frag */ "./src/skybox/shader/skybox.frag");
        if (this.cubemap.valid) {
            return new mesh_shader_1.MeshShader(PIXI.Program.from(vert, frag));
        }
    };
    return SkyboxMaterial;
}(material_1.Material));
exports.SkyboxMaterial = SkyboxMaterial;


/***/ }),

/***/ "./src/skybox/skybox.ts":
/*!******************************!*\
  !*** ./src/skybox/skybox.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Skybox = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var skybox_material_1 = __webpack_require__(/*! ./skybox-material */ "./src/skybox/skybox-material.ts");
var mesh_1 = __webpack_require__(/*! ../mesh/mesh */ "./src/mesh/mesh.ts");
var container_1 = __webpack_require__(/*! ../container */ "./src/container.ts");
var cubemap_1 = __webpack_require__(/*! ../cubemap/cubemap */ "./src/cubemap/cubemap.ts");
/**
 * A skybox is a method of creating backgrounds in a 3D scene. It consists of
 * a cubemap texture which has six sides. Note that the skybox should be rendered
 * before all other objects in the scene.
 */
var Skybox = /** @class */ (function (_super) {
    tslib_1.__extends(Skybox, _super);
    /**
     * Creates a new skybox using the specified cubemap.
     * @param cubemap Cubemap to use for rendering.
     */
    function Skybox(cubemap) {
        var _this = _super.call(this) || this;
        _this._mesh = _this.addChild(mesh_1.Mesh3D.createCube(new skybox_material_1.SkyboxMaterial(cubemap)));
        return _this;
    }
    Object.defineProperty(Skybox.prototype, "camera", {
        /**
         * Camera used when rendering. If this value is not set, the main camera will
         * be used by default.
         */
        get: function () {
            return this._mesh.material.camera;
        },
        set: function (value) {
            this._mesh.material.camera = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "cubemap", {
        /**
         * The cubemap texture used when rendering.
         */
        get: function () {
            return this._mesh.material.cubemap;
        },
        set: function (value) {
            this._mesh.material.cubemap = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Creates a new skybox from the specified source.
     * @param source The source to create the skybox from.
     */
    Skybox.from = function (source) {
        return new Skybox(cubemap_1.Cubemap.fromFaces(source));
    };
    return Skybox;
}(container_1.Container3D));
exports.Skybox = Skybox;


/***/ }),

/***/ "./src/sprite/post-processing-sprite.ts":
/*!**********************************************!*\
  !*** ./src/sprite/post-processing-sprite.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PostProcessingSprite = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
/**
 * Represents a sprite which has post processing effects. Can be used for
 * rendering 3D objects as 2D sprites.
 */
var PostProcessingSprite = /** @class */ (function (_super) {
    tslib_1.__extends(PostProcessingSprite, _super);
    /**
     * Creates a new post processing sprite using the specified options.
     * @param renderer The renderer to use.
     * @param options The options for the render texture. If both width and height
     * has not been set, it will automatically be resized to the renderer size.
     */
    function PostProcessingSprite(renderer, options) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        var _a = options || {}, _b = _a.width, width = _b === void 0 ? 512 : _b, _c = _a.height, height = _c === void 0 ? 512 : _c, objectToRender = _a.objectToRender;
        _this._renderTexture = PIXI.RenderTexture.create({ width: width, height: height });
        /* When rendering to a texture, it's flipped vertically for some reason.
        This will flip it back to it's expected orientation. */
        _this._renderTexture.rotate = 8;
        _this._renderTexture.baseTexture.framebuffer.addDepthTexture();
        _this._texture = _this._renderTexture;
        if (!options || !options.width || !options.height) {
            renderer.on("prerender", function () {
                _this._renderTexture.resize(renderer.screen.width, renderer.screen.height);
            });
        }
        if (objectToRender) {
            PIXI.Ticker.shared.add(function () {
                if (_this.worldVisible && _this.worldAlpha > 0 && _this.renderable) {
                    objectToRender && _this.renderObject(objectToRender);
                }
            });
        }
        return _this;
    }
    Object.defineProperty(PostProcessingSprite.prototype, "renderTexture", {
        /** The render texture. */
        get: function () {
            return this._renderTexture;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PostProcessingSprite.prototype, "depthTexture", {
        /** The depth texture. */
        get: function () {
            if (this._renderTexture) {
                return this._renderTexture.baseTexture.framebuffer.depthTexture;
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Updates the sprite's texture by rendering the specified object to it.
     * @param object The object to render.
     */
    PostProcessingSprite.prototype.renderObject = function (object) {
        this.renderer.render(object, this._renderTexture);
    };
    return PostProcessingSprite;
}(PIXI.Sprite));
exports.PostProcessingSprite = PostProcessingSprite;


/***/ }),

/***/ "./src/sprite/projection-sprite.ts":
/*!*****************************************!*\
  !*** ./src/sprite/projection-sprite.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectionSprite = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var ProjectionSprite = /** @class */ (function (_super) {
    tslib_1.__extends(ProjectionSprite, _super);
    function ProjectionSprite(texture) {
        var _this = _super.call(this, texture) || this;
        _this._pixelsPerUnit = 100;
        _this.modelViewProjection = new Float32Array(16);
        _this.pluginName = "sprite3d";
        return _this;
    }
    Object.defineProperty(ProjectionSprite.prototype, "pixelsPerUnit", {
        get: function () {
            return this._pixelsPerUnit;
        },
        set: function (value) {
            if (value !== this._pixelsPerUnit) {
                // @ts-ignore
                this._transformID = -1;
                this._pixelsPerUnit = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    ProjectionSprite.prototype.calculateVertices = function () {
        var texture = this._texture;
        // @ts-ignore
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
            return;
        }
        if (this._textureID !== texture._updateID) {
            this.uvs = this._texture._uvs.uvsFloat32;
        }
        // @ts-ignore
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        var wt = this.transform.worldTransform;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w1 = texture.trim ? texture.trim.x - (anchor._x * orig.width) : -anchor._x * orig.width;
        var w0 = texture.trim ? w1 + texture.trim.width : w1 + orig.width;
        var h1 = texture.trim ? texture.trim.y - (anchor._y * orig.height) : -anchor._y * orig.height;
        var h0 = texture.trim ? h1 + texture.trim.height : h1 + orig.height;
        this.vertexData[0] = ((wt.a * w1) + (wt.c * -h1)) / this._pixelsPerUnit;
        this.vertexData[1] = ((wt.d * -h1) + (wt.b * w1)) / this._pixelsPerUnit;
        this.vertexData[2] = ((wt.a * w0) + (wt.c * -h1)) / this._pixelsPerUnit;
        this.vertexData[3] = ((wt.d * -h1) + (wt.b * w0)) / this._pixelsPerUnit;
        this.vertexData[4] = ((wt.a * w0) + (wt.c * -h0)) / this._pixelsPerUnit;
        this.vertexData[5] = ((wt.d * -h0) + (wt.b * w0)) / this._pixelsPerUnit;
        this.vertexData[6] = ((wt.a * w1) + (wt.c * -h0)) / this._pixelsPerUnit;
        this.vertexData[7] = ((wt.d * -h0) + (wt.b * w1)) / this._pixelsPerUnit;
        if (this.roundPixels) {
            var resolution = PIXI.settings.RESOLUTION;
            for (var i = 0; i < this.vertexData.length; ++i) {
                this.vertexData[i] = Math.round((this.vertexData[i] * resolution | 0) / resolution);
            }
        }
    };
    return ProjectionSprite;
}(PIXI.Sprite));
exports.ProjectionSprite = ProjectionSprite;


/***/ }),

/***/ "./src/sprite/shader/sprite.frag":
/*!***************************************!*\
  !*** ./src/sprite/shader/sprite.frag ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = vColor * vec4(color.rgb, color.a);\n}"

/***/ }),

/***/ "./src/sprite/shader/sprite.vert":
/*!***************************************!*\
  !*** ./src/sprite/shader/sprite.vert ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nattribute vec2 aVertexPosition;\n\nattribute vec4 aMatrix0;\nattribute vec4 aMatrix1;\nattribute vec4 aMatrix2;\nattribute vec4 aMatrix3;\n\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void) {\n  mat4 modelMatrix = mat4(aMatrix0, aMatrix1, aMatrix2, aMatrix3);\n\n  gl_Position = modelMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);\n\n  vTextureCoord = vec2(aTextureCoord.x, aTextureCoord.y);\n  vTextureId = aTextureId;\n  vColor = aColor * tint;\n}"

/***/ }),

/***/ "./src/sprite/sprite-batch-geometry.ts":
/*!*********************************************!*\
  !*** ./src/sprite/sprite-batch-geometry.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SpriteBatchGeometry = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var SpriteBatchGeometry = /** @class */ (function (_super) {
    tslib_1.__extends(SpriteBatchGeometry, _super);
    function SpriteBatchGeometry() {
        var _this = _super.call(this) || this;
        _this.addAttribute("aMatrix0", _this._buffer, 4, false, PIXI.TYPES.FLOAT);
        _this.addAttribute("aMatrix1", _this._buffer, 4, false, PIXI.TYPES.FLOAT);
        _this.addAttribute("aMatrix2", _this._buffer, 4, false, PIXI.TYPES.FLOAT);
        _this.addAttribute("aMatrix3", _this._buffer, 4, false, PIXI.TYPES.FLOAT);
        return _this;
    }
    return SpriteBatchGeometry;
}(PIXI.BatchGeometry));
exports.SpriteBatchGeometry = SpriteBatchGeometry;


/***/ }),

/***/ "./src/sprite/sprite-batch-renderer.ts":
/*!*********************************************!*\
  !*** ./src/sprite/sprite-batch-renderer.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SpriteBatchRenderer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var sprite_batch_geometry_1 = __webpack_require__(/*! ./sprite-batch-geometry */ "./src/sprite/sprite-batch-geometry.ts");
var SpriteBatchRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(SpriteBatchRenderer, _super);
    function SpriteBatchRenderer(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = new PIXI.BatchShaderGenerator(__webpack_require__(/*! ./shader/sprite.vert */ "./src/sprite/shader/sprite.vert"), __webpack_require__(/*! ./shader/sprite.frag */ "./src/sprite/shader/sprite.frag"));
        _this.geometryClass = sprite_batch_geometry_1.SpriteBatchGeometry;
        // The vertex size when rendering 2D sprites is 6. Here, 16 is being added 
        // to hold the model matrix.
        _this.vertexSize = 6 + 16;
        Object.assign(_this.state, {
            culling: false, clockwiseFrontFace: false, depthTest: true
        });
        return _this;
    }
    SpriteBatchRenderer.prototype.packInterleavedGeometry = function (element, attributeBuffer, indexBuffer, aIndex, iIndex) {
        var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
        var packedVertices = aIndex / this.vertexSize;
        var uvs = element.uvs;
        var indicies = element.indices;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._batchLocation;
        var alpha = Math.min(element.worldAlpha, 1.0);
        var argb = (alpha < 1.0
            && element._texture.baseTexture.alphaMode)
            ? PIXI.utils.premultiplyTint(element._tintRGB, alpha)
            : element._tintRGB + (alpha * 255 << 24);
        for (var i = 0; i < vertexData.length; i += 2) {
            float32View[aIndex++] = vertexData[i];
            float32View[aIndex++] = vertexData[i + 1];
            float32View[aIndex++] = uvs[i];
            float32View[aIndex++] = uvs[i + 1];
            uint32View[aIndex++] = argb;
            float32View[aIndex++] = textureId;
            for (var j = 0; j < 16; j++) {
                // @ts-ignore
                float32View[aIndex++] = element.modelViewProjection[j];
            }
        }
        for (var i = 0; i < indicies.length; i++) {
            indexBuffer[iIndex++] = packedVertices + indicies[i];
        }
    };
    return SpriteBatchRenderer;
}(PIXI.AbstractBatchRenderer));
exports.SpriteBatchRenderer = SpriteBatchRenderer;
PIXI.Renderer.registerPlugin("sprite3d", SpriteBatchRenderer);


/***/ }),

/***/ "./src/sprite/sprite-billboard-type.ts":
/*!*********************************************!*\
  !*** ./src/sprite/sprite-billboard-type.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SpriteBillboardType = void 0;
/**
 * Represents different billboard types.
 */
var SpriteBillboardType;
(function (SpriteBillboardType) {
    /**
     * Sprite will be rotated towards the viewer on both the x-plane and y-plane.
     */
    SpriteBillboardType["Spherical"] = "spherical";
    /**
     * Sprite will be rotated towards the viewer on the y-plane.
     */
    SpriteBillboardType["Cylindrical"] = "cylindrical";
})(SpriteBillboardType = exports.SpriteBillboardType || (exports.SpriteBillboardType = {}));


/***/ }),

/***/ "./src/sprite/sprite.ts":
/*!******************************!*\
  !*** ./src/sprite/sprite.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Sprite3D = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var camera_1 = __webpack_require__(/*! ../camera/camera */ "./src/camera/camera.ts");
var sprite_billboard_type_1 = __webpack_require__(/*! ./sprite-billboard-type */ "./src/sprite/sprite-billboard-type.ts");
var container_1 = __webpack_require__(/*! ../container */ "./src/container.ts");
var mat4_1 = __webpack_require__(/*! ../math/mat4 */ "./src/math/mat4.ts");
var projection_sprite_1 = __webpack_require__(/*! ./projection-sprite */ "./src/sprite/projection-sprite.ts");
/**
 * Represents a sprite in 3D space.
 */
var Sprite3D = /** @class */ (function (_super) {
    tslib_1.__extends(Sprite3D, _super);
    /**
     * Creates a new sprite using the specified texture.
     * @param texture The texture to use.
     */
    function Sprite3D(texture) {
        var _this = _super.call(this) || this;
        _this._modelView = new Float32Array(16);
        _this._sprite = new projection_sprite_1.ProjectionSprite(texture);
        _this._sprite.anchor.set(0.5);
        return _this;
    }
    Object.defineProperty(Sprite3D.prototype, "billboardType", {
        /**
         * The billboard type to use when rendering the sprite. Used for making the
         * sprite always face the viewer.
         */
        get: function () {
            return this._billboardType;
        },
        set: function (value) {
            if (value !== this._billboardType) {
                this._billboardType = value;
                this._cameraTransformId = undefined;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite3D.prototype, "pixelsPerUnit", {
        /** Defines the size of the sprite relative to a unit in world space. */
        get: function () {
            return this._sprite.pixelsPerUnit;
        },
        set: function (value) {
            this._sprite.pixelsPerUnit = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite3D.prototype, "tint", {
        /**
         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF
         * will remove any tint effect.
         */
        get: function () {
            return this._sprite.tint;
        },
        set: function (value) {
            this._sprite.tint = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Destroys this sprite and optionally its texture and children.
     */
    Sprite3D.prototype.destroy = function (options) {
        _super.prototype.destroy.call(this, options);
        this._sprite.destroy(options);
    };
    /**
     * Renders the sprite.
     * @param renderer The renderer to use.
     */
    Sprite3D.prototype._render = function (renderer) {
        var camera = this.camera || camera_1.Camera.main;
        var update = camera.transformId !== this._cameraTransformId ||
            this._parentID !== this.transform._worldID;
        if (update) {
            var scaling = this.worldTransform.scaling;
            mat4_1.Mat4.multiply(camera.view, this.worldTransform.array, this._modelView);
            switch (this._billboardType) {
                case sprite_billboard_type_1.SpriteBillboardType.Spherical: {
                    this._modelView[0] = scaling[0];
                    this._modelView[1] = 0;
                    this._modelView[2] = 0;
                    this._modelView[3] = 0;
                    this._modelView[4] = 0;
                    this._modelView[5] = scaling[1];
                    this._modelView[6] = 0;
                    this._modelView[7] = 0;
                    break;
                }
                case sprite_billboard_type_1.SpriteBillboardType.Cylindrical: {
                    this._modelView[0] = scaling[0];
                    this._modelView[1] = 0;
                    this._modelView[2] = 0;
                    this._modelView[3] = 0;
                    this._modelView[8] = 0;
                    this._modelView[9] = 0;
                    this._modelView[10] = 1;
                    this._modelView[11] = 0;
                    break;
                }
            }
            mat4_1.Mat4.multiply(camera.projection, this._modelView, this._sprite.modelViewProjection);
            this._parentID = this.transform._worldID;
            this._cameraTransformId = camera.transformId;
        }
        this._sprite.worldAlpha = this.worldAlpha;
        this._sprite.render(renderer);
    };
    Object.defineProperty(Sprite3D.prototype, "anchor", {
        /**
         * The anchor sets the origin point of the sprite.
         */
        get: function () {
            return this._sprite.anchor;
        },
        set: function (value) {
            this._sprite.anchor = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite3D.prototype, "texture", {
        /** The texture used when rendering the sprite. */
        get: function () {
            return this._sprite.texture;
        },
        set: function (value) {
            this._sprite.texture = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite3D.prototype, "blendMode", {
        /** The blend used when rendering the sprite. */
        get: function () {
            return this._sprite.blendMode;
        },
        set: function (value) {
            this._sprite.blendMode = value;
        },
        enumerable: false,
        configurable: true
    });
    return Sprite3D;
}(container_1.Container3D));
exports.Sprite3D = Sprite3D;


/***/ }),

/***/ "./src/texture/textureTransform.ts":
/*!*****************************************!*\
  !*** ./src/texture/textureTransform.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TextureTransform = void 0;
var mat3_1 = __webpack_require__(/*! ../math/mat3 */ "./src/math/mat3.ts");
var TextureTransform = /** @class */ (function () {
    function TextureTransform() {
    }
    /**
     * Calculates uv transform matrix based on "offset", "rotation" and "scale"
     * parameters from extension data (if any), and attaches it to texture
     * @param KHR_texture_transform extension data from gltf file
     * @param texture Texture to attach generated matrix to
     */
    TextureTransform.calculateUVTransform = function (uvTransform, texture) {
        TextureTransform._uvTransMat.set([1, 0, 0, 0, 1, 0, 0, 0, 1], 0);
        TextureTransform._uvRotMat.set([1, 0, 0, 0, 1, 0, 0, 0, 1], 0);
        TextureTransform._uvScaleMat.set([1, 0, 0, 0, 1, 0, 0, 0, 1], 0);
        if (uvTransform.rotation !== undefined) {
            var s = Math.sin(uvTransform.rotation);
            var c = Math.cos(uvTransform.rotation);
            TextureTransform._uvRotMat.set([c, s, 0, -s, c, 0, 0, 0, 1], 0);
        }
        if (uvTransform.scale !== undefined) {
            TextureTransform._uvScaleMat.set([uvTransform.scale[0], 0, 0, 0, uvTransform.scale[1], 0, 0, 0, 1], 0);
        }
        if (uvTransform.offset !== undefined) {
            TextureTransform._uvTransMat.set([1, 0, uvTransform.offset[0], 0, 1, uvTransform.offset[1], 0, 0, 1], 0);
        }
        var uvMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        mat3_1.Mat3.multiply(TextureTransform._uvRotMat, TextureTransform._uvScaleMat, uvMatrix);
        mat3_1.Mat3.multiply(uvMatrix, TextureTransform._uvTransMat, uvMatrix);
        texture.uvTransform = uvMatrix;
    };
    TextureTransform._uvTransMat = new Float32Array(9);
    TextureTransform._uvRotMat = new Float32Array(9);
    TextureTransform._uvScaleMat = new Float32Array(9);
    return TextureTransform;
}());
exports.TextureTransform = TextureTransform;


/***/ }),

/***/ "./src/transform/matrix-component.ts":
/*!*******************************************!*\
  !*** ./src/transform/matrix-component.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MatrixComponent = void 0;
var MatrixComponent = /** @class */ (function () {
    function MatrixComponent(_parent, size, _update) {
        this._parent = _parent;
        this._update = _update;
        this._array = new Float32Array(size);
    }
    Object.defineProperty(MatrixComponent.prototype, "array", {
        get: function () {
            if (this._id !== this._parent.transformId) {
                this._update(this._array);
                this._id = this._parent.transformId;
            }
            return this._array;
        },
        enumerable: false,
        configurable: true
    });
    return MatrixComponent;
}());
exports.MatrixComponent = MatrixComponent;


/***/ }),

/***/ "./src/transform/observable-point.ts":
/*!*******************************************!*\
  !*** ./src/transform/observable-point.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservablePoint3D = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
/**
 * Represents a point in 3D space.
 */
var ObservablePoint3D = /** @class */ (function (_super) {
    tslib_1.__extends(ObservablePoint3D, _super);
    /**
     * Creates a new observable point.
     * @param cb The callback when changed.
     * @param scope The owner of callback.
     * @param x The position on the x axis.
     * @param y The position on the y axis.
     * @param z The position on the z axis.
     */
    function ObservablePoint3D(cb, scope, x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        var _this = _super.call(this, cb, scope) || this;
        _this._array = new Float32Array(3);
        _this._array.set([x, y, z]);
        return _this;
    }
    Object.defineProperty(ObservablePoint3D.prototype, "array", {
        /** Array containing the x, y, z values. */
        get: function () {
            return this._array;
        },
        set: function (value) {
            this.setFrom(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservablePoint3D.prototype, "x", {
        /**
         * Position on the x axis relative to the local coordinates of the parent.
         */
        get: function () {
            return this._array[0];
        },
        set: function (value) {
            if (this._array[0] !== value) {
                this._array[0] = value;
                this.cb.call(this.scope);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservablePoint3D.prototype, "y", {
        /**
         * Position on the y axis relative to the local coordinates of the parent.
         */
        get: function () {
            return this._array[1];
        },
        set: function (value) {
            if (this._array[1] !== value) {
                this._array[1] = value;
                this.cb.call(this.scope);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservablePoint3D.prototype, "z", {
        /**
         * Position on the z axis relative to the local coordinates of the parent.
         */
        get: function () {
            return this._array[2];
        },
        set: function (value) {
            if (this._array[2] !== value) {
                this._array[2] = value;
                this.cb.call(this.scope);
            }
        },
        enumerable: false,
        configurable: true
    });
    ObservablePoint3D.prototype.clone = function (cb, scope) {
        if (cb === void 0) { cb = this.cb; }
        if (scope === void 0) { scope = this.scope; }
        return new ObservablePoint3D(cb, scope, this.x, this.y, this.z);
    };
    ObservablePoint3D.prototype.copyFrom = function (p) {
        if (this._array[0] !== p.x || this._array[1] !== p.y || this._array[2] !== p.z) {
            this._array[0] = p.x;
            this._array[1] = p.y;
            this._array[2] = p.z;
            this.cb.call(this.scope);
        }
        return this;
    };
    ObservablePoint3D.prototype.copyTo = function (p) {
        if (p instanceof ObservablePoint3D) {
            p.set(this.x, this.y, this.z);
        }
        return p;
    };
    ObservablePoint3D.prototype.equals = function (p) {
        return p.x === this.x && p.y === this.y && p.z === this.z;
    };
    /**
     * Sets the point to a new x, y and z position.
     * @param x The position on the x axis.
     * @param y The position on the y axis.
     * @param z The position on the z axis.
     */
    ObservablePoint3D.prototype.set = function (x, y, z) {
        if (y === void 0) { y = x; }
        if (z === void 0) { z = x; }
        if (this._array[0] !== x || this._array[1] !== y || this._array[2] !== z) {
            this._array[0] = x;
            this._array[1] = y;
            this._array[2] = z;
            this.cb.call(this.scope);
        }
        return this;
    };
    /**
     * Sets the point to a new x, y and z position.
     * @param array The array containing x, y and z, expected length is 3.
     */
    ObservablePoint3D.prototype.setFrom = function (array) {
        this.set(array[0], array[1], array[2]);
        return this;
    };
    return ObservablePoint3D;
}(PIXI.ObservablePoint));
exports.ObservablePoint3D = ObservablePoint3D;


/***/ }),

/***/ "./src/transform/observable-quaternion.ts":
/*!************************************************!*\
  !*** ./src/transform/observable-quaternion.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableQuaternion = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var quat_1 = __webpack_require__(/*! ../math/quat */ "./src/math/quat.ts");
/**
 * Represents a rotation quaternion in 3D space.
 */
var ObservableQuaternion = /** @class */ (function (_super) {
    tslib_1.__extends(ObservableQuaternion, _super);
    /**
     * Creates a new observable quaternion.
     * @param cb The callback when changed.
     * @param scope The owner of callback.
     * @param x The x component.
     * @param y The y component.
     * @param z The z component.
     * @param w The w component.
     */
    function ObservableQuaternion(cb, scope, x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 1; }
        var _this = _super.call(this, cb, scope) || this;
        _this._array = new Float32Array(4);
        _this._array.set([x, y, z, w]);
        return _this;
    }
    Object.defineProperty(ObservableQuaternion.prototype, "array", {
        /** Array containing the x, y, z, w values. */
        get: function () {
            return this._array;
        },
        set: function (value) {
            this.setFrom(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservableQuaternion.prototype, "x", {
        /** The x component of the quaternion. */
        get: function () {
            return this._array[0];
        },
        set: function (value) {
            if (this._array[0] !== value) {
                this._array[0] = value;
                this.cb.call(this.scope);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservableQuaternion.prototype, "y", {
        /** The y component of the quaternion. */
        get: function () {
            return this._array[1];
        },
        set: function (value) {
            if (this._array[1] !== value) {
                this._array[1] = value;
                this.cb.call(this.scope);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservableQuaternion.prototype, "z", {
        /** The z component of the quaternion. */
        get: function () {
            return this._array[2];
        },
        set: function (value) {
            if (this._array[2] !== value) {
                this._array[2] = value;
                this.cb.call(this.scope);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservableQuaternion.prototype, "w", {
        /** The w component of the quaternion. */
        get: function () {
            return this._array[3];
        },
        set: function (value) {
            if (this._array[3] !== value) {
                this._array[3] = value;
                this.cb.call(this.scope);
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the euler angles in degrees.
     * @param x The x angle.
     * @param y The y angle.
     * @param z The z angle.
     */
    ObservableQuaternion.prototype.setEulerAngles = function (x, y, z) {
        quat_1.Quat.fromEuler(x, y, z, this._array);
        this.cb.call(this.scope);
    };
    /**
     * Creates a clone of this quaternion.
     * @param cb Callback when changed.
     * @param scope Owner of callback.
     */
    ObservableQuaternion.prototype.clone = function (cb, scope) {
        if (cb === void 0) { cb = this.cb; }
        if (scope === void 0) { scope = this.scope; }
        return new ObservableQuaternion(cb, scope, this.x, this.y, this.z, this.w);
    };
    /**
     * Copies x, y, z, and w from the given quaternion.
     * @param p The quaternion to copy from.
     */
    ObservableQuaternion.prototype.copyFrom = function (p) {
        if (this._array[0] !== p.x || this._array[1] !== p.y || this._array[2] !== p.z || this._array[3] !== p.w) {
            this._array[0] = p.x;
            this._array[1] = p.y;
            this._array[2] = p.z;
            this._array[3] = p.w;
            this.cb.call(this.scope);
        }
        return this;
    };
    /**
     * Copies x, y, z and w into the given quaternion.
     * @param p The quaternion to copy to.
     */
    ObservableQuaternion.prototype.copyTo = function (p) {
        if (p instanceof ObservableQuaternion) {
            p.set(this.x, this.y, this.z, this.w);
        }
        return p;
    };
    /**
     * Returns true if the given quaternion is equal to this quaternion.
     * @param p The quaternion to check.
     */
    ObservableQuaternion.prototype.equals = function (p) {
        return p.x === this.x && p.y === this.y && p.z === this.z && p.w === this.w;
    };
    /**
     * Sets the quaternion to new x, y, z and w components.
     * @param x X component to set.
     * @param y Y component to set.
     * @param z Z component to set.
     * @param w W component to set.
     */
    ObservableQuaternion.prototype.set = function (x, y, z, w) {
        if (y === void 0) { y = x; }
        if (z === void 0) { z = x; }
        if (w === void 0) { w = x; }
        if (this._array[0] !== x || this._array[1] !== y || this._array[2] !== z || this._array[3] !== w) {
            this._array[0] = x;
            this._array[1] = y;
            this._array[2] = z;
            this._array[3] = w;
            this.cb.call(this.scope);
        }
        return this;
    };
    /**
     * Sets the quaternion to a new x, y, z and w components.
     * @param array The array containing x, y, z and w, expected length is 4.
     */
    ObservableQuaternion.prototype.setFrom = function (array) {
        this.set(array[0], array[1], array[2], array[3]);
        return this;
    };
    return ObservableQuaternion;
}(PIXI.ObservablePoint));
exports.ObservableQuaternion = ObservableQuaternion;


/***/ }),

/***/ "./src/transform/transform-matrix.ts":
/*!*******************************************!*\
  !*** ./src/transform/transform-matrix.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformMatrix = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var mat4_1 = __webpack_require__(/*! ../math/mat4 */ "./src/math/mat4.ts");
var vec3_1 = __webpack_require__(/*! ../math/vec3 */ "./src/math/vec3.ts");
var vec4_1 = __webpack_require__(/*! ../math/vec4 */ "./src/math/vec4.ts");
var matrix_component_1 = __webpack_require__(/*! ./matrix-component */ "./src/transform/matrix-component.ts");
var quat_1 = __webpack_require__(/*! ../math/quat */ "./src/math/quat.ts");
/**
 * Represents the matrix for a transform.
 */
var TransformMatrix = /** @class */ (function (_super) {
    tslib_1.__extends(TransformMatrix, _super);
    /**
     * Creates a new transform matrix using the specified matrix array.
     * @param array The matrix array, expected length is 16. If empty, an identity
     * matrix is used by default.
     */
    function TransformMatrix(array) {
        var _this = _super.call(this) || this;
        _this._transformId = 0;
        if (array) {
            _this.array = new Float32Array(array);
        }
        else {
            _this.array = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        }
        return _this;
    }
    Object.defineProperty(TransformMatrix.prototype, "transformId", {
        get: function () {
            return this._transformId;
        },
        enumerable: false,
        configurable: true
    });
    TransformMatrix.prototype.toArray = function (transpose, out) {
        if (transpose) {
            return mat4_1.Mat4.transpose(this.array, out);
        }
        return out ? mat4_1.Mat4.copy(this.array, out) : this.array;
    };
    Object.defineProperty(TransformMatrix.prototype, "position", {
        /** Returns the position component of the matrix. */
        get: function () {
            var _this = this;
            if (!this._position) {
                this._position = new matrix_component_1.MatrixComponent(this, 3, function (data) {
                    mat4_1.Mat4.getTranslation(_this.array, data);
                });
            }
            return this._position.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformMatrix.prototype, "scaling", {
        /** Returns the scaling component of the matrix. */
        get: function () {
            var _this = this;
            if (!this._scaling) {
                this._scaling = new matrix_component_1.MatrixComponent(this, 3, function (data) {
                    mat4_1.Mat4.getScaling(_this.array, data);
                });
            }
            return this._scaling.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformMatrix.prototype, "rotation", {
        /** Returns the rotation quaternion of the matrix. */
        get: function () {
            var _this = this;
            if (!this._rotation) {
                var matrix_1 = new Float32Array(16);
                this._rotation = new matrix_component_1.MatrixComponent(this, 4, function (data) {
                    var e_1, _a;
                    try {
                        // To extract a correct rotation, the scaling component must be eliminated.
                        for (var _b = tslib_1.__values([0, 1, 2]), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var col = _c.value;
                            matrix_1[col + 0] = _this.array[col + 0] / _this.scaling[0];
                            matrix_1[col + 4] = _this.array[col + 4] / _this.scaling[1];
                            matrix_1[col + 8] = _this.array[col + 8] / _this.scaling[2];
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    quat_1.Quat.normalize(mat4_1.Mat4.getRotation(matrix_1, data), data);
                });
            }
            return this._rotation.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformMatrix.prototype, "up", {
        /** Returns the up vector of the matrix. */
        get: function () {
            var _this = this;
            if (!this._up) {
                this._up = new matrix_component_1.MatrixComponent(this, 3, function (data) {
                    vec3_1.Vec3.normalize(vec3_1.Vec3.set(_this.array[4], _this.array[5], _this.array[6], data), data);
                });
            }
            return this._up.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformMatrix.prototype, "down", {
        /** Returns the down vector of the matrix. */
        get: function () {
            var _this = this;
            if (!this._down) {
                this._down = new matrix_component_1.MatrixComponent(this, 3, function (data) {
                    vec3_1.Vec3.negate(_this.up, data);
                });
            }
            return this._down.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformMatrix.prototype, "right", {
        /** Returns the left vector of the matrix. */
        get: function () {
            var _this = this;
            if (!this._right) {
                this._right = new matrix_component_1.MatrixComponent(this, 3, function (data) {
                    vec3_1.Vec3.negate(_this.left, data);
                });
            }
            return this._right.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformMatrix.prototype, "left", {
        /** Returns the right vector of the matrix. */
        get: function () {
            var _this = this;
            if (!this._left) {
                this._left = new matrix_component_1.MatrixComponent(this, 3, function (data) {
                    vec3_1.Vec3.normalize(vec3_1.Vec3.cross(_this.up, _this.forward, data), data);
                });
            }
            return this._left.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformMatrix.prototype, "forward", {
        /** Returns the forward vector of the matrix. */
        get: function () {
            var _this = this;
            if (!this._forward) {
                this._forward = new matrix_component_1.MatrixComponent(this, 3, function (data) {
                    vec3_1.Vec3.normalize(vec3_1.Vec3.set(_this.array[8], _this.array[9], _this.array[10], data), data);
                });
            }
            return this._forward.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TransformMatrix.prototype, "backward", {
        /** Returns the backward vector of the matrix. */
        get: function () {
            var _this = this;
            if (!this._backward) {
                this._backward = new matrix_component_1.MatrixComponent(this, 3, function (data) {
                    vec3_1.Vec3.negate(_this.forward, data);
                });
            }
            return this._backward.array;
        },
        enumerable: false,
        configurable: true
    });
    TransformMatrix.prototype.copyFrom = function (matrix) {
        if (matrix instanceof TransformMatrix) {
            mat4_1.Mat4.copy(matrix.array, this.array);
            this._transformId++;
        }
        return this;
    };
    /**
     * Sets the rotation, position and scale components.
     * @param rotation The rotation to set.
     * @param position The position to set.
     * @param scaling The scale to set.
     */
    TransformMatrix.prototype.setFromRotationPositionScale = function (rotation, position, scaling) {
        vec4_1.Vec4.set(rotation.x, rotation.y, rotation.z, rotation.w, this.rotation);
        vec3_1.Vec3.set(scaling.x, scaling.y, scaling.z, this.scaling);
        vec3_1.Vec3.set(position.x, position.y, position.z, this.position);
        mat4_1.Mat4.fromRotationTranslationScale(this.rotation, this.position, this.scaling, this.array);
        this._transformId++;
    };
    /**
     * Sets the multiplication result of two matrix transforms.
     * @param a The first operand.
     * @param b The second operand.
     */
    TransformMatrix.prototype.setFromMultiply = function (a, b) {
        mat4_1.Mat4.multiply(a.array, b.array, this.array);
        this._transformId++;
    };
    return TransformMatrix;
}(PIXI.Matrix));
exports.TransformMatrix = TransformMatrix;


/***/ }),

/***/ "./src/transform/transform.ts":
/*!************************************!*\
  !*** ./src/transform/transform.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Transform3D = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var PIXI = tslib_1.__importStar(__webpack_require__(/*! pixi.js */ "pixi.js"));
var transform_matrix_1 = __webpack_require__(/*! ./transform-matrix */ "./src/transform/transform-matrix.ts");
var observable_point_1 = __webpack_require__(/*! ./observable-point */ "./src/transform/observable-point.ts");
var observable_quaternion_1 = __webpack_require__(/*! ./observable-quaternion */ "./src/transform/observable-quaternion.ts");
var mat4_1 = __webpack_require__(/*! ../math/mat4 */ "./src/math/mat4.ts");
/**
 * Handles position, scaling and rotation.
 */
var Transform3D = /** @class */ (function (_super) {
    tslib_1.__extends(Transform3D, _super);
    function Transform3D() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The position in local space. */
        _this.position = new observable_point_1.ObservablePoint3D(_this.onChange, _this, 0, 0, 0);
        /** The scale in local space. */
        _this.scale = new observable_point_1.ObservablePoint3D(_this.onChange, _this, 1, 1, 1);
        /** The rotation in local space. */
        _this.rotationQuaternion = new observable_quaternion_1.ObservableQuaternion(_this.onChange, _this, 0, 0, 0, 1);
        /** The transformation matrix in world space. */
        _this.worldTransform = new transform_matrix_1.TransformMatrix();
        /** The transformation matrix in local space. */
        _this.localTransform = new transform_matrix_1.TransformMatrix();
        /** The inverse transformation matrix in world space. */
        _this.inverseWorldTransform = new transform_matrix_1.TransformMatrix();
        /** The normal transformation matrix. */
        _this.normalTransform = new transform_matrix_1.TransformMatrix();
        return _this;
    }
    /**
     * Updates the local transformation matrix.
     */
    Transform3D.prototype.updateLocalTransform = function () {
        if (this._localID === this._currentLocalID) {
            return;
        }
        this.localTransform.setFromRotationPositionScale(this.rotationQuaternion, this.position, this.scale);
        this._parentID = -1;
        this._currentLocalID = this._localID;
    };
    /**
     * Sets position, rotation and scale from an matrix array.
     * @param matrix The matrix to set.
     */
    Transform3D.prototype.setFromMatrix = function (matrix) {
        this.localTransform.copyFrom(matrix);
        this.position.set(this.localTransform.position[0], this.localTransform.position[1], this.localTransform.position[2]);
        this.scale.set(this.localTransform.scaling[0], this.localTransform.scaling[1], this.localTransform.scaling[2]);
        this.rotationQuaternion.set(this.localTransform.rotation[0], this.localTransform.rotation[1], this.localTransform.rotation[2], this.localTransform.rotation[3]);
    };
    /**
     * Updates the world transformation matrix.
     * @param parentTransform The parent transform.
     */
    Transform3D.prototype.updateTransform = function (parentTransform) {
        this.updateLocalTransform();
        if (parentTransform && this._parentID === parentTransform._worldID) {
            return;
        }
        if (parentTransform instanceof Transform3D) {
            this.worldTransform.setFromMultiply(parentTransform.worldTransform, this.localTransform);
        }
        else {
            this.worldTransform.copyFrom(this.localTransform);
        }
        mat4_1.Mat4.invert(this.worldTransform.array, this.inverseWorldTransform.array);
        mat4_1.Mat4.transpose(this.inverseWorldTransform.array, this.normalTransform.array);
        this._worldID++;
        if (parentTransform) {
            this._parentID = parentTransform._worldID;
        }
    };
    /**
     * Rotates the transform so the forward vector points at specified point.
     * @param point The point to look at.
     * @param up The upward direction.
     */
    Transform3D.prototype.lookAt = function (point, up) {
        if (up === void 0) { up = new Float32Array([0, 1, 0]); }
        var rot = mat4_1.Mat4.getRotation(mat4_1.Mat4.targetTo(point.array, this.worldTransform.position, up));
        this.rotationQuaternion.set(rot[0], rot[1], rot[2], rot[3]);
    };
    return Transform3D;
}(PIXI.Transform));
exports.Transform3D = Transform3D;


/***/ }),

/***/ "pixi.js":
/*!*******************************************************************************************!*\
  !*** external {"commonjs":"pixi.js","commonjs2":"pixi.js","amd":"pixi.js","root":"PIXI"} ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_pixi_js__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QSVhJM0Qvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1BJWEkzRC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9QSVhJM0QvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vbWF0Mi5qcyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQyZC5qcyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQzLmpzIiwid2VicGFjazovL1BJWEkzRC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDQuanMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vcXVhdC5qcyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9xdWF0Mi5qcyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMyLmpzIiwid2VicGFjazovL1BJWEkzRC8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzMuanMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjNC5qcyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9hbmltYXRpb24udHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2NhbWVyYS9jYW1lcmEtb3JiaXQtY29udHJvbC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvY2FtZXJhL2NhbWVyYS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvY29sb3IudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2NvbnNvbGUudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2NvbnRhaW5lci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvY3ViZW1hcC9jdWJlbWFwLXJlc291cmNlLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9jdWJlbWFwL2N1YmVtYXAudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2N1YmVtYXAvbWlwbWFwLXJlc291cmNlLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9nbHRmL2FuaW1hdGlvbi9nbHRmLWFuaW1hdGlvbi50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvZ2x0Zi9hbmltYXRpb24vZ2x0Zi1jaGFubmVsLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9nbHRmL2FuaW1hdGlvbi9nbHRmLWN1YmljLXNwbGluZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvZ2x0Zi9hbmltYXRpb24vZ2x0Zi1pbnRlcnBvbGF0aW9uLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9nbHRmL2FuaW1hdGlvbi9nbHRmLWxpbmVhci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvZ2x0Zi9hbmltYXRpb24vZ2x0Zi1yb3RhdGlvbi50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvZ2x0Zi9hbmltYXRpb24vZ2x0Zi1zY2FsZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvZ2x0Zi9hbmltYXRpb24vZ2x0Zi1zcGhlcmljYWwtbGluZWFyLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9nbHRmL2FuaW1hdGlvbi9nbHRmLXN0ZXAudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2dsdGYvYW5pbWF0aW9uL2dsdGYtdHJhbnNsYXRpb24udHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2dsdGYvYW5pbWF0aW9uL2dsdGYtd2VpZ2h0cy50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvZ2x0Zi9nbHRmLWFzc2V0LnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9nbHRmL2dsdGYtYnVmZmVyLXZpZXcudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2dsdGYvZ2x0Zi1tYXRlcmlhbC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvZ2x0Zi9nbHRmLXBhcnNlci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2luc3RhbmNlZC1tb2RlbC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbGlnaHRpbmcvYXNzZXRzL2JyZGYucG5nIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9saWdodGluZy9pbWFnZS1iYXNlZC1saWdodGluZy50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbGlnaHRpbmcvbGlnaHQtdHlwZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbGlnaHRpbmcvbGlnaHQudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2xpZ2h0aW5nL2xpZ2h0aW5nLWVudmlyb25tZW50LnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9sb2FkZXIvY3ViZW1hcC1sb2FkZXIudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2xvYWRlci9nbHRmLWJpbmFyeS1sb2FkZXIudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL2xvYWRlci9nbHRmLWxvYWRlci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbG9hZGVyL3NoYWRlci1zb3VyY2UtbG9hZGVyLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tYXRlcmlhbC9tYXRlcmlhbC1yZW5kZXItc29ydC10eXBlLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tYXRlcmlhbC9tYXRlcmlhbC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWF0ZXJpYWwvc3RhbmRhcmQvaW5zdGFuY2VkLXN0YW5kYXJkLW1hdGVyaWFsLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tYXRlcmlhbC9zdGFuZGFyZC9zaGFkZXIvbWV0YWxsaWMtcm91Z2huZXNzLmZyYWciLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21hdGVyaWFsL3N0YW5kYXJkL3NoYWRlci9wcmltaXRpdmUudmVydCIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtbWF0ZXJpYWwtYWxwaGEtbW9kZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtbWF0ZXJpYWwtZGVidWctbW9kZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtbWF0ZXJpYWwtZmVhdHVyZS1zZXQudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21hdGVyaWFsL3N0YW5kYXJkL3N0YW5kYXJkLW1hdGVyaWFsLW1hdHJpeC10ZXh0dXJlLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tYXRlcmlhbC9zdGFuZGFyZC9zdGFuZGFyZC1tYXRlcmlhbC1za2luLXVuaWZvcm1zLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tYXRlcmlhbC9zdGFuZGFyZC9zdGFuZGFyZC1tYXRlcmlhbC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtc2hhZGVyLWluc3RhbmNpbmcudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21hdGVyaWFsL3N0YW5kYXJkL3N0YW5kYXJkLXNoYWRlci1zb3VyY2UudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21hdGVyaWFsL3N0YW5kYXJkL3N0YW5kYXJkLXNoYWRlci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWF0aC9tYXQzLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tYXRoL21hdDQudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21hdGgvcGxhbmUudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21hdGgvcXVhdC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWF0aC9yYXkudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21hdGgvdmVjMy50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWF0aC92ZWM0LnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tZXNoL2dlb21ldHJ5L2N1YmUtZ2VvbWV0cnkudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21lc2gvZ2VvbWV0cnkvbWVzaC1nZW9tZXRyeS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWVzaC9nZW9tZXRyeS9wbGFuZS1nZW9tZXRyeS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvbWVzaC9nZW9tZXRyeS9xdWFkLWdlb21ldHJ5LnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tZXNoL2luc3RhbmNlZC1tZXNoLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tZXNoL21lc2gtc2hhZGVyLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9tZXNoL21lc2gudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL21vZGVsLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9waWNraW5nL3BpY2tpbmctaGl0YXJlYS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvcGlja2luZy9waWNraW5nLWlkLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9waWNraW5nL3BpY2tpbmctbWFuYWdlci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvcGlja2luZy9waWNraW5nLW1hcC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvcGlja2luZy9zaGFkZXIvcGlja2luZy5mcmFnIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9waWNraW5nL3NoYWRlci9waWNraW5nLnZlcnQiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL3BpcGVsaW5lL21hdGVyaWFsLXJlbmRlci1wYXNzLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9waXBlbGluZS9zdGFuZGFyZC1waXBlbGluZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvcGl4aS9hcnJheS1yZXNvdXJjZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvcGl4aS9iYXNlLWltYWdlLXJlc291cmNlLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9waXhpL2J1ZmZlci1yZXNvdXJjZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvcGl4aS9jdWJlLXJlc291cmNlLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9wbGF0Zm9ybS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2hhZG93L3NoYWRlci9nYXVzc2lhbi1ibHVyLmZyYWciLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL3NoYWRvdy9zaGFkZXIvZ2F1c3NpYW4tYmx1ci52ZXJ0Iiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9zaGFkb3cvc2hhZGVyL3NoYWRvdy5mcmFnIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9zaGFkb3cvc2hhZGVyL3NoYWRvdy52ZXJ0Iiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9zaGFkb3cvc2hhZG93LWNhc3RpbmctbGlnaHQudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL3NoYWRvdy9zaGFkb3ctZmlsdGVyLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9zaGFkb3cvc2hhZG93LW1hdGgudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL3NoYWRvdy9zaGFkb3ctcXVhbGl0eS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2hhZG93L3NoYWRvdy1yZW5kZXItcGFzcy50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2hhZG93L3NoYWRvdy1yZW5kZXJlci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2hhZG93L3NoYWRvdy1zaGFkZXIudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL3NoYWRvdy9zaGFkb3ctdGV4dHVyZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2hhZG93L3NraW5uaW5nLXNoYWRlci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2hhZG93L3RleHR1cmUtc2hhZGVyLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy9za2lubmluZy9qb2ludC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2tpbm5pbmcvc2tpbi50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2t5Ym94L3NoYWRlci9za3lib3guZnJhZyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2t5Ym94L3NoYWRlci9za3lib3gudmVydCIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2t5Ym94L3NreWJveC1tYXRlcmlhbC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc2t5Ym94L3NreWJveC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc3ByaXRlL3Bvc3QtcHJvY2Vzc2luZy1zcHJpdGUudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL3Nwcml0ZS9wcm9qZWN0aW9uLXNwcml0ZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc3ByaXRlL3NoYWRlci9zcHJpdGUuZnJhZyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc3ByaXRlL3NoYWRlci9zcHJpdGUudmVydCIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc3ByaXRlL3Nwcml0ZS1iYXRjaC1nZW9tZXRyeS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc3ByaXRlL3Nwcml0ZS1iYXRjaC1yZW5kZXJlci50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc3ByaXRlL3Nwcml0ZS1iaWxsYm9hcmQtdHlwZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvc3ByaXRlL3Nwcml0ZS50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvdGV4dHVyZS90ZXh0dXJlVHJhbnNmb3JtLnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy90cmFuc2Zvcm0vbWF0cml4LWNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly9QSVhJM0QvLi9zcmMvdHJhbnNmb3JtL29ic2VydmFibGUtcG9pbnQudHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL3RyYW5zZm9ybS9vYnNlcnZhYmxlLXF1YXRlcm5pb24udHMiLCJ3ZWJwYWNrOi8vUElYSTNELy4vc3JjL3RyYW5zZm9ybS90cmFuc2Zvcm0tbWF0cml4LnRzIiwid2VicGFjazovL1BJWEkzRC8uL3NyYy90cmFuc2Zvcm0vdHJhbnNmb3JtLnRzIiwid2VicGFjazovL1BJWEkzRC9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwicGl4aS5qc1wiLFwiY29tbW9uanMyXCI6XCJwaXhpLmpzXCIsXCJhbWRcIjpcInBpeGkuanNcIixcInJvb3RcIjpcIlBJWElcIn0iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFl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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztB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LElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQztRQUMzQyxJQUFNLElBQUksR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUM7UUFDM0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDckMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUMsU0FBUyxDQUN2QyxRQUFRLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNuTDtRQUNELE9BQU8sSUFBSSxDQUFDLEtBQUs7SUFDbkIsQ0FBQztJQUVNLHlCQUFTLEdBQWhCLFVBQWlCLENBQVMsRUFBRSxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsRUFBRSxFQUFVO1FBQ3hFLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUMsRUFBSSxDQUFDLEVBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFDLEVBQUksQ0FBQyxFQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsVUFBQyxFQUFJLENBQUMsRUFBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQUMsRUFBSSxDQUFDLEVBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFD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QUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUN2UjtZQUNELE9BQU8sRUFBRTtnQkFDUCxNQUFNLEVBQUUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ3pKO1lBQ0QsT0FBTyxFQUFFO2dCQUNQLE1BQU0sRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDL1A7WUFDRCxHQUFHLEVBQUUsQ0FBQztvQkFDSixNQUFNLEVBQUUsSUFBSSxZQUFZLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO2lCQUMvVCxDQUFDO1lBQ0YsUUFBUSxFQUFFO2dCQUNSLE1BQU0sRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUMvVDtTQUNGLENBQUM7SUFDSixDQUFDO0lBbEJlLG1CQUFNLFNBa0JyQjtBQUNILENBQUMsRUFwQmdCLFlBQVksR0FBWixvQkFBWSxLQUFaLG9CQUFZLFFBb0I1Qjs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCRDs7R0FFRztBQUNIO0lBQUE7UUFDVSxvQkFBZSxHQUFvQyxFQUFFO0lBaUQvRCxDQUFDO0lBdENDOzs7T0FHRztJQUNILDBDQUFpQixHQUFqQixVQUFrQixNQUFrQjtRQUNsQyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDBDQUFpQixHQUFqQixVQUFrQixNQUFrQixFQUFFLFNBQWtCO1FBQ3RELElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDO0lBQ2xGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsMENBQWlCLEdBQWpCLFVBQWtCLE1BQWtCLEVBQUUsU0FBa0I7UUFDdEQsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNyQyxPQUFPLENBQUMsU0FBUyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQztTQUNoRjtRQUNELE9BQU8sS0FBSztJQUNkLENBQUM7SUFFRDs7T0FFRztJQUNILGdDQUFPLEdBQVA7UUFDRSxLQUFLLElBQUksTUFBSSxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDckMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUU7U0FDckM7UUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUU7SUFDM0IsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0FBQztBQWxEWSx3Q0FBYzs7Ozs7Ozs7Ozs7Ozs7OztBQ1QzQix5R0FBZ0Q7QUFFaEQsSUFBaUIsYUFBYSxDQWlCN0I7QUFqQkQsV0FBaUIsYUFBYTtJQUM1QixTQUFnQixNQUFNO1FBQ3BCLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLDhCQUFjLEVBQUUsRUFBRTtZQUN6QyxTQUFTLEVBQUU7Z0JBQ1QsTUFBTSxFQUFFLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ25FO1lBQ0QsT0FBTyxFQUFFO2dCQUNQLE1BQU0sRUFBRSxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDM0M7WUFDRCxPQUFPLEVBQUU7Z0JBQ1AsTUFBTSxFQUFFLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUMvRDtZQUNELEdBQUcsRUFBRSxDQUFDO29CQUNKLE1BQU0sRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDbkQsQ0FBQztTQUNILENBQUM7SUFDSixDQUFDO0lBZmUsb0JBQU0sU0FlckI7QUFDSCxDQUFDLEVBakJnQixhQUFhLEdBQWIscUJBQWEsS0FBYixxQkFBYSxRQWlCN0I7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQkQseUdBQWdEO0FBRWhELElBQWlCLFlBQVksQ0FpQjVCO0FBakJELFdBQWlCLFlBQVk7SUFDM0IsU0FBZ0IsTUFBTTtRQUNwQixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSw4QkFBYyxFQUFFLEVBQUU7WUFDekMsU0FBUyxFQUFFO2dCQUNULE1BQU0sRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNuRTtZQUNELE9BQU8sRUFBRTtnQkFDUCxNQUFNLEVBQUUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQzNDO1lBQ0QsT0FBTyxFQUFFO2dCQUNQLE1BQU0sRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDL0Q7WUFDRCxHQUFHLEVBQUUsQ0FBQztvQkFDSixNQUFNLEVBQUUsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQ25ELENBQUM7U0FDSCxDQUFDO0lBQ0osQ0FBQztJQWZlLG1CQUFNLFNBZXJCO0FBQ0gsQ0FBQyxFQWpCZ0IsWUFBWSxHQUFaLG9CQUFZLEtBQVosb0JBQVksUUFpQjVCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCRCxnRkFBMEM7QUFHMUM7SUFBcUMsMkNBQVc7SUFDOUMseUJBQXFCLElBQVksRUFBVyxRQUFpQjtRQUE3RCxZQUNFLGlCQUFPLFNBQ1I7UUFGb0IsVUFBSSxHQUFKLElBQUksQ0FBUTtRQUFXLGNBQVEsR0FBUixRQUFRLENBQVM7O0lBRTdELENBQUM7SUFFRCxpQ0FBTyxHQUFQLFVBQVEsT0FBbUQ7UUFDekQsaUJBQU0sT0FBTyxZQUFDLE9BQU8sQ0FBQztRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0FBQyxDQVRvQyx1QkFBVyxHQVMvQztBQVRZLDBDQUFlOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0w1QiwrRUFBK0I7QUFLL0I7O0dBRUc7QUFDSDtJQUFnQyxzQ0FBVztJQUEzQztRQUFBLHFFQWdFQztRQS9EUyxZQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUMvQyxPQUFPLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSTtTQUMxRCxDQUFDOztJQTZESixDQUFDO0lBMURDLHNCQUFJLDRCQUFJO1FBRFIsNk1BQTZNO2FBQzdNO1lBQ0UsT0FBTyxhQUFhO1FBQ3RCLENBQUM7OztPQUFBO0lBRUQ7Ozs7T0FJRztJQUNILHlDQUFvQixHQUFwQixVQUFxQixRQUF3QixFQUFFLFNBQWtCO1FBQy9ELElBQUksTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUNoQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLEVBQUU7WUFDcEIsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsS0FBSyxDQUFDLEVBQUU7Z0JBQ25ELGdGQUFnRjtnQkFDaEYsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQzNFO2lCQUFNO2dCQUNMLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDMUQ7U0FDRjtRQUNELElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRTtZQUN0QixNQUFNLENBQUMsWUFBWSxDQUFDLFlBQVksRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFDMUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsU0FBUyxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztTQUN6RTtRQUNELElBQUksUUFBUSxDQUFDLEdBQUcsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ25DLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUNsRSxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1NBQ25FO1FBQ0QsSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFO1lBQ3BCLE1BQU0sQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUN0RSxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO1NBQ3JFO1FBQ0QsSUFBSSxRQUFRLENBQUMsUUFBUSxFQUFFO1lBQ3JCLE1BQU0sQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUN4RSxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO1NBQ3ZFO1FBQ0QsT0FBTyxNQUFNO0lBQ2YsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILDJCQUFNLEdBQU4sVUFBTyxJQUFZLEVBQUUsUUFBdUIsRUFBRSxLQUErQixFQUFFLFFBQW9DO1FBQXJFLGdDQUFvQixJQUFJLENBQUMsTUFBTTtRQUFFLHNDQUFXLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUztRQUNqSCxJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFDO1lBQzNDLFFBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDLFVBQVU7UUFBOUIsQ0FBOEIsQ0FBQyxDQUFDLE1BQU07UUFDeEMsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQztRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLEVBQUU7WUFDdEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDO1NBQ2xEO1FBQ0QsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7UUFDcEQsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQztRQUNqQyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7UUFDekIsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQztRQUN0QyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxhQUFhLENBQUM7SUFDdkUsQ0FBQztJQUNILGlCQUFDO0FBQUQsQ0FBQyxDQWhFK0IsSUFBSSxDQUFDLE1BQU0sR0FnRTFDO0FBaEVZLGdDQUFVOzs7Ozs7Ozs7Ozs7Ozs7OztBQ052QixxSEFBeUQ7QUFDekQsa0hBQXVEO0FBR3ZELDRJQUF5RTtBQUN6RSxnRkFBMEM7QUFDMUMsa0hBQXVEO0FBRXZELG1HQUFrRDtBQUNsRCw2RUFBc0M7QUFFdEM7O0dBRUc7QUFDSDtJQUE0QixrQ0FBVztJQWNyQzs7OztPQUlHO0lBQ0gsZ0JBQW1CLFFBQXdCLEVBQVMsUUFBbUI7UUFBdkUsWUFDRSxpQkFBTyxTQUlSO1FBTGtCLGNBQVEsR0FBUixRQUFRLENBQWdCO1FBQVMsY0FBUSxHQUFSLFFBQVEsQ0FBVztRQWpCdkUsMERBQTBEO1FBQzFELGdCQUFVLEdBQUcsVUFBVTtRQVF2QiwrQ0FBK0M7UUFDL0MseUJBQW1CLEdBQUcsQ0FBQyxVQUFVLENBQUM7UUFzQjFCLGdCQUFVLEdBQXNCLEVBQUU7UUFieEMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUM7U0FDdEU7O0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDRCQUFxQixHQUE1QixVQUE2QixRQUF1QjtRQUNsRCxPQUFPLG1CQUFRLENBQUMscUJBQXFCLENBQUMsUUFBUSxDQUFDO0lBQ2pELENBQUM7SUFLRCxzQkFBSSw2QkFBUztRQURiLG9EQUFvRDthQUNwRDtZQUNFLE9BQU8sSUFBSSxDQUFDLFVBQVU7UUFDeEIsQ0FBQzs7O09BQUE7SUFFRDs7T0FFRztJQUNILCtCQUFjLEdBQWQ7O1FBQ0UsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxxQkFBcUIsRUFBRTtZQUN6RCxNQUFNLElBQUksS0FBSyxDQUFDLGdGQUFnRixDQUFDO1NBQ2xHO1FBQ0QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLGdDQUFlLENBQUMsSUFBSSxFQUFFLFVBQUksQ0FBQyxRQUFRLDBDQUFFLGNBQWMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3JGO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILCtCQUFjLEdBQWQsVUFBZSxRQUF5QjtRQUN0QyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7UUFDL0MsSUFBSSxLQUFLLElBQUksQ0FBQyxFQUFFO1lBQ2QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUNqQztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCxpQ0FBZ0IsR0FBaEIsVUFBaUIsSUFBWTtRQUMzQixJQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzlDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILGtDQUFpQixHQUFqQixVQUFrQixJQUFZO1FBQzVCLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ3BELElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTtZQUNkLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUMxQztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCxvQ0FBbUIsR0FBbkIsVUFBb0IsSUFBWTtRQUM5QixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNwRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCx3QkFBTyxHQUFQO1FBQ0UsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUU7UUFDdkIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFO1NBQ3hCO1FBQ0QsaUJBQU0sT0FBTyxXQUFFO0lBQ2pCLENBQUM7SUFFRCx3QkFBTyxHQUFQLFVBQVEsUUFBdUI7UUFDN0IsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FDSCxRQUFRLENBQUMsT0FBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FDOUQsQ0FBQztRQUN5QixRQUFRLENBQUMsT0FBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO0lBQzVFLENBQUM7SUFFRDs7O09BR0c7SUFDSSxpQkFBVSxHQUFqQixVQUFrQixRQUEyQztRQUEzQywwQ0FBeUIsb0NBQWdCLEVBQUU7UUFDM0QsT0FBTyxJQUFJLE1BQU0sQ0FBQyw0QkFBWSxDQUFDLE1BQU0sRUFBRSxFQUFFLFFBQVEsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksaUJBQVUsR0FBakIsVUFBa0IsUUFBMkM7UUFBM0MsMENBQXlCLG9DQUFnQixFQUFFO1FBQzNELE9BQU8sSUFBSSxNQUFNLENBQUMsNEJBQVksQ0FBQyxNQUFNLEVBQUUsRUFBRSxRQUFRLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGtCQUFXLEdBQWxCLFVBQW1CLFFBQTJDO1FBQTNDLDBDQUF5QixvQ0FBZ0IsRUFBRTtRQUM1RCxPQUFPLElBQUksTUFBTSxDQUFDLDhCQUFhLENBQUMsTUFBTSxFQUFFLEVBQUUsUUFBUSxDQUFDO0lBQ3JELENBQUM7SUFDSCxhQUFDO0FBQUQsQ0FBQyxDQXRJMkIsdUJBQVcsR0FzSXRDO0FBdElZLHdCQUFNOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCbkIsK0ZBQStDO0FBSy9DLCtFQUF5QztBQUN6QyxpR0FBa0Q7QUFFbEQ7O0dBRUc7QUFDSDtJQUEyQixpQ0FBVztJQUF0QztRQUFBLHFFQXlCQztRQXhCQyw0Q0FBNEM7UUFDNUMsZ0JBQVUsR0FBZ0IsRUFBRTtRQUU1Qjs7O1dBR0c7UUFDSCxZQUFNLEdBQWEsRUFBRTs7SUFpQnZCLENBQUM7SUFmQzs7OztPQUlHO0lBQ0ksVUFBSSxHQUFYLFVBQVksTUFBaUIsRUFBRSxlQUFpQztRQUM5RCxPQUFPLHdCQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxlQUFlLENBQUM7SUFDeEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsOEJBQWMsR0FBZDtRQUNFLE9BQU8sZ0NBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ2xDLENBQUM7SUFDSCxZQUFDO0FBQUQsQ0FBQyxDQXpCMEIsdUJBQVcsR0F5QnJDO0FBekJZLHNCQUFLOzs7Ozs7Ozs7Ozs7Ozs7O0FDTmxCLDBGQUF3QztBQUd4Qzs7R0FFRztBQUNIO0lBTUU7Ozs7O09BS0c7SUFDSCx3QkFBWSxRQUF1QixFQUFTLE1BQXNCLEVBQVMsTUFBZTtRQUE5QyxXQUFNLEdBQU4sTUFBTSxDQUFnQjtRQUFTLFdBQU0sR0FBTixNQUFNLENBQVM7UUFUMUYsdUNBQXVDO1FBQ3ZDLE9BQUUsR0FBRyxzQkFBUyxDQUFDLElBQUksRUFBRTtRQVNuQixJQUFJLENBQUMsUUFBUSxHQUFTLFFBQVEsQ0FBQyxPQUFRLENBQUMsT0FBTztJQUNqRCxDQUFDO0lBRUQsaUNBQVEsR0FBUixVQUFTLENBQVMsRUFBRSxDQUFTO1FBQzNCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUM7SUFDbEQsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0FBQztBQW5CWSx3Q0FBYzs7Ozs7Ozs7Ozs7Ozs7OztBQ1gzQixJQUFpQixTQUFTLENBUXpCO0FBUkQsV0FBaUIsU0FBUztJQUN4QixJQUFJLEVBQUUsR0FBRyxDQUFDO0lBQ1YsU0FBZ0IsSUFBSTtRQUNsQixFQUFFLEVBQUU7UUFDSixPQUFPLElBQUksVUFBVSxDQUFDO1lBQ3BCLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsRUFBRSxHQUFHLEdBQUc7U0FDNUMsQ0FBQztJQUNKLENBQUM7SUFMZSxjQUFJLE9BS25CO0FBQ0gsQ0FBQyxFQVJnQixTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQVF6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSRCwrRUFBK0I7QUFHL0IsNkZBQTBDO0FBRTFDOzs7OztHQUtHO0FBQ0g7SUFJRTs7O09BR0c7SUFDSCx3QkFBbUIsUUFBdUI7UUFBMUMsaUJBa0JDO1FBbEJrQixhQUFRLEdBQVIsUUFBUSxDQUFlO1FBTmxDLGNBQVMsR0FBcUIsRUFBRTtRQU90QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksd0JBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBRTVHLFFBQVEsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFO1lBQ3hCLHlFQUF5RTtZQUN6RSxpRUFBaUU7WUFDakUsNEVBQTRFO1lBQzVFLHFDQUFxQztZQUNyQyxLQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFL0QsSUFBSSxLQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQUUsT0FBTTthQUFFO1lBRTNDLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxLQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZGLElBQUksS0FBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBSyxFQUFFO2dCQUM3QixLQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDMUM7WUFDRCxLQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFBQyxLQUFJLENBQUMsU0FBUyxHQUFHLEVBQUU7UUFDdkQsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELGdDQUFPLEdBQVA7SUFDQSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCx3Q0FBZSxHQUFmLFVBQWdCLENBQVMsRUFBRSxDQUFTLEVBQUUsT0FBdUI7UUFDM0QsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO1NBQzdCO1FBQ0QsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxFQUFFLENBQUM7SUFDL0MsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0FBQztBQTNDWSx3Q0FBYztBQTZDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFPLGNBQWMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RDVELCtFQUErQjtBQUcvQixxRkFBeUM7QUFDekMsMkVBQXFDO0FBQ3JDLGdHQUFnRDtBQUVoRDtJQU1FLG9CQUFvQixTQUF3QixFQUFFLEtBQWEsRUFBRSxNQUFjO1FBQXZELGNBQVMsR0FBVCxTQUFTLENBQWU7UUFGcEMsWUFBTyxHQUFHLENBQUM7UUFHakIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLFVBQVUsQ0FBQyxLQUFLLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxTQUFFLE1BQU0sVUFBRSxDQUFDO1FBQzNELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSx3QkFBVSxDQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBTyxDQUFDLGdFQUF1QixDQUFDLEVBQUUsbUJBQU8sQ0FBQyxnRUFBdUIsQ0FBQyxDQUFDLENBQUM7UUFDeEYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsZUFBZSxFQUFFO0lBQzVDLENBQUM7SUFFRCw0QkFBTyxHQUFQO1FBQ0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQzFCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO0lBQ3hCLENBQUM7SUFFRCwyQkFBTSxHQUFOLFVBQU8sS0FBYSxFQUFFLE1BQWM7UUFDbEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLFVBQVUsQ0FBQyxLQUFLLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDO0lBQ3BDLENBQUM7SUFFRCwrQkFBVSxHQUFWLFVBQVcsQ0FBUyxFQUFFLENBQVMsRUFBRSxFQUFjO1FBQ3ZDLFNBQW9CLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUF2QyxLQUFLLGFBQUUsTUFBTSxZQUEwQjtRQUUvQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBQzlDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUMzRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzFCLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUNoRSxPQUFPLEtBQUs7YUFDYjtTQUNGO1FBQ0QsT0FBTyxJQUFJO0lBQ2IsQ0FBQztJQUVELHNCQUFJLDZCQUFLO2FBQVQsY0FBYyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFDLENBQUM7OztPQUFBO0lBRXpDLHNCQUFJLDhCQUFNO2FBQVYsY0FBZSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFDLENBQUM7OztPQUFBO0lBRTNDLDJCQUFNLEdBQU4sVUFBTyxRQUEwQjs7UUFDL0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDL0MsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM1QiwyRUFBMkU7WUFDM0UsK0RBQStEO1lBQy9ELElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRTs7Z0JBQ3BDLEtBQW9CLDBDQUFRLDJGQUFFO29CQUF6QixJQUFJLE9BQU87b0JBQ2QsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sWUFBWSxhQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU07b0JBQ3hGLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLElBQUksZUFBTSxDQUFDLElBQUk7O3dCQUMxQyxLQUFpQixxREFBTSxrRkFBRTs0QkFBcEIsSUFBSSxJQUFJOzRCQUNYLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxLQUFLOzRCQUNuRSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLEVBQUU7NEJBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxjQUFjOzRCQUM5RCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQzt5QkFDMUM7Ozs7Ozs7OztpQkFDRjs7Ozs7Ozs7O1NBQ0Y7YUFBTTtZQUNMLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUM1QixFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUM7U0FDdEc7UUFDRCxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQzlDLENBQUM7SUFDSCxpQkFBQztBQUFELENBQUM7QUEvRFksZ0NBQVU7Ozs7Ozs7Ozs7OztBQ1B2Qiw2RkFBNkYsbUNBQW1DLDhCQUE4QixpQkFBaUIsMkNBQTJDLEdBQUcsQzs7Ozs7Ozs7Ozs7QUNBN04sNERBQTRELHlCQUF5QixnQ0FBZ0MsaUJBQWlCLHFFQUFxRSxHQUFHLEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNFOU0sb0VBQWdDO0FBSWhDOztHQUVHO0FBQ0g7SUFlRTs7OztPQUlHO0lBQ0gsNEJBQW1CLFFBQXVCLEVBQVMsSUFBWTtRQUE1QyxhQUFRLEdBQVIsUUFBUSxDQUFlO1FBQVMsU0FBSSxHQUFKLElBQUksQ0FBUTtRQWpCL0QsZ0lBQWdJO1FBQ2hJLGVBQVUsR0FBRyxJQUFJLGFBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7SUFpQmxDLENBQUM7SUFkRCxzQkFBSSw2Q0FBYTtRQURqQixvREFBb0Q7YUFDcEQ7WUFDRSxPQUFPLElBQUksQ0FBQyxjQUFjO1FBQzVCLENBQUM7YUFFRCxVQUFrQixLQUFxQztZQUNyRCxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUs7UUFDN0IsQ0FBQzs7O09BSkE7SUFjRCxrQ0FBSyxHQUFMO1FBQ0UsSUFBSSxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDMUMsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTztZQUNuRCxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztZQUNyRCxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ25FLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7U0FDMUM7SUFDSCxDQUFDO0lBRUQsbUNBQU0sR0FBTixVQUFPLE1BQWdCOztRQUNyQixJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPO1FBQ25ELElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztTQUN0RDs7WUFDRCxLQUFpQixzQ0FBTSxpRkFBRTtnQkFBcEIsSUFBSSxJQUFJO2dCQUNYLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDakIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUM7aUJBQzFDO2FBQ0Y7Ozs7Ozs7OztRQUNELElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO1NBQzFDO0lBQ0gsQ0FBQztJQUNILHlCQUFDO0FBQUQsQ0FBQztBQTlDWSxnREFBa0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVC9CLCtFQUErQjtBQUUvQix5SEFBMkQ7QUFFM0QseUhBQStEO0FBQy9ELHFJQUFvRztBQUNwRyxvRUFBZ0M7QUFHaEMsNElBQXlFO0FBQ3pFLGtKQUE4RTtBQUU5RTs7O0dBR0c7QUFDSDtJQUFzQyw0Q0FBbUI7SUFjdkQ7OztPQUdHO0lBQ0gsMEJBQW1CLFFBQXVCO1FBQTFDLFlBQ0Usa0JBQU0sUUFBUSxDQUFDLFNBVWhCO1FBWGtCLGNBQVEsR0FBUixRQUFRLENBQWU7UUFqQmxDLG1CQUFhLEdBQWlCLEVBQUU7UUFDaEMsYUFBTyxHQUFhLEVBQUU7UUFtQjVCLEtBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLHFDQUFnQixDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMvRSxLQUFJLENBQUMsYUFBYSxHQUFHLEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSx5Q0FBa0IsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFckYsUUFBUSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUU7OztnQkFDdkIsS0FBaUIsK0JBQUksQ0FBQyxhQUFhLDZDQUFFO29CQUFoQyxJQUFJLElBQUk7b0JBQ1gsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO3dCQUFFLElBQUksQ0FBQyxLQUFLLEVBQUU7cUJBQUU7aUJBQ2pDOzs7Ozs7Ozs7UUFDSCxDQUFDLENBQUM7O0lBQ0osQ0FBQztJQXZCRDs7O09BR0c7SUFDSSxxQkFBSSxHQUFYLFVBQVksUUFBdUI7UUFDakMsT0FBK0IsUUFBUSxDQUFDLE9BQVEsQ0FBQyxRQUFRO0lBQzNELENBQUM7SUFtQkQ7OztPQUdHO0lBQ0gsd0NBQWEsR0FBYixVQUFvQyxVQUFhO1FBQy9DLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzlDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztTQUNwQztRQUNELE9BQU8sVUFBVTtJQUNuQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsMkNBQWdCLEdBQWhCLFVBQWlCLFVBQXNCO1FBQ3JDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztRQUNwRCxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7WUFDZCxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxxREFBMEIsR0FBMUIsVUFBMkIsT0FBcUM7UUFDOUQsSUFBTSxNQUFNLEdBQ1YsSUFBSSw2Q0FBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQztRQUNsRCxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsYUFBYTtRQUN2RCxPQUFPLE1BQU07SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsaUNBQU0sR0FBTixVQUFPLElBQVk7UUFDakIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7T0FFRztJQUNILGdDQUFLLEdBQUw7O1FBQ0UsSUFBSSxDQUFDLElBQUksRUFBRTtnQ0FDRixJQUFJO1lBQ1gsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFLLE9BQU8sQ0FBQyxNQUFNLENBQUMsY0FBSSxJQUFJLFdBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQW5DLENBQW1DLENBQUMsQ0FBQzs7OztZQUQvRSxLQUFpQiw4QkFBSSxDQUFDLGFBQWE7Z0JBQTlCLElBQUksSUFBSTt3QkFBSixJQUFJO2FBRVo7Ozs7Ozs7OztRQUNELElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRTtJQUNuQixDQUFDO0lBRUQ7O09BRUc7SUFDSCwrQkFBSSxHQUFKO1FBQ0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQztZQUNyQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7Z0JBQzlCLE9BQU8sQ0FBQzthQUNUO1lBQ0QsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLGNBQWMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLGNBQWMsRUFBRTtnQkFDM0QsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLGNBQWMsS0FBSyxrREFBc0IsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2pGO1lBQ0QsT0FBTyxDQUFDO1FBQ1YsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUdELHNCQUFJLHdDQUFVO1FBRGQsMkNBQTJDO2FBQzNDO1lBQ0UsT0FBTyxJQUFJLENBQUMsV0FBVztRQUN6QixDQUFDOzs7T0FBQTtJQUdELHNCQUFJLDBDQUFZO1FBRGhCLDZDQUE2QzthQUM3QztZQUNFLE9BQU8sSUFBSSxDQUFDLGFBQWE7UUFDM0IsQ0FBQzs7O09BQUE7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsd0NBQWEsR0FBYixVQUFjLE1BQXNCLEVBQUUsS0FBMEI7O1FBQzlELElBQUksTUFBTSxHQUFHLE1BQU0sWUFBWSxhQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDOztZQUMvRCxLQUFpQixzQ0FBTSxpRkFBRTtnQkFBcEIsSUFBSSxJQUFJO2dCQUNYLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLFlBQVksb0NBQWdCLEVBQUU7b0JBQ3RELElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLEdBQUcsS0FBSztpQkFDekM7Z0JBQ0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO2FBQzdDOzs7Ozs7Ozs7UUFDRCxJQUFJLEtBQUssRUFBRTtZQUNULElBQUksQ0FBQyxXQUFXLENBQUMscUJBQXFCLENBQUMsS0FBSyxDQUFDO1NBQzlDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILHlDQUFjLEdBQWQsVUFBZSxNQUFzQjs7UUFDbkMsSUFBSSxNQUFNLEdBQUcsTUFBTSxZQUFZLGFBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7O1lBQy9ELEtBQWlCLHNDQUFNLGlGQUFFO2dCQUFwQixJQUFJLElBQUk7Z0JBQ1gsSUFBSSxJQUFJLENBQUMsUUFBUSxZQUFZLG9DQUFnQixFQUFFO29CQUM3QyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixHQUFHLFNBQVM7aUJBQzdDO2dCQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQzthQUM5Qzs7Ozs7Ozs7O0lBQ0gsQ0FBQztJQUNILHVCQUFDO0FBQUQsQ0FBQyxDQS9JcUMsSUFBSSxDQUFDLGNBQWMsR0ErSXhEO0FBL0lZLDRDQUFnQjtBQWlKN0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxFQUFPLGdCQUFnQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pLL0QsK0VBQStCO0FBRS9CLGFBQWE7QUFDQSxxQkFBYSxHQUE4QixJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIMUcsK0VBQStCO0FBRS9CLGFBQWE7QUFDQSx5QkFBaUIsR0FBa0MsSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsaUJBQWlCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0gxSCwrRUFBK0I7QUFFL0IsYUFBYTtBQUNBLHNCQUFjLEdBQStCLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0g5RywrRUFBK0I7QUFFL0IsYUFBYTtBQUNBLG9CQUFZLEdBQTZCLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZOzs7Ozs7Ozs7Ozs7Ozs7O0FDRHRHLElBQWlCLFFBQVEsQ0FnSHhCO0FBaEhELFdBQWlCLFFBQVE7SUFDdkIsSUFBSSx3QkFBNEM7SUFFaEQsU0FBZ0IsMEJBQTBCLENBQUMsUUFBdUI7UUFDaEUsSUFBSSx3QkFBd0IsS0FBSyxTQUFTLEVBQUU7WUFDMUMsT0FBTyx3QkFBd0I7U0FDaEM7UUFDRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsRUFBRTtRQUN0Qix3QkFBd0IsR0FBVyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQywwQkFBMEIsQ0FBQztRQUNqRixPQUFPLHdCQUF3QjtJQUNqQyxDQUFDO0lBUGUsbUNBQTBCLDZCQU96QztJQUVELElBQUksd0JBQTZDO0lBRWpELFNBQWdCLHVCQUF1QixDQUFDLFFBQXVCO1FBQzdELElBQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEtBQUssQ0FBQyxFQUFFO1lBQ3ZDLE9BQU8sSUFBSTtTQUNaO1FBQ0QsSUFBSSx3QkFBd0IsS0FBSyxTQUFTLEVBQUU7WUFDMUMsT0FBTyx3QkFBd0I7U0FDaEM7UUFDRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsRUFBRTtRQUN0QixJQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLG1CQUFtQixDQUFDO1FBQ2hELElBQUksR0FBRyxFQUFFO1lBQ1AsT0FBTyxJQUFJO1NBQ1o7UUFDRCxJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsYUFBYSxFQUFFO1FBQ2xDLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUM7UUFDdEMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUM7UUFDMUUsd0JBQXdCLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBQyxRQUFRO1FBQ3hELEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDO1FBQ3pCLE9BQU8sd0JBQXdCO0lBQ2pDLENBQUM7SUFsQmUsZ0NBQXVCLDBCQWtCdEM7SUFFRCxJQUFJLGdDQUFxRDtJQUV6RCxTQUFnQiwrQkFBK0IsQ0FBQyxRQUF1QjtRQUNyRSxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsWUFBWSxLQUFLLENBQUMsRUFBRTtZQUN2QyxPQUFPLElBQUk7U0FDWjtRQUNELElBQUksZ0NBQWdDLEtBQUssU0FBUyxFQUFFO1lBQ2xELE9BQU8sZ0NBQWdDO1NBQ3hDO1FBQ0QsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLEVBQUU7UUFDdEIsSUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyx3QkFBd0IsQ0FBQztRQUNyRCxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1IsT0FBTyxLQUFLO1NBQ2I7UUFDRCxJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsYUFBYSxFQUFFO1FBQ2xDLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUM7UUFDdEMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUM7UUFDcEYsSUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixFQUFFO1FBQ2pDLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUM7UUFDdEMsSUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDLGlCQUFpQjtRQUM1QyxFQUFFLENBQUMsb0JBQW9CLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxlQUFlLEVBQUUsRUFBRSxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ25GLGdDQUFnQyxHQUFHLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDLG9CQUFvQjtRQUN4RyxPQUFPLGdDQUFnQztJQUN6QyxDQUFDO0lBckJlLHdDQUErQixrQ0FxQjlDO0lBRUQsSUFBSSw0QkFBaUQ7SUFFckQsU0FBZ0IsMkJBQTJCLENBQUMsUUFBdUI7UUFDakUsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLFlBQVksS0FBSyxDQUFDLEVBQUU7WUFDdkMsT0FBTyxJQUFJO1NBQ1o7UUFDRCxJQUFJLDRCQUE0QixLQUFLLFNBQVMsRUFBRTtZQUM5QyxPQUFPLDRCQUE0QjtTQUNwQztRQUNELElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxFQUFFO1FBQ3RCLElBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUM7UUFDaEQsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLE9BQU8sS0FBSztTQUNiO1FBQ0QsSUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLGFBQWEsRUFBRTtRQUNsQyxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDO1FBQ3RDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDO1FBQzFFLElBQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRTtRQUNqQyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDO1FBQ3RDLElBQU0sZUFBZSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUI7UUFDNUMsRUFBRSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsZUFBZSxFQUFFLEVBQUUsQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNuRiw0QkFBNEIsR0FBRyxFQUFFLENBQUMsc0JBQXNCLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxvQkFBb0I7UUFDcEcsT0FBTyw0QkFBNEI7SUFDckMsQ0FBQztJQXJCZSxvQ0FBMkIsOEJBcUIxQztJQUVELElBQUksdUJBQTRDO0lBRWhELFNBQWdCLG1CQUFtQixDQUFDLFFBQXVCO1FBQ3pELElBQUksdUJBQXVCLEtBQUssU0FBUyxFQUFFO1lBQ3pDLE9BQU8sdUJBQXVCO1NBQy9CO1FBQ0QsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLEVBQUU7UUFDdEIsdUJBQXVCLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQywwQkFBMEIsQ0FBQyxLQUFLLElBQUk7UUFDOUUsT0FBTyx1QkFBdUI7SUFDaEMsQ0FBQztJQVBlLDRCQUFtQixzQkFPbEM7SUFFRCxTQUFnQiwyQkFBMkIsQ0FBQyxRQUF1QjtRQUNqRSxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsWUFBWSxLQUFLLENBQUMsRUFBRTtZQUN2QyxPQUFPLElBQUk7U0FDWjtRQUNELE9BQU8sUUFBUSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsd0JBQXdCLENBQUMsS0FBSyxJQUFJO0lBQ3BFLENBQUM7SUFMZSxvQ0FBMkIsOEJBSzFDO0lBRUQsSUFBSSxzQkFBMkM7SUFFL0MsU0FBZ0IscUJBQXFCLENBQUMsUUFBdUI7UUFDM0QsSUFBSSxzQkFBc0IsS0FBSyxTQUFTLEVBQUU7WUFDeEMsT0FBTyxzQkFBc0I7U0FDOUI7UUFDRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsRUFBRTtRQUN0QixzQkFBc0IsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLHdCQUF3QixDQUFDLEtBQUssU0FBUztRQUNoRixPQUFPLHNCQUFzQjtJQUMvQixDQUFDO0lBUGUsOEJBQXFCLHdCQU9wQztBQUNILENBQUMsRUFoSGdCLFFBQVEsR0FBUixnQkFBUSxLQUFSLGdCQUFRLFFBZ0h4Qjs7Ozs7Ozs7Ozs7O0FDbEhELDZGQUE2RixtQ0FBbUMsK0JBQStCLDZCQUE2QixvQ0FBb0MsaUJBQWlCLDJCQUEyQiw4RkFBOEYsNEZBQTRGLDZGQUE2Riw2RkFBNkYsNkZBQTZGLDRGQUE0Riw0RkFBNEYsMkJBQTJCLEdBQUcsQzs7Ozs7Ozs7Ozs7QUNBbjdCLDREQUE0RCx1QkFBdUIsdUJBQXVCLGlCQUFpQixrQkFBa0Isd0NBQXdDLEdBQUcsQzs7Ozs7Ozs7Ozs7QUNBeEwsZ0pBQWdKLG1DQUFtQyx5QkFBeUIsaUNBQWlDLG1CQUFtQixtQkFBbUIsK0RBQStELHVCQUF1QiwyRUFBMkUsOERBQThELEdBQUcsQzs7Ozs7Ozs7Ozs7QUNBcmYsZ0ZBQWdGLGlEQUFpRCwyQkFBMkIsZ0RBQWdELDZCQUE2QixtR0FBbUcsMkRBQTJELHlSQUF5UiwwRkFBMEYscVRBQXFULG9EQUFvRCxlQUFlLCtCQUErQiwwQkFBMEIsNE5BQTROLGtCQUFrQixHQUFHLHlCQUF5QixxQ0FBcUMsNkRBQTZELHlFQUF5RSxHQUFHLEM7Ozs7Ozs7Ozs7Ozs7OztBQ0dubUQscUdBQWtEO0FBRWxELDZFQUFzQztBQUN0QyxxR0FBZ0Q7QUFDaEQscUdBQWdEO0FBQ2hELDRGQUEwQztBQUUxQzs7R0FFRztBQUNIO0lBa0NFOzs7Ozs7Ozs7OztPQVdHO0lBQ0gsNEJBQW1CLFFBQXVCLEVBQVMsS0FBWSxFQUFFLGlCQUF5QixFQUFTLFVBQWtCLEVBQVMsUUFBWSxFQUFFLE9BQThCO1FBQTVDLHVDQUFZO1FBQUUsb0NBQVUsOEJBQWEsQ0FBQyxNQUFNO1FBQXZKLGFBQVEsR0FBUixRQUFRLENBQWU7UUFBUyxVQUFLLEdBQUwsS0FBSyxDQUFPO1FBQW9DLGVBQVUsR0FBVixVQUFVLENBQVE7UUFBUyxhQUFRLEdBQVIsUUFBUSxDQUFJO1FBM0NsSSx5QkFBb0IsR0FBRyxJQUFJLFlBQVksQ0FBQyxFQUFFLENBQUM7UUFVbkQ7Ozs7V0FJRztRQUNILGlCQUFZLEdBQUcsSUFBSTtRQTZCakIsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLHNCQUFTLENBQUMsS0FBSyxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkVBQTJFLENBQUM7U0FDN0Y7UUFDRCxJQUFJLENBQUMsY0FBYyxHQUFHLDhCQUFhLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxPQUFPLENBQUM7UUFDaEYsSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRTtRQUM3RCxJQUFJLENBQUMsY0FBYyxHQUFHLDhCQUFhLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxPQUFPLENBQUM7SUFDbEYsQ0FBQztJQS9DRCxzQkFBSSxtREFBbUI7UUFEdkIsd0NBQXdDO2FBQ3hDO1lBQ0UsT0FBTyxJQUFJLENBQUMsb0JBQW9CO1FBQ2xDLENBQUM7OztPQUFBO0lBZUQsc0JBQUksNkNBQWE7UUFIakI7O1dBRUc7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLGNBQWM7UUFDNUIsQ0FBQzs7O09BQUE7SUFLRCxzQkFBSSw2Q0FBYTtRQUhqQjs7V0FFRzthQUNIO1lBQ0UsT0FBTyxJQUFJLENBQUMsY0FBYztRQUM1QixDQUFDOzs7T0FBQTtJQXVCRDs7T0FFRztJQUNILG9DQUFPLEdBQVA7UUFDRSxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDakMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNILGtDQUFLLEdBQUw7UUFDRSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztRQUNyRCxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztRQUN0SCxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7T0FFRztJQUNILHNEQUF5QixHQUF6QjtRQUNFLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssc0JBQVMsQ0FBQyxXQUFXLEVBQUU7WUFDN0Msd0JBQVUsQ0FBQyx1Q0FBdUMsQ0FBQyxJQUFJLENBQUM7U0FDekQ7YUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLHNCQUFTLENBQUMsSUFBSSxFQUFFO1lBQzdDLHdCQUFVLENBQUMsZ0NBQWdDLENBQUMsSUFBSSxDQUFDO1NBQ2xEO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSwyQ0FBd0IsR0FBL0IsVUFBZ0MsUUFBdUI7UUFDckQsT0FBTyxtQkFBUSxDQUFDLCtCQUErQixDQUFDLFFBQVEsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLHlDQUFzQixHQUE3QixVQUE4QixRQUF1QjtRQUNuRCxPQUFPLG1CQUFRLENBQUMsMkJBQTJCLENBQUMsUUFBUSxDQUFDO0lBQ3ZELENBQUM7SUFDSCx5QkFBQztBQUFELENBQUM7QUFwR1ksZ0RBQWtCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2IvQiwrRUFBK0I7QUFFL0IsZ0dBQWdEO0FBQ2hELDJFQUFxQztBQUdyQztJQUlFLHNCQUFtQixRQUF1QjtRQUF2QixhQUFRLEdBQVIsUUFBUSxDQUFlO1FBQ3hDLElBQUksQ0FBQyxLQUFLLEdBQUcsYUFBTSxDQUFDLFVBQVUsRUFBRTtRQUNoQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSx3QkFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUN6RCxtQkFBTyxDQUFDLDJFQUE2QixDQUFDLEVBQ3RDLG1CQUFPLENBQUMsMkVBQTZCLENBQUMsQ0FDdkMsQ0FBQztJQUNKLENBQUM7SUFFRCx3Q0FBaUIsR0FBakIsVUFBa0IsS0FBeUI7UUFDekMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxhQUFhLEVBQzFELElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3JFLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsYUFBYSxFQUMxRCxJQUFJLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBRUQscUNBQWMsR0FBZCxVQUFlLEtBQXlCLEVBQUUsTUFBMEIsRUFBRSxLQUFtQjtRQUN2RixJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRTtRQUVuQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLGVBQWUsR0FBRyxLQUFLO1FBQ3pELElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsV0FBVyxHQUFHLEtBQUs7UUFDckQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUM7UUFFMUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUM3QyxDQUFDO0lBQ0gsbUJBQUM7QUFBRCxDQUFDO0FBN0JZLG9DQUFZOzs7Ozs7Ozs7Ozs7Ozs7OztBQ056QiwrRUFBK0I7QUFHL0IsMkVBQW1DO0FBQ25DLHFHQUFrRDtBQUNsRCwyRUFBbUM7QUFDbkMsMkVBQW1DO0FBQ25DLHFGQUF5QztBQUV6QyxJQUFpQixVQUFVLENBeUQxQjtBQXpERCxXQUFpQixVQUFVO0lBRXpCLElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxZQUFZLENBQUMsRUFBRSxDQUFDO0lBQzdDLElBQU0sVUFBVSxHQUFHLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQztJQUN2QyxJQUFNLEdBQUcsR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkMsSUFBTSxrQkFBa0IsR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDOUMsSUFBTSxtQkFBbUIsR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDL0MsSUFBTSxrQkFBa0IsR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDOUMsSUFBTSxhQUFhLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLElBQU0sY0FBYyxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQztJQUUxQyxTQUFnQix1Q0FBdUMsQ0FBQyxrQkFBc0M7UUFDNUYsSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLHNCQUFTLENBQUMsV0FBVyxFQUFFO1lBQzNELE9BQU07U0FDUDtRQUNELElBQUksY0FBYyxHQUFHLGtCQUFrQixDQUFDLFVBQVUsR0FBRyxDQUFDO1FBQ3RELElBQUksY0FBYyxHQUFHLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLFVBQVU7UUFDekUsSUFBSSxlQUFlLEdBQUcsV0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRSxjQUFjLEVBQzlELENBQUMsY0FBYyxFQUFFLGNBQWMsRUFBRSxDQUFDLGNBQWMsRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLENBQUM7UUFDckYsSUFBSSxLQUFLLEdBQUcsa0JBQWtCLENBQUMsS0FBSztRQUNwQyxJQUFJLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLElBQUksZUFBTSxDQUFDLElBQUk7UUFFckQsSUFBSSxNQUFNLElBQUksa0JBQWtCLENBQUMsWUFBWSxFQUFFO1lBQzdDLFdBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQztZQUN6RSxXQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSxhQUFhLENBQUM7WUFDdkUsV0FBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLEVBQUUsV0FBSSxDQUFDLFNBQVMsQ0FDOUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsa0JBQWtCLENBQUMsRUFBRSxtQkFBbUIsQ0FBQztZQUU3RixtQkFBbUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxjQUFjO2dCQUNyQyxJQUFJLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQztZQUNyRCxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxjQUFjO2dCQUNyQyxJQUFJLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQztZQUVyRCxXQUFJLENBQUMsYUFBYSxDQUFDLG1CQUFtQixFQUFFLEtBQUssQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLG1CQUFtQixDQUFDO1lBQzNGLFdBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsS0FBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLENBQUM7WUFDL0UsV0FBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxrQkFBa0IsRUFBRSxLQUFLLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUM7WUFDekYsV0FBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixDQUFDLG1CQUFtQixDQUFDO1NBQ25GO2FBQU07WUFDTCxXQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUNwQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUM7WUFDakUsV0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFDdkMsYUFBYSxFQUFFLEtBQUssQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQztZQUNyRCxXQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxVQUFVLEVBQUUsa0JBQWtCLENBQUMsbUJBQW1CLENBQUM7U0FDbkY7SUFDSCxDQUFDO0lBakNlLGtEQUF1QywwQ0FpQ3REO0lBRUQsU0FBZ0IsZ0NBQWdDLENBQUMsa0JBQXNDO1FBQ3JGLElBQUksa0JBQWtCLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxzQkFBUyxDQUFDLElBQUksRUFBRTtZQUNwRCxPQUFNO1NBQ1A7UUFDRCxJQUFJLEtBQUssR0FBRyxrQkFBa0IsQ0FBQyxLQUFLO1FBRXBDLFdBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsZ0JBQWdCLENBQUM7UUFDakcsV0FBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUM7UUFDcEYsV0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxhQUFhLEVBQUUsS0FBSyxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDO1FBQzlGLFdBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixDQUFDLG1CQUFtQixDQUFDO0lBQ3JGLENBQUM7SUFWZSwyQ0FBZ0MsbUNBVS9DO0FBQ0gsQ0FBQyxFQXpEZ0IsVUFBVSxHQUFWLGtCQUFVLEtBQVYsa0JBQVUsUUF5RDFCOzs7Ozs7Ozs7Ozs7Ozs7O0FDbEVELElBQVksYUFhWDtBQWJELFdBQVksYUFBYTtJQUN2Qjs7T0FFRztJQUNILDRCQUFZO0lBQ1o7O09BRUc7SUFDSCxrQ0FBaUI7SUFDakI7O09BRUc7SUFDSCw4QkFBYTtBQUNmLENBQUMsRUFiVyxhQUFhLEdBQWIscUJBQWEsS0FBYixxQkFBYSxRQWF4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNURCxrR0FBOEM7QUFFOUMsd0dBQWtEO0FBRWxEOztHQUVHO0FBQ0g7SUFLRTs7OztPQUlHO0lBQ0gsMEJBQW1CLFFBQXVCLEVBQVMsSUFBZTtRQUFmLHNDQUFlO1FBQS9DLGFBQVEsR0FBUixRQUFRLENBQWU7UUFBUyxTQUFJLEdBQUosSUFBSSxDQUFXO1FBVDFELFlBQU8sR0FBeUIsRUFBRTtRQVV4QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksNEJBQVksQ0FBQyxRQUFRLENBQUM7UUFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGdDQUFjLENBQUMsUUFBUSxDQUFDO0lBQzdDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxnREFBcUIsR0FBckIsVUFBc0Isa0JBQXNDO1FBQzFELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDaEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUM7U0FDdEM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsbURBQXdCLEdBQXhCLFVBQXlCLGtCQUFzQztRQUM3RCxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQztRQUN0RCxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7WUFDZCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQzlCO0lBQ0gsQ0FBQztJQUVELGdDQUFLLEdBQUw7OztZQUNFLEtBQStCLDhCQUFJLENBQUMsT0FBTyw2Q0FBRTtnQkFBeEMsSUFBSSxrQkFBa0I7Z0JBQ3pCLGtCQUFrQixDQUFDLEtBQUssRUFBRTthQUMzQjs7Ozs7Ozs7O0lBQ0gsQ0FBQztJQUVELGlDQUFNLEdBQU4sVUFBTyxNQUFnQjs7UUFDckIsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDcEQsT0FBTTtTQUNQO1FBQ0QsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTzs7WUFDbkQsS0FBK0IsOEJBQUksQ0FBQyxPQUFPLDZDQUFFO2dCQUF4QyxJQUFJLGtCQUFrQjtnQkFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQztnQkFDbEUsa0JBQWtCLENBQUMseUJBQXlCLEVBQUU7O29CQUM5QyxLQUFpQixxREFBTSxrRkFBRTt3QkFBcEIsSUFBSSxJQUFJO3dCQUNYLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxrQkFBa0IsQ0FBQztxQkFDOUM7Ozs7Ozs7OztnQkFDRCxJQUFJLGtCQUFrQixDQUFDLFFBQVEsR0FBRyxDQUFDLEVBQUU7b0JBQ25DLElBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsa0JBQWtCLENBQUM7aUJBQ25EO2FBQ0Y7Ozs7Ozs7OztRQUNELElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDM0MsQ0FBQztJQUNILHVCQUFDO0FBQUQsQ0FBQztBQTNEWSw0Q0FBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWDdCLCtFQUErQjtBQUUvQixrR0FBOEM7QUFHOUMsd0dBQWtEO0FBQ2xELHFHQUFnRDtBQUdoRDtJQVFFLHdCQUFtQixRQUF1QjtRQUF2QixhQUFRLEdBQVIsUUFBUSxDQUFlO1FBUGxDLFdBQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQy9DLFNBQVMsRUFBRSxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSTtTQUM1RixDQUFDO1FBTUEsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLDRCQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN0RCxDQUFDO0lBRUQsK0JBQU0sR0FBTixVQUFPLElBQVksRUFBRSxrQkFBc0M7UUFDekQsSUFBSSxNQUFNLEdBQTZCLElBQUksQ0FBQyxhQUFhO1FBQ3pELElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRTtZQUM5RCxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQkFDekIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLGdDQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzthQUN6RDtZQUNELE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZTtZQUM3QixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGtCQUFrQixFQUFFO2dCQUNyRSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtvQkFDeEIsSUFBSSw4QkFBYSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7d0JBQzVDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSw4QkFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7cUJBQ3ZEO2lCQUNGO2dCQUNELE1BQU0sR0FBRyxJQUFJLENBQUMsY0FBYzthQUM3QjtTQUNGO1FBQ0QsSUFBSSxNQUFNLEVBQUU7WUFDVixNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxrQkFBa0IsQ0FBQztZQUMvQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDaEQ7SUFDSCxDQUFDO0lBQ0gscUJBQUM7QUFBRCxDQUFDO0FBakNZLHdDQUFjOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1QzQiwrRUFBK0I7QUFHL0IsZ0dBQWdEO0FBQ2hELDJKQUFrRjtBQUlsRjtJQUFrQyx3Q0FBVTtJQUMxQyxzQkFBWSxRQUF1QixFQUFFLFFBQXVCO1FBQXZCLHdDQUF1QjtRQUE1RCxpQkFPQztRQU5DLElBQUksSUFBSSxHQUFHLG1CQUFPLENBQUMsNkRBQXNCLENBQUM7UUFDMUMsSUFBSSxJQUFJLEdBQUcsbUJBQU8sQ0FBQyw2REFBc0IsQ0FBQztRQUUxQywwQkFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FDckIsNkNBQW9CLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLEVBQ3BELDZDQUFvQixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7O0lBQzFELENBQUM7SUFFRCwyQ0FBb0IsR0FBcEIsVUFBcUIsUUFBd0I7UUFDM0MsSUFBSSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1FBQ2hDLElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRTtZQUNwQixJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLGlCQUFpQixLQUFLLENBQUMsRUFBRTtnQkFDbkQsZ0ZBQWdGO2dCQUNoRixNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7YUFDM0U7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMxRDtTQUNGO1FBQ0QsSUFBSSxRQUFRLENBQUMsU0FBUyxFQUFFO1lBQ3RCLE1BQU0sQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUMxRSxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1NBQ3pFO1FBQ0QsT0FBTyxNQUFNO0lBQ2YsQ0FBQztJQUVELHNCQUFJLDhCQUFJO2FBQVI7WUFDRSxPQUFPLGVBQWU7UUFDeEIsQ0FBQzs7O09BQUE7SUFFRCxxQ0FBYyxHQUFkLFVBQWUsSUFBWSxFQUFFLGtCQUFzQztRQUNqRSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUs7UUFDdkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsR0FBRyxrQkFBa0IsQ0FBQyxtQkFBbUI7SUFDL0UsQ0FBQztJQUNILG1CQUFDO0FBQUQsQ0FBQyxDQW5DaUMsd0JBQVUsR0FtQzNDO0FBbkNZLG9DQUFZOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1J6QiwrRUFBK0I7QUFFL0IscUdBQWdEO0FBQ2hELDZFQUFzQztBQUV0QyxJQUFpQixhQUFhLENBNkI3QjtBQTdCRCxXQUFpQixhQUFhO0lBQzVCLFNBQWdCLE1BQU0sQ0FBQyxRQUF1QixFQUFFLElBQVksRUFBRSxPQUFzQjtRQUNsRixJQUFJLElBQUksR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDO1FBQzlDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUM7WUFDL0IsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLHFCQUFxQixDQUFDLFFBQVEsQ0FBQztTQUNsRixDQUFDO0lBQ0osQ0FBQztJQUxlLG9CQUFNLFNBS3JCO0lBRUQsU0FBUyxxQkFBcUIsQ0FBQyxRQUF1QjtRQUNwRCxJQUFJLG1CQUFRLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDMUMsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU07U0FDL0I7UUFDRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTztJQUNqQyxDQUFDO0lBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxRQUF1QixFQUFFLE9BQXNCO1FBQ3ZFLElBQUksT0FBTyxLQUFLLDhCQUFhLENBQUMsSUFBSSxFQUFFO1lBQ2xDLElBQUksbUJBQVEsQ0FBQywyQkFBMkIsQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDbEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUs7YUFDeEI7WUFDRCxJQUFJLG1CQUFRLENBQUMsK0JBQStCLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ3RELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVO2FBQzdCO1NBQ0Y7UUFDRCxJQUFJLE9BQU8sS0FBSyw4QkFBYSxDQUFDLE1BQU0sSUFBSSxtQkFBUSxDQUFDLCtCQUErQixDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzFGLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVO1NBQzdCO1FBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWE7SUFDakMsQ0FBQztBQUNILENBQUMsRUE3QmdCLGFBQWEsR0FBYixxQkFBYSxLQUFiLHFCQUFhLFFBNkI3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQ0QsK0VBQStCO0FBSS9CLDZFQUFzQztBQUV0QyxrR0FBOEM7QUFFOUM7SUFBb0MsMENBQVk7SUFPOUMsd0JBQVksUUFBdUI7UUFBbkMsaUJBU0M7UUFSQyxJQUFJLGdDQUFnQyxHQUFHLENBQUM7UUFDeEMsSUFBSSx1QkFBdUIsR0FDekIsbUJBQVEsQ0FBQywwQkFBMEIsQ0FBQyxRQUFRLENBQUMsR0FBRyxnQ0FBZ0M7UUFDbEYsSUFBSSx3QkFBd0IsR0FBRyxDQUFDO1FBQ2hDLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsdUJBQXVCLEdBQUcsd0JBQXdCLENBQUM7UUFFbEYsMEJBQU0sUUFBUSxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsa0JBQWtCLEdBQUcsYUFBYSxDQUFDLENBQUM7UUFDdkUsS0FBSSxDQUFDLG1CQUFtQixHQUFHLGFBQWE7O0lBQzFDLENBQUM7SUFiRCxzQkFBSSw4Q0FBa0I7YUFBdEI7WUFDRSxPQUFPLElBQUksQ0FBQyxtQkFBbUI7UUFDakMsQ0FBQzs7O09BQUE7SUFhRCw2Q0FBb0IsR0FBcEIsVUFBcUIsUUFBd0I7UUFDM0MsSUFBSSxNQUFNLEdBQUcsaUJBQU0sb0JBQW9CLFlBQUMsUUFBUSxDQUFDO1FBQ2pELElBQUksUUFBUSxDQUFDLE1BQU0sRUFBRTtZQUNuQixNQUFNLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFDckUsQ0FBQyxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUNuRTtRQUNELElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRTtZQUNwQixNQUFNLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFDdkUsQ0FBQyxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztTQUNyRTtRQUNELE9BQU8sTUFBTTtJQUNmLENBQUM7SUFFRCxzQkFBSSxnQ0FBSTthQUFSO1lBQ0UsT0FBTyx1QkFBdUI7UUFDaEMsQ0FBQzs7O09BQUE7SUFFRCx1Q0FBYyxHQUFkLFVBQWUsSUFBWSxFQUFFLGtCQUFzQztRQUNqRSxpQkFBTSxjQUFjLFlBQUMsSUFBSSxFQUFFLGtCQUFrQixDQUFDO1FBQzlDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2QsT0FBTTtTQUNQO1FBQ0ssdUJBQW1CLEdBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxvQkFBdkMsQ0FBdUM7UUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLEdBQUcsbUJBQW1CO0lBQ25ELENBQUM7SUFDSCxxQkFBQztBQUFELENBQUMsQ0EzQ21DLDRCQUFZLEdBMkMvQztBQTNDWSx3Q0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSM0IsK0VBQStCO0FBSy9CLGtHQUE4QztBQUM5Qyx5TEFBcUc7QUFFckcsSUFBTSxvQkFBb0IsR0FBRyxHQUFHO0FBRWhDO0lBQW1DLHlDQUFZO0lBVzdDLHVCQUFZLFFBQXVCO1FBQW5DLFlBQ0Usa0JBQU0sUUFBUSxFQUFFO1lBQ2QsZ0JBQWdCLEVBQUUsd0JBQXdCLEVBQUUsa0JBQWtCLEdBQUcsb0JBQW9CO1NBQ3RGLENBQUMsU0FHSDtRQUZDLEtBQUksQ0FBQyxtQkFBbUI7WUFDdEIsSUFBSSxnRUFBNkIsQ0FBQyxvQkFBb0IsQ0FBQzs7SUFDM0QsQ0FBQztJQWRELHNCQUFJLDZDQUFrQjthQUF0QjtZQUNFLE9BQU8sb0JBQW9CO1FBQzdCLENBQUM7OztPQUFBO0lBRU0seUJBQVcsR0FBbEIsVUFBbUIsUUFBdUI7UUFDeEMsT0FBTyxnRUFBNkIsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDO0lBQzVELENBQUM7SUFVRCw0Q0FBb0IsR0FBcEIsVUFBcUIsUUFBd0I7UUFDM0MsSUFBSSxNQUFNLEdBQUcsaUJBQU0sb0JBQW9CLFlBQUMsUUFBUSxDQUFDO1FBQ2pELElBQUksUUFBUSxDQUFDLE1BQU0sRUFBRTtZQUNuQixNQUFNLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFDckUsQ0FBQyxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUNuRTtRQUNELElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRTtZQUNwQixNQUFNLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFDdkUsQ0FBQyxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztTQUNyRTtRQUNELE9BQU8sTUFBTTtJQUNmLENBQUM7SUFFRCxzQkFBSSwrQkFBSTthQUFSO1lBQ0UsT0FBTyx1QkFBdUI7UUFDaEMsQ0FBQzs7O09BQUE7SUFFRCxzQ0FBYyxHQUFkLFVBQWUsSUFBWSxFQUFFLGtCQUFzQztRQUNqRSxpQkFBTSxjQUFjLFlBQUMsSUFBSSxFQUFFLGtCQUFrQixDQUFDO1FBQzlDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2QsT0FBTTtTQUNQO1FBQ0ssdUJBQW1CLEdBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxvQkFBdkMsQ0FBdUM7UUFDaEUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQztRQUMxRCxJQUFJLENBQUMsUUFBUSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQyxtQkFBbUI7SUFDL0QsQ0FBQztJQUNILG9CQUFDO0FBQUQsQ0FBQyxDQTdDa0MsNEJBQVksR0E2QzlDO0FBN0NZLHNDQUFhOzs7Ozs7Ozs7Ozs7Ozs7O0FDUjFCOztHQUVHO0FBQ0g7SUFDRTs7OztPQUlHO0lBQ0gsZUFBbUIsSUFBaUIsRUFBUyxpQkFBK0I7UUFBekQsU0FBSSxHQUFKLElBQUksQ0FBYTtRQUFTLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBYztJQUM1RSxDQUFDO0lBQ0gsWUFBQztBQUFELENBQUM7QUFSWSxzQkFBSzs7Ozs7Ozs7Ozs7Ozs7OztBQ0xsQiwyRUFBbUM7QUFJbkM7O0dBRUc7QUFDSDtJQUNFOzs7O09BSUc7SUFDSCxjQUFtQixNQUFtQixFQUFTLE1BQWU7UUFBM0MsV0FBTSxHQUFOLE1BQU0sQ0FBYTtRQUFTLFdBQU0sR0FBTixNQUFNLENBQVM7UUFVdEQseUJBQW9CLEdBQW1CLEVBQUU7UUFFekMseUJBQW9CLEdBQW1CLEVBQUU7UUFYL0MsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ2hFLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNoRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN0QyxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDbEcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxFQUFFLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ25HO0lBQ0gsQ0FBQztJQU9EOztPQUVHO0lBQ0gscUNBQXNCLEdBQXRCO1FBQ0UsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNDOzs7O2tDQUlzQjtZQUN0QixXQUFJLENBQUMsUUFBUSxDQUF3QixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUMzRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVqRTs7O2lEQUdxQztZQUNyQyxXQUFJLENBQUMsUUFBUSxDQUF3QixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQ3BGLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFN0QsV0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZFLFdBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzRTtRQUNELE9BQU87WUFDTCxtQkFBbUIsRUFBRSxJQUFJLENBQUMsb0JBQW9CO1lBQzlDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxvQkFBb0I7U0FDL0M7SUFDSCxDQUFDO0lBQ0gsV0FBQztBQUFELENBQUM7QUFoRFksb0JBQUk7Ozs7Ozs7Ozs7OztBQ1BqQiwwQ0FBMEMsNkNBQTZDLGlCQUFpQixnRkFBZ0YsR0FBRyxDOzs7Ozs7Ozs7OztBQ0EzTCw0Q0FBNEMsNEJBQTRCLCtCQUErQixzQkFBc0IsNEJBQTRCLGlCQUFpQixnQ0FBZ0MsaVJBQWlSLEdBQUcsQzs7Ozs7Ozs7Ozs7Ozs7OztBQ0E5ZCwrRUFBK0I7QUFHL0IsZ0dBQWdEO0FBQ2hELHFGQUF5QztBQUV6QywrRkFBK0M7QUFFL0M7SUFBb0MsMENBQVE7SUFxQjFDLHdCQUFZLE9BQWdCO1FBQTVCLFlBQ0UsaUJBQU8sU0FLUjtRQUpDLEtBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTztRQUN2QixLQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDM0MsT0FBTyxFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUk7U0FDekQsQ0FBQzs7SUFDSixDQUFDO0lBeEJELHNCQUFJLG1DQUFPO2FBQVg7WUFDRSxPQUFPLElBQUksQ0FBQyxRQUFRO1FBQ3RCLENBQUM7YUFFRCxVQUFZLEtBQWM7WUFDeEIsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFO29CQUN4QixxRUFBcUU7b0JBQ3JFLHVFQUF1RTtvQkFDdkUscUVBQXFFO29CQUNyRSxJQUFJLENBQUMsT0FBTyxHQUFHLFNBQVM7aUJBQ3pCO2dCQUNELElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSzthQUN0QjtRQUNILENBQUM7OztPQVpBO0lBd0JELHVDQUFjLEdBQWQsVUFBZSxJQUFZLEVBQUUsTUFBa0I7UUFDN0MsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxlQUFNLENBQUMsSUFBSTtRQUV2QyxNQUFNLENBQUMsUUFBUSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUs7UUFDekQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUk7UUFDcEMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDLFVBQVU7UUFDaEQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsT0FBTztJQUNyRCxDQUFDO0lBRUQsK0JBQU0sR0FBTixVQUFPLElBQVksRUFBRSxRQUF1QjtRQUMxQywwRUFBMEU7UUFDMUUsd0NBQXdDO1FBQ3hDLFFBQVEsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztRQUM1QixpQkFBTSxNQUFNLFlBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztRQUM1QixRQUFRLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7SUFDN0IsQ0FBQztJQUVELHFDQUFZLEdBQVo7UUFDRSxJQUFJLElBQUksR0FBRyxtQkFBTyxDQUFDLDZEQUFzQixDQUFDO1FBQzFDLElBQUksSUFBSSxHQUFHLG1CQUFPLENBQUMsNkRBQXNCLENBQUM7UUFFMUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRTtZQUN0QixPQUFPLElBQUksd0JBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDckQ7SUFDSCxDQUFDO0lBQ0gscUJBQUM7QUFBRCxDQUFDLENBdERtQyxtQkFBUSxHQXNEM0M7QUF0RFksd0NBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUjNCLHdHQUFrRDtBQUNsRCwyRUFBcUM7QUFDckMsZ0ZBQTBDO0FBQzFDLDBGQUE0QztBQUk1Qzs7OztHQUlHO0FBQ0g7SUFBNEIsa0NBQVc7SUFHckM7OztPQUdHO0lBQ0gsZ0JBQVksT0FBZ0I7UUFBNUIsWUFDRSxpQkFBTyxTQUVSO1FBREMsS0FBSSxDQUFDLEtBQUssR0FBRyxLQUFJLENBQUMsUUFBUSxDQUFDLGFBQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxnQ0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7O0lBQzVFLENBQUM7SUFNRCxzQkFBSSwwQkFBTTtRQUpWOzs7V0FHRzthQUNIO1lBQ0UsT0FBd0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFTLENBQUMsTUFBTTtRQUNyRCxDQUFDO2FBRUQsVUFBVyxLQUF5QjtZQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVMsQ0FBQyxNQUFNLEdBQUcsS0FBSztRQUN0RCxDQUFDOzs7T0FKQTtJQVNELHNCQUFJLDJCQUFPO1FBSFg7O1dBRUc7YUFDSDtZQUNFLE9BQXdCLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUyxDQUFDLE9BQU87UUFDdEQsQ0FBQzthQUVELFVBQVksS0FBYztZQUNQLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUyxDQUFDLE9BQU8sR0FBRyxLQUFLO1FBQ3ZELENBQUM7OztPQUpBO0lBTUQ7OztPQUdHO0lBQ0ksV0FBSSxHQUFYLFVBQVksTUFBb0I7UUFDOUIsT0FBTyxJQUFJLE1BQU0sQ0FBQyxpQkFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBQ0gsYUFBQztBQUFELENBQUMsQ0ExQzJCLHVCQUFXLEdBMEN0QztBQTFDWSx3QkFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNabkIsK0VBQStCO0FBa0IvQjs7O0dBR0c7QUFDSDtJQUEwQyxnREFBVztJQWVuRDs7Ozs7T0FLRztJQUNILDhCQUFtQixRQUF1QixFQUFFLE9BQXFDO1FBQWpGLFlBQ0UsaUJBQU8sU0F1QlI7UUF4QmtCLGNBQVEsR0FBUixRQUFRLENBQWU7UUFHcEMsU0FBZ0QsT0FBTyxJQUFJLEVBQUUsRUFBM0QsYUFBVyxFQUFYLEtBQUssbUJBQUcsR0FBRyxPQUFFLGNBQVksRUFBWixNQUFNLG1CQUFHLEdBQUcsT0FBRSxjQUFjLG9CQUFrQjtRQUVqRSxLQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxTQUFFLE1BQU0sVUFBRSxDQUFDO1FBQ2xFOytEQUN1RDtRQUN2RCxLQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBRyxDQUFDO1FBQzlCLEtBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUU7UUFDN0QsS0FBSSxDQUFDLFFBQVEsR0FBRyxLQUFJLENBQUMsY0FBYztRQUVuQyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUU7WUFDakQsUUFBUSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUU7Z0JBQ3ZCLEtBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1lBQzNFLENBQUMsQ0FBQztTQUNIO1FBQ0QsSUFBSSxjQUFjLEVBQUU7WUFDbEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDO2dCQUNyQixJQUFJLEtBQUksQ0FBQyxZQUFZLElBQUksS0FBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLElBQUksS0FBSSxDQUFDLFVBQVUsRUFBRTtvQkFDL0QsY0FBYyxJQUFJLEtBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDO2lCQUNwRDtZQUNILENBQUMsQ0FBQztTQUNIOztJQUNILENBQUM7SUF6Q0Qsc0JBQUksK0NBQWE7UUFEakIsMEJBQTBCO2FBQzFCO1lBQ0UsT0FBTyxJQUFJLENBQUMsY0FBYztRQUM1QixDQUFDOzs7T0FBQTtJQUdELHNCQUFJLDhDQUFZO1FBRGhCLHlCQUF5QjthQUN6QjtZQUNFLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDdkIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsWUFBWTthQUNoRTtRQUNILENBQUM7OztPQUFBO0lBa0NEOzs7T0FHRztJQUNILDJDQUFZLEdBQVosVUFBYSxNQUEwQjtRQUNyQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUNuRCxDQUFDO0lBQ0gsMkJBQUM7QUFBRCxDQUFDLENBdER5QyxJQUFJLENBQUMsTUFBTSxHQXNEcEQ7QUF0RFksb0RBQW9COzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCakMsK0VBQStCO0FBRS9CO0lBQXNDLDRDQUFXO0lBSy9DLDBCQUFZLE9BQXFDO1FBQWpELFlBQ0Usa0JBQU0sT0FBTyxDQUFDLFNBRWY7UUFQTyxvQkFBYyxHQUFHLEdBQUc7UUFFNUIseUJBQW1CLEdBQUcsSUFBSSxZQUFZLENBQUMsRUFBRSxDQUFDO1FBSXhDLEtBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVTs7SUFDOUIsQ0FBQztJQUVELHNCQUFJLDJDQUFhO2FBQWpCO1lBQ0UsT0FBTyxJQUFJLENBQUMsY0FBYztRQUM1QixDQUFDO2FBRUQsVUFBa0IsS0FBYTtZQUM3QixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsY0FBYyxFQUFFO2dCQUNqQyxhQUFhO2dCQUNiLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO2dCQUN0QixJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUs7YUFDNUI7UUFDSCxDQUFDOzs7T0FSQTtJQVVELDRDQUFpQixHQUFqQjtRQUNFLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRO1FBQzdCLGFBQWE7UUFDYixJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQzFGLE9BQU07U0FDUDtRQUNELElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3pDLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVTtTQUN6QztRQUNELGFBQWE7UUFDYixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUTtRQUMzQyxJQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxTQUFTO1FBRW5DLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDO1FBQ3pDLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJO1FBQ3pCLElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPO1FBRTNCLElBQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSztRQUM3RixJQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSztRQUNuRSxJQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU07UUFDL0YsSUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU07UUFFckUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjO1FBQ3ZFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsY0FBYztRQUV2RSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWM7UUFDdkUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjO1FBRXZFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdB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RSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNoRSxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDOUQsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWhFLElBQUksV0FBVyxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUU7WUFDdEMsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDO1lBQ3hDLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQztZQUN4QyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNoRTtRQUNELElBQUksV0FBVyxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDbkMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENB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QUFDLEtBQUssQ0FBQztRQUN4RSxXQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUM7UUFDNUUsSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUNmLElBQUksZUFBZSxFQUFFO1lBQ25CLElBQUksQ0FBQyxTQUFTLEdBQUcsZUFBZSxDQUFDLFFBQVE7U0FDMUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDRCQUFNLEdBQU4sVUFBTyxLQUF3QixFQUFFLEVBQWdDO1FBQWhDLDhCQUFTLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDL0QsSUFBSSxHQUFHLEdBQUcsV0FBSSxDQUFDLFdBQVcsQ0FDeEIsV0FBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFDSCxrQkFBQztBQUFELENBQUMsQ0FqRmdDLElBQUksQ0FBQyxTQUFTLEdBaUY5QztBQWpGWSxrQ0FBVzs7Ozs7Ozs7Ozs7O0FDWHhCLHFEIiwiZmlsZSI6InBpeGkzZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInBpeGkuanNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJQSVhJM0RcIiwgW1wicGl4aS5qc1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQSVhJM0RcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJwaXhpLmpzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQSVhJM0RcIl0gPSBmYWN0b3J5KHJvb3RbXCJQSVhJXCJdKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9waXhpX2pzX18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c1wiKTtcbiIsIi8qKlxyXG4gKiBDb21tb24gdXRpbGl0aWVzXHJcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcclxuICovXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xuZXhwb3J0IHZhciBFUFNJTE9OID0gMC4wMDAwMDE7XG5leHBvcnQgdmFyIEFSUkFZX1RZUEUgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuZXhwb3J0IHZhciBSQU5ET00gPSBNYXRoLnJhbmRvbTtcbi8qKlxyXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcclxuICpcclxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvciB8IEFycmF5Q29uc3RydWN0b3J9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRNYXRyaXhBcnJheVR5cGUodHlwZSkge1xuICBBUlJBWV9UWVBFID0gdHlwZTtcbn1cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuLyoqXHJcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBBbmdsZSBpbiBEZWdyZWVzXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbi8qKlxyXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXHJcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3NcclxuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuaWYgKCFNYXRoLmh5cG90KSBNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgeSA9IDAsXG4gICAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgeSArPSBhcmd1bWVudHNbaV0gKiBhcmd1bWVudHNbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KHkpO1xufTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSBcIi4vbWF0Mi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MmQgZnJvbSBcIi4vbWF0MmQuanNcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0My5qc1wiO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tIFwiLi9tYXQ0LmpzXCI7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gXCIuL3F1YXQuanNcIjtcbmltcG9ydCAqIGFzIHF1YXQyIGZyb20gXCIuL3F1YXQyLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gXCIuL3ZlYzIuanNcIjtcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vdmVjMy5qc1wiO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tIFwiLi92ZWM0LmpzXCI7XG5leHBvcnQgeyBnbE1hdHJpeCwgbWF0MiwgbWF0MmQsIG1hdDMsIG1hdDQsIHF1YXQsIHF1YXQyLCB2ZWMyLCB2ZWMzLCB2ZWM0IH07IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogMngyIE1hdHJpeFxyXG4gKiBAbW9kdWxlIG1hdDJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcclxuICpcclxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDIgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHJldHVybnMge21hdDJ9IG91dCBBIG5ldyAyeDIgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTEwO1xuICBvdXRbM10gPSBtMTE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MiB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTEwO1xuICBvdXRbM10gPSBtMTE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGVcbiAgLy8gc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMSA9IGFbMV07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhMTtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYVsxXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGEzICogZGV0O1xuICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gIG91dFsyXSA9IC1hMiAqIGRldDtcbiAgb3V0WzNdID0gYTAgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIHZhciBhMCA9IGFbMF07XG4gIG91dFswXSA9IGFbM107XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDIuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG59XG4vKipcclxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBMRFUoTCwgRCwgVSwgYSkge1xuICBMWzJdID0gYVsyXSAvIGFbMF07XG4gIFVbMF0gPSBhWzBdO1xuICBVWzFdID0gYVsxXTtcbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTtcbiAgcmV0dXJuIFtMLCBELCBVXTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogMngzIE1hdHJpeFxyXG4gKiBAbW9kdWxlIG1hdDJkXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIG1hdDJkIGNvbnRhaW5zIHNpeCBlbGVtZW50cyBkZWZpbmVkIGFzOlxyXG4gKiA8cHJlPlxyXG4gKiBbYSwgYixcclxuICogIGMsIGQsXHJcbiAqICB0eCwgdHldXHJcbiAqIDwvcHJlPlxyXG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XHJcbiAqIDxwcmU+XHJcbiAqIFthLCBiLCAwLFxyXG4gKiAgYywgZCwgMCxcclxuICogIHR4LCB0eSwgMV1cclxuICogPC9wcmU+XHJcbiAqIFRoZSBsYXN0IGNvbHVtbiBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDJkIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MmQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGMgQ29tcG9uZW50IEMgKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdHkgQ29tcG9uZW50IFRZIChpbmRleCA1KVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IEEgbmV3IG1hdDJkXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MmQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGFhID0gYVswXSxcbiAgICAgIGFiID0gYVsxXSxcbiAgICAgIGFjID0gYVsyXSxcbiAgICAgIGFkID0gYVszXTtcbiAgdmFyIGF0eCA9IGFbNF0sXG4gICAgICBhdHkgPSBhWzVdO1xuICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgb3V0WzRdID0gYTQ7XG4gIG91dFs1XSA9IGE1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwO1xuICBvdXRbMV0gPSBhMTtcbiAgb3V0WzJdID0gYTI7XG4gIG91dFszXSA9IGEzO1xuICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gYztcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gdlswXTtcbiAgb3V0WzVdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQyZChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgMSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MmQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MmQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogM3gzIE1hdHJpeFxyXG4gKiBAbW9kdWxlIG1hdDNcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcclxuICpcclxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVs0XTtcbiAgb3V0WzRdID0gYVs1XTtcbiAgb3V0WzVdID0gYVs2XTtcbiAgb3V0WzZdID0gYVs4XTtcbiAgb3V0WzddID0gYVs5XTtcbiAgb3V0WzhdID0gYVsxMF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEByZXR1cm5zIHttYXQzfSBBIG5ldyBtYXQzXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTEyID0gYVs1XTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYTAxO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYTAyO1xuICAgIG91dFs3XSA9IGExMjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhWzFdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhWzJdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcbiAgdmFyIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XG4gIHZhciBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGIwMSAqIGRldDtcbiAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgb3V0WzNdID0gYjExICogZGV0O1xuICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICBvdXRbMF0gPSBhMTEgKiBhMjIgLSBhMTIgKiBhMjE7XG4gIG91dFsxXSA9IGEwMiAqIGEyMSAtIGEwMSAqIGEyMjtcbiAgb3V0WzJdID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBvdXRbM10gPSBhMTIgKiBhMjAgLSBhMTAgKiBhMjI7XG4gIG91dFs0XSA9IGEwMCAqIGEyMiAtIGEwMiAqIGEyMDtcbiAgb3V0WzVdID0gYTAyICogYTEwIC0gYTAwICogYTEyO1xuICBvdXRbNl0gPSBhMTAgKiBhMjEgLSBhMTEgKiBhMjA7XG4gIG91dFs3XSA9IGEwMSAqIGEyMCAtIGEwMCAqIGEyMTtcbiAgb3V0WzhdID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMCA9IGJbMF0sXG4gICAgICBiMDEgPSBiWzFdLFxuICAgICAgYjAyID0gYlsyXTtcbiAgdmFyIGIxMCA9IGJbM10sXG4gICAgICBiMTEgPSBiWzRdLFxuICAgICAgYjEyID0gYls1XTtcbiAgdmFyIGIyMCA9IGJbNl0sXG4gICAgICBiMjEgPSBiWzddLFxuICAgICAgYjIyID0gYls4XTtcbiAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcbiAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcbiAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0gYTAwO1xuICBvdXRbMV0gPSBhMDE7XG4gIG91dFsyXSA9IGEwMjtcbiAgb3V0WzNdID0gYTEwO1xuICBvdXRbNF0gPSBhMTE7XG4gIG91dFs1XSA9IGExMjtcbiAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcbiAgb3V0WzZdID0gYTIwO1xuICBvdXRbN10gPSBhMjE7XG4gIG91dFs4XSA9IGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0geCAqIGFbMF07XG4gIG91dFsxXSA9IHggKiBhWzFdO1xuICBvdXRbMl0gPSB4ICogYVsyXTtcbiAgb3V0WzNdID0geSAqIGFbM107XG4gIG91dFs0XSA9IHkgKiBhWzRdO1xuICBvdXRbNV0gPSB5ICogYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gdlswXTtcbiAgb3V0WzddID0gdlsxXTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQzLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IC1zO1xuICBvdXRbNF0gPSBjO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHZbMV07XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNvcHlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0MmQob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IGFbMl07XG4gIG91dFs0XSA9IGFbM107XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IGFbNF07XG4gIG91dFs3XSA9IGFbNV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB5eCA9IHkgKiB4MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgenggPSB6ICogeDI7XG4gIHZhciB6eSA9IHogKiB5MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzNdID0geXggLSB3ejtcbiAgb3V0WzZdID0genggKyB3eTtcbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzRdID0gMSAtIHh4IC0geno7XG4gIG91dFs3XSA9IHp5IC0gd3g7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFs1XSA9IHp5ICsgd3g7XG4gIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgMkQgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHlvdXIgZ2wgY29udGV4dFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBnbCBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0aW9uKG91dCwgd2lkdGgsIGhlaWdodCkge1xuICBvdXRbMF0gPSAyIC8gd2lkdGg7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IC0yIC8gaGVpZ2h0O1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAtMTtcbiAgb3V0WzddID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIsIFwiICsgYVs4XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDMncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN10sXG4gICAgICBhOCA9IGFbOF07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN10sXG4gICAgICBiOCA9IGJbOF07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiA0eDQgTWF0cml4PGJyPkZvcm1hdDogY29sdW1uLW1ham9yLCB3aGVuIHR5cGVkIG91dCBpdCBsb29rcyBsaWtlIHJvdy1tYWpvcjxicj5UaGUgbWF0cmljZXMgYXJlIGJlaW5nIHBvc3QgbXVsdGlwbGllZC5cclxuICogQG1vZHVsZSBtYXQ0XHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFs1XSA9IDE7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcclxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM107XG4gICAgdmFyIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG4gICAgdmFyIGEyMyA9IGFbMTFdO1xuICAgIG91dFsxXSA9IGFbNF07XG4gICAgb3V0WzJdID0gYVs4XTtcbiAgICBvdXRbM10gPSBhWzEyXTtcbiAgICBvdXRbNF0gPSBhMDE7XG4gICAgb3V0WzZdID0gYVs5XTtcbiAgICBvdXRbN10gPSBhWzEzXTtcbiAgICBvdXRbOF0gPSBhMDI7XG4gICAgb3V0WzldID0gYTEyO1xuICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICBvdXRbMTJdID0gYTAzO1xuICAgIG91dFsxM10gPSBhMTM7XG4gICAgb3V0WzE0XSA9IGEyMztcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbNF07XG4gICAgb3V0WzJdID0gYVs4XTtcbiAgICBvdXRbM10gPSBhWzEyXTtcbiAgICBvdXRbNF0gPSBhWzFdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs5XTtcbiAgICBvdXRbN10gPSBhWzEzXTtcbiAgICBvdXRbOF0gPSBhWzJdO1xuICAgIG91dFs5XSA9IGFbNl07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICBvdXRbMTJdID0gYVszXTtcbiAgICBvdXRbMTNdID0gYVs3XTtcbiAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgb3V0WzBdID0gYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpO1xuICBvdXRbMV0gPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gIG91dFsyXSA9IGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzNdID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbNF0gPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gIG91dFs1XSA9IGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKTtcbiAgb3V0WzZdID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbN10gPSBhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFs4XSA9IGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKTtcbiAgb3V0WzldID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICBvdXRbMTBdID0gYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpO1xuICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICBvdXRbMTNdID0gYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpO1xuICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICBvdXRbMTVdID0gYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0NHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07IC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuXG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbMV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzJdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFszXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbNF07XG4gIGIxID0gYls1XTtcbiAgYjIgPSBiWzZdO1xuICBiMyA9IGJbN107XG4gIG91dFs0XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbNV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzZdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFs3XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbOF07XG4gIGIxID0gYls5XTtcbiAgYjIgPSBiWzEwXTtcbiAgYjMgPSBiWzExXTtcbiAgb3V0WzhdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs5XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMTBdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFsxMV0gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzEyXTtcbiAgYjEgPSBiWzEzXTtcbiAgYjIgPSBiWzE0XTtcbiAgYjMgPSBiWzE1XTtcbiAgb3V0WzEyXSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbMTNdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxNF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzE1XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIHZhciBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIHZhciBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIHZhciBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgaWYgKGEgPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IGFbMF07XG4gICAgYTAxID0gYVsxXTtcbiAgICBhMDIgPSBhWzJdO1xuICAgIGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTtcbiAgICBhMTEgPSBhWzVdO1xuICAgIGExMiA9IGFbNl07XG4gICAgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdO1xuICAgIGEyMSA9IGFbOV07XG4gICAgYTIyID0gYVsxMF07XG4gICAgYTIzID0gYVsxMV07XG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG4gICAgb3V0WzNdID0gYTAzO1xuICAgIG91dFs0XSA9IGExMDtcbiAgICBvdXRbNV0gPSBhMTE7XG4gICAgb3V0WzZdID0gYTEyO1xuICAgIG91dFs3XSA9IGExMztcbiAgICBvdXRbOF0gPSBhMjA7XG4gICAgb3V0WzldID0gYTIxO1xuICAgIG91dFsxMF0gPSBhMjI7XG4gICAgb3V0WzExXSA9IGEyMztcbiAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyBub3QgdXNpbmcgdmVjdG9yaXphdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgb3V0WzBdID0gYVswXSAqIHg7XG4gIG91dFsxXSA9IGFbMV0gKiB4O1xuICBvdXRbMl0gPSBhWzJdICogeDtcbiAgb3V0WzNdID0gYVszXSAqIHg7XG4gIG91dFs0XSA9IGFbNF0gKiB5O1xuICBvdXRbNV0gPSBhWzVdICogeTtcbiAgb3V0WzZdID0gYVs2XSAqIHk7XG4gIG91dFs3XSA9IGFbN10gKiB5O1xuICBvdXRbOF0gPSBhWzhdICogejtcbiAgb3V0WzldID0gYVs5XSAqIHo7XG4gIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBnaXZlbiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgICB5ID0gYXhpc1sxXSxcbiAgICAgIHogPSBheGlzWzJdO1xuICB2YXIgbGVuID0gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbiAgdmFyIHMsIGMsIHQ7XG4gIHZhciBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIHZhciBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIHZhciBhMjAsIGEyMSwgYTIyLCBhMjM7XG4gIHZhciBiMDAsIGIwMSwgYjAyO1xuICB2YXIgYjEwLCBiMTEsIGIxMjtcbiAgdmFyIGIyMCwgYjIxLCBiMjI7XG5cbiAgaWYgKGxlbiA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjO1xuICBhMDAgPSBhWzBdO1xuICBhMDEgPSBhWzFdO1xuICBhMDIgPSBhWzJdO1xuICBhMDMgPSBhWzNdO1xuICBhMTAgPSBhWzRdO1xuICBhMTEgPSBhWzVdO1xuICBhMTIgPSBhWzZdO1xuICBhMTMgPSBhWzddO1xuICBhMjAgPSBhWzhdO1xuICBhMjEgPSBhWzldO1xuICBhMjIgPSBhWzEwXTtcbiAgYTIzID0gYVsxMV07IC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuXG4gIGIwMCA9IHggKiB4ICogdCArIGM7XG4gIGIwMSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIGIxMSA9IHkgKiB5ICogdCArIGM7XG4gIGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICBiMjAgPSB4ICogeiAqIHQgKyB5ICogcztcbiAgYjIxID0geSAqIHogKiB0IC0geCAqIHM7XG4gIGIyMiA9IHogKiB6ICogdCArIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IHZbMV07XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSB2WzJdO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgICB5ID0gYXhpc1sxXSxcbiAgICAgIHogPSBheGlzWzJdO1xuICB2YXIgbGVuID0gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbiAgdmFyIHMsIGMsIHQ7XG5cbiAgaWYgKGxlbiA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjOyAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IHggKiB4ICogdCArIGM7XG4gIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIG91dFs1XSA9IHkgKiB5ICogdCArIGM7XG4gIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogcztcbiAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHM7XG4gIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IC1zO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21ZUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gcztcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWlJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLXM7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdikge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBmcm9tIGEgZHVhbCBxdWF0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBNYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7bWF0NH0gbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0MihvdXQsIGEpIHtcbiAgdmFyIHRyYW5zbGF0aW9uID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN107XG4gIHZhciBtYWduaXR1ZGUgPSBieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnogKyBidyAqIGJ3OyAvL09ubHkgc2NhbGUgaWYgaXQgbWFrZXMgc2Vuc2VcblxuICBpZiAobWFnbml0dWRlID4gMCkge1xuICAgIHRyYW5zbGF0aW9uWzBdID0gKGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnkpICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsxXSA9IChheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyIC8gbWFnbml0dWRlO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zbGF0aW9uWzBdID0gKGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnkpICogMjtcbiAgICB0cmFuc2xhdGlvblsxXSA9IChheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICB9XG5cbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBhLCB0cmFuc2xhdGlvbik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXHJcbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sXHJcbiAqICB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cclxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXHJcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cclxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlXHJcbiAqICB3aXRoIGEgbm9ybWFsaXplZCBRdWF0ZXJuaW9uIHBhcmFtdGVyLCB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmVcclxuICogIHRoZSBzYW1lIGFzIHRoZSBzY2FsaW5nIHZlY3RvclxyXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cclxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXHJcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxpbmcob3V0LCBtYXQpIHtcbiAgdmFyIG0xMSA9IG1hdFswXTtcbiAgdmFyIG0xMiA9IG1hdFsxXTtcbiAgdmFyIG0xMyA9IG1hdFsyXTtcbiAgdmFyIG0yMSA9IG1hdFs0XTtcbiAgdmFyIG0yMiA9IG1hdFs1XTtcbiAgdmFyIG0yMyA9IG1hdFs2XTtcbiAgdmFyIG0zMSA9IG1hdFs4XTtcbiAgdmFyIG0zMiA9IG1hdFs5XTtcbiAgdmFyIG0zMyA9IG1hdFsxMF07XG4gIG91dFswXSA9IE1hdGguaHlwb3QobTExLCBtMTIsIG0xMyk7XG4gIG91dFsxXSA9IE1hdGguaHlwb3QobTIxLCBtMjIsIG0yMyk7XG4gIG91dFsyXSA9IE1hdGguaHlwb3QobTMxLCBtMzIsIG0zMyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxyXG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcclxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxyXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb24ob3V0LCBtYXQpIHtcbiAgdmFyIHNjYWxpbmcgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgZ2V0U2NhbGluZyhzY2FsaW5nLCBtYXQpO1xuICB2YXIgaXMxID0gMSAvIHNjYWxpbmdbMF07XG4gIHZhciBpczIgPSAxIC8gc2NhbGluZ1sxXTtcbiAgdmFyIGlzMyA9IDEgLyBzY2FsaW5nWzJdO1xuICB2YXIgc20xMSA9IG1hdFswXSAqIGlzMTtcbiAgdmFyIHNtMTIgPSBtYXRbMV0gKiBpczI7XG4gIHZhciBzbTEzID0gbWF0WzJdICogaXMzO1xuICB2YXIgc20yMSA9IG1hdFs0XSAqIGlzMTtcbiAgdmFyIHNtMjIgPSBtYXRbNV0gKiBpczI7XG4gIHZhciBzbTIzID0gbWF0WzZdICogaXMzO1xuICB2YXIgc20zMSA9IG1hdFs4XSAqIGlzMTtcbiAgdmFyIHNtMzIgPSBtYXRbOV0gKiBpczI7XG4gIHZhciBzbTMzID0gbWF0WzEwXSAqIGlzMztcbiAgdmFyIHRyYWNlID0gc20xMSArIHNtMjIgKyBzbTMzO1xuICB2YXIgUyA9IDA7XG5cbiAgaWYgKHRyYWNlID4gMCkge1xuICAgIFMgPSBNYXRoLnNxcnQodHJhY2UgKyAxLjApICogMjtcbiAgICBvdXRbM10gPSAwLjI1ICogUztcbiAgICBvdXRbMF0gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMV0gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICBvdXRbMl0gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgfSBlbHNlIGlmIChzbTExID4gc20yMiAmJiBzbTExID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20xMSAtIHNtMjIgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMjMgLSBzbTMyKSAvIFM7XG4gICAgb3V0WzBdID0gMC4yNSAqIFM7XG4gICAgb3V0WzFdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzJdID0gKHNtMzEgKyBzbTEzKSAvIFM7XG4gIH0gZWxzZSBpZiAoc20yMiA+IHNtMzMpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMjIgLSBzbTExIC0gc20zMykgKiAyO1xuICAgIG91dFszXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFswXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgIG91dFsxXSA9IDAuMjUgKiBTO1xuICAgIG91dFsyXSA9IChzbTIzICsgc20zMikgLyBTO1xuICB9IGVsc2Uge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20zMyAtIHNtMTEgLSBzbTIyKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMzEgKyBzbTEzKSAvIFM7XG4gICAgb3V0WzFdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gICAgb3V0WzJdID0gMC4yNSAqIFM7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBzIFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKG91dCwgcSwgdiwgcykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4ob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIHZhciBveCA9IG9bMF07XG4gIHZhciBveSA9IG9bMV07XG4gIHZhciBveiA9IG9bMl07XG4gIHZhciBvdXQwID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIHZhciBvdXQxID0gKHh5ICsgd3opICogc3g7XG4gIHZhciBvdXQyID0gKHh6IC0gd3kpICogc3g7XG4gIHZhciBvdXQ0ID0gKHh5IC0gd3opICogc3k7XG4gIHZhciBvdXQ1ID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIHZhciBvdXQ2ID0gKHl6ICsgd3gpICogc3k7XG4gIHZhciBvdXQ4ID0gKHh6ICsgd3kpICogc3o7XG4gIHZhciBvdXQ5ID0gKHl6IC0gd3gpICogc3o7XG4gIHZhciBvdXQxMCA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICBvdXRbNl0gPSBvdXQ2O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBvdXQ4O1xuICBvdXRbOV0gPSBvdXQ5O1xuICBvdXRbMTBdID0gb3V0MTA7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dDAgKiBveCArIG91dDQgKiBveSArIG91dDggKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0MSAqIG94ICsgb3V0NSAqIG95ICsgb3V0OSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXQyICogb3ggKyBvdXQ2ICogb3kgKyBvdXQxMCAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB5eCA9IHkgKiB4MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgenggPSB6ICogeDI7XG4gIHZhciB6eSA9IHogKiB5MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geXggLSB3ejtcbiAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gIG91dFs2XSA9IHp5ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHp4ICsgd3k7XG4gIG91dFs5XSA9IHp5IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZydXN0dW0ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XG4gIHZhciB0YiA9IDEgLyAodG9wIC0gYm90dG9tKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gbmVhciAqIDIgKiBybDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gbmVhciAqIDIgKiB0YjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IGZhciAqIG5lYXIgKiAyICogbmY7XG4gIG91dFsxNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cclxuICogUGFzc2luZyBudWxsL3VuZGVmaW5lZC9ubyB2YWx1ZSBmb3IgZmFyIHdpbGwgZ2VuZXJhdGUgaW5maW5pdGUgcHJvamVjdGlvbiBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW0sIGNhbiBiZSBudWxsIG9yIEluZmluaXR5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgbmY7XG4gIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGY7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTVdID0gMDtcblxuICBpZiAoZmFyICE9IG51bGwgJiYgZmFyICE9PSBJbmZpbml0eSkge1xuICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE0XSA9IDIgKiBmYXIgKiBuZWFyICogbmY7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzEwXSA9IC0xO1xuICAgIG91dFsxNF0gPSAtMiAqIG5lYXI7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXHJcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcclxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKTtcbiAgdmFyIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuICBvdXRbMF0gPSB4U2NhbGU7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIG91dFs0XSA9IDAuMDtcbiAgb3V0WzVdID0geVNjYWxlO1xuICBvdXRbNl0gPSAwLjA7XG4gIG91dFs3XSA9IDAuMDtcbiAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gIG91dFs5XSA9ICh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41O1xuICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTFdID0gLTEuMDtcbiAgb3V0WzEyXSA9IDAuMDtcbiAgb3V0WzEzXSA9IDAuMDtcbiAgb3V0WzE0XSA9IGZhciAqIG5lYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxNV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBvcnRobyhvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTtcbiAgdmFyIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSAtMiAqIGxyO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAtMiAqIGJ0O1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMiAqIG5mO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzLlxyXG4gKiBJZiB5b3Ugd2FudCBhIG1hdHJpeCB0aGF0IGFjdHVhbGx5IG1ha2VzIGFuIG9iamVjdCBsb29rIGF0IGFub3RoZXIgb2JqZWN0LCB5b3Ugc2hvdWxkIHVzZSB0YXJnZXRUbyBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW47XG4gIHZhciBleWV4ID0gZXllWzBdO1xuICB2YXIgZXlleSA9IGV5ZVsxXTtcbiAgdmFyIGV5ZXogPSBleWVbMl07XG4gIHZhciB1cHggPSB1cFswXTtcbiAgdmFyIHVweSA9IHVwWzFdO1xuICB2YXIgdXB6ID0gdXBbMl07XG4gIHZhciBjZW50ZXJ4ID0gY2VudGVyWzBdO1xuICB2YXIgY2VudGVyeSA9IGNlbnRlclsxXTtcbiAgdmFyIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gIH1cblxuICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuICBsZW4gPSAxIC8gTWF0aC5oeXBvdCh6MCwgejEsIHoyKTtcbiAgejAgKj0gbGVuO1xuICB6MSAqPSBsZW47XG4gIHoyICo9IGxlbjtcbiAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0gTWF0aC5oeXBvdCh4MCwgeDEsIHgyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHgwID0gMDtcbiAgICB4MSA9IDA7XG4gICAgeDIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuICBsZW4gPSBNYXRoLmh5cG90KHkwLCB5MSwgeTIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeTAgPSAwO1xuICAgIHkxID0gMDtcbiAgICB5MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB5MCAqPSBsZW47XG4gICAgeTEgKj0gbGVuO1xuICAgIHkyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB5MDtcbiAgb3V0WzJdID0gejA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHgxO1xuICBvdXRbNV0gPSB5MTtcbiAgb3V0WzZdID0gejE7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHgyO1xuICBvdXRbOV0gPSB5MjtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbWF0cml4IHRoYXQgbWFrZXMgc29tZXRoaW5nIGxvb2sgYXQgc29tZXRoaW5nIGVsc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0YXJnZXRUbyhvdXQsIGV5ZSwgdGFyZ2V0LCB1cCkge1xuICB2YXIgZXlleCA9IGV5ZVswXSxcbiAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICB1cHkgPSB1cFsxXSxcbiAgICAgIHVweiA9IHVwWzJdO1xuICB2YXIgejAgPSBleWV4IC0gdGFyZ2V0WzBdLFxuICAgICAgejEgPSBleWV5IC0gdGFyZ2V0WzFdLFxuICAgICAgejIgPSBleWV6IC0gdGFyZ2V0WzJdO1xuICB2YXIgbGVuID0gejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyO1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuICB9XG5cbiAgdmFyIHgwID0gdXB5ICogejIgLSB1cHogKiB6MSxcbiAgICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MixcbiAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0geDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyO1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHgxO1xuICBvdXRbMl0gPSB4MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gejEgKiB4MiAtIHoyICogeDE7XG4gIG91dFs1XSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICBvdXRbNl0gPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gejA7XG4gIG91dFs5XSA9IHoxO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gZXlleDtcbiAgb3V0WzEzXSA9IGV5ZXk7XG4gIG91dFsxNF0gPSBleWV6O1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0NChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIsIFwiICsgYVs4XSArIFwiLCBcIiArIGFbOV0gKyBcIiwgXCIgKyBhWzEwXSArIFwiLCBcIiArIGFbMTFdICsgXCIsIFwiICsgYVsxMl0gKyBcIiwgXCIgKyBhWzEzXSArIFwiLCBcIiArIGFbMTRdICsgXCIsIFwiICsgYVsxNV0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdLCBhWzldLCBhWzEwXSwgYVsxMV0sIGFbMTJdLCBhWzEzXSwgYVsxNF0sIGFbMTVdKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQ0J3NcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICBvdXRbOV0gPSBhWzldICogYjtcbiAgb3V0WzEwXSA9IGFbMTBdICogYjtcbiAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgb3V0WzEyXSA9IGFbMTJdICogYjtcbiAgb3V0WzEzXSA9IGFbMTNdICogYjtcbiAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgb3V0WzE1XSA9IGFbMTVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQ0J3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdICogc2NhbGU7XG4gIG91dFs3XSA9IGFbN10gKyBiWzddICogc2NhbGU7XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdICogc2NhbGU7XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldICogc2NhbGU7XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdICogc2NhbGU7XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdICogc2NhbGU7XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdICogc2NhbGU7XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdICogc2NhbGU7XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdICogc2NhbGU7XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdICYmIGFbOV0gPT09IGJbOV0gJiYgYVsxMF0gPT09IGJbMTBdICYmIGFbMTFdID09PSBiWzExXSAmJiBhWzEyXSA9PT0gYlsxMl0gJiYgYVsxM10gPT09IGJbMTNdICYmIGFbMTRdID09PSBiWzE0XSAmJiBhWzE1XSA9PT0gYlsxNV07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN107XG4gIHZhciBhOCA9IGFbOF0sXG4gICAgICBhOSA9IGFbOV0sXG4gICAgICBhMTAgPSBhWzEwXSxcbiAgICAgIGExMSA9IGFbMTFdO1xuICB2YXIgYTEyID0gYVsxMl0sXG4gICAgICBhMTMgPSBhWzEzXSxcbiAgICAgIGExNCA9IGFbMTRdLFxuICAgICAgYTE1ID0gYVsxNV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIHZhciBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN107XG4gIHZhciBiOCA9IGJbOF0sXG4gICAgICBiOSA9IGJbOV0sXG4gICAgICBiMTAgPSBiWzEwXSxcbiAgICAgIGIxMSA9IGJbMTFdO1xuICB2YXIgYjEyID0gYlsxMl0sXG4gICAgICBiMTMgPSBiWzEzXSxcbiAgICAgIGIxNCA9IGJbMTRdLFxuICAgICAgYjE1ID0gYlsxNV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJiBNYXRoLmFicyhhOSAtIGI5KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiYgTWF0aC5hYnMoYTEwIC0gYjEwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJiBNYXRoLmFicyhhMTEgLSBiMTEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmIE1hdGguYWJzKGExMiAtIGIxMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiYgTWF0aC5hYnMoYTEzIC0gYjEzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJiBNYXRoLmFicyhhMTQgLSBiMTQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmIE1hdGguYWJzKGExNSAtIGIxNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQzIGZyb20gXCIuL21hdDMuanNcIjtcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vdmVjMy5qc1wiO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tIFwiLi92ZWM0LmpzXCI7XG4vKipcclxuICogUXVhdGVybmlvblxyXG4gKiBAbW9kdWxlIHF1YXRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcclxuICpcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgcXVhdCB0byB0aGUgaWRlbnRpdHkgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxyXG4gKiB0aGVuIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBeGlzQW5nbGUob3V0LCBheGlzLCByYWQpIHtcbiAgcmFkID0gcmFkICogMC41O1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cclxuICogIHF1YXRlcm5pb24uIElmIGEgcXVhdGVybmlvbiBpcyBjcmVhdGVkIHdpdGhcclxuICogIHNldEF4aXNBbmdsZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWVcclxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XHJcbiAqICBPUiBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB2YWx1ZXMuXHJcbiAqIEV4YW1wbGU6IFRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieSBheGlzIFswLCAwLCAxXSBhbmRcclxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcclxuICogIFswLCAwLCAxXSBhbmQgMjcwLiBUaGlzIG1ldGhvZCBmYXZvcnMgdGhlIGxhdHRlci5cclxuICogQHBhcmFtICB7dmVjM30gb3V0X2F4aXMgIFZlY3RvciByZWNlaXZpbmcgdGhlIGF4aXMgb2Ygcm90YXRpb25cclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0fSBxICAgICBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSByb3RhdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNBbmdsZShvdXRfYXhpcywgcSkge1xuICB2YXIgcmFkID0gTWF0aC5hY29zKHFbM10pICogMi4wO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCAvIDIuMCk7XG5cbiAgaWYgKHMgPiBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgb3V0X2F4aXNbMF0gPSBxWzBdIC8gcztcbiAgICBvdXRfYXhpc1sxXSA9IHFbMV0gLyBzO1xuICAgIG91dF9heGlzWzJdID0gcVsyXSAvIHM7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgcyBpcyB6ZXJvLCByZXR1cm4gYW55IGF4aXMgKG5vIHJvdGF0aW9uIC0gYXhpcyBkb2VzIG5vdCBtYXR0ZXIpXG4gICAgb3V0X2F4aXNbMF0gPSAxO1xuICAgIG91dF9heGlzWzFdID0gMDtcbiAgICBvdXRfYXhpc1syXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmFkO1xufVxuLyoqXHJcbiAqIEdldHMgdGhlIGFuZ3VsYXIgZGlzdGFuY2UgYmV0d2VlbiB0d28gdW5pdCBxdWF0ZXJuaW9uc1xyXG4gKlxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXR9IGEgICAgIE9yaWdpbiB1bml0IHF1YXRlcm5pb25cclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0fSBiICAgICBEZXN0aW5hdGlvbiB1bml0IHF1YXRlcm5pb25cclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIGJldHdlZW4gdGhlIHR3byBxdWF0ZXJuaW9uc1xyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlKGEsIGIpIHtcbiAgdmFyIGRvdHByb2R1Y3QgPSBkb3QoYSwgYik7XG4gIHJldHVybiBNYXRoLmFjb3MoMiAqIGRvdHByb2R1Y3QgKiBkb3Rwcm9kdWN0IC0gMSk7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgYncgPSBiWzNdO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieSA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieiA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxyXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxyXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVcob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IE1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleHAob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgdmFyIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgdmFyIGV0ID0gTWF0aC5leHAodyk7XG4gIHZhciBzID0gciA+IDAgPyBldCAqIE1hdGguc2luKHIpIC8gciA6IDA7XG4gIG91dFswXSA9IHggKiBzO1xuICBvdXRbMV0gPSB5ICogcztcbiAgb3V0WzJdID0geiAqIHM7XG4gIG91dFszXSA9IGV0ICogTWF0aC5jb3Mocik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBhIHVuaXQgcXVhdGVybmlvbi5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIHRoZSBleHBvbmVudGlhbCBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbG4ob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgdmFyIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgdmFyIHQgPSByID4gMCA/IE1hdGguYXRhbjIociwgdykgLyByIDogMDtcbiAgb3V0WzBdID0geCAqIHQ7XG4gIG91dFsxXSA9IHkgKiB0O1xuICBvdXRbMl0gPSB6ICogdDtcbiAgb3V0WzNdID0gMC41ICogTWF0aC5sb2coeCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHcpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgc2NhbGFyIHBvd2VyIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgcXVhdGVybmlvbiBieVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcG93KG91dCwgYSwgYikge1xuICBsbihvdXQsIGEpO1xuICBzY2FsZShvdXQsIG91dCwgYik7XG4gIGV4cChvdXQsIG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNsZXJwKG91dCwgYSwgYiwgdCkge1xuICAvLyBiZW5jaG1hcmtzOlxuICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgYncgPSBiWzNdO1xuICB2YXIgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7IC8vIGNhbGMgY29zaW5lXG5cbiAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3OyAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcblxuICBpZiAoY29zb20gPCAwLjApIHtcbiAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICBieCA9IC1ieDtcbiAgICBieSA9IC1ieTtcbiAgICBieiA9IC1iejtcbiAgICBidyA9IC1idztcbiAgfSAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG5cblxuICBpZiAoMS4wIC0gY29zb20gPiBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgb21lZ2EgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgIHNpbm9tID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgfSBlbHNlIHtcbiAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlXG4gICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgc2NhbGUxID0gdDtcbiAgfSAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG5cblxuICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB1bml0IHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0KSB7XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcbiAgLy8gVE9ETzogQ2FsbGluZyByYW5kb20gMyB0aW1lcyBpcyBwcm9iYWJseSBub3QgdGhlIGZhc3Rlc3Qgc29sdXRpb25cbiAgdmFyIHUxID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciB1MiA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgdTMgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHNxcnQxTWludXNVMSA9IE1hdGguc3FydCgxIC0gdTEpO1xuICB2YXIgc3FydFUxID0gTWF0aC5zcXJ0KHUxKTtcbiAgb3V0WzBdID0gc3FydDFNaW51c1UxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzFdID0gc3FydDFNaW51c1UxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzJdID0gc3FydFUxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgb3V0WzNdID0gc3FydFUxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgZG90ID0gYTAgKiBhMCArIGExICogYTEgKyBhMiAqIGEyICsgYTMgKiBhMztcbiAgdmFyIGludkRvdCA9IGRvdCA/IDEuMCAvIGRvdCA6IDA7IC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgb3V0WzBdID0gLWEwICogaW52RG90O1xuICBvdXRbMV0gPSAtYTEgKiBpbnZEb3Q7XG4gIG91dFsyXSA9IC1hMiAqIGludkRvdDtcbiAgb3V0WzNdID0gYTMgKiBpbnZEb3Q7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxyXG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb25qdWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cclxuICpcclxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcclxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gcm90YXRpb24gbWF0cml4XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDMob3V0LCBtKSB7XG4gIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICB2YXIgZlJvb3Q7XG5cbiAgaWYgKGZUcmFjZSA+IDAuMCkge1xuICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAvLyAyd1xuXG4gICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsgLy8gMS8oNHcpXG5cbiAgICBvdXRbMF0gPSAobVs1XSAtIG1bN10pICogZlJvb3Q7XG4gICAgb3V0WzFdID0gKG1bNl0gLSBtWzJdKSAqIGZSb290O1xuICAgIG91dFsyXSA9IChtWzFdIC0gbVszXSkgKiBmUm9vdDtcbiAgfSBlbHNlIHtcbiAgICAvLyB8d3wgPD0gMS8yXG4gICAgdmFyIGkgPSAwO1xuICAgIGlmIChtWzRdID4gbVswXSkgaSA9IDE7XG4gICAgaWYgKG1bOF0gPiBtW2kgKiAzICsgaV0pIGkgPSAyO1xuICAgIHZhciBqID0gKGkgKyAxKSAlIDM7XG4gICAgdmFyIGsgPSAoaSArIDIpICUgMztcbiAgICBmUm9vdCA9IE1hdGguc3FydChtW2kgKiAzICsgaV0gLSBtW2ogKiAzICsgal0gLSBtW2sgKiAzICsga10gKyAxLjApO1xuICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgb3V0WzNdID0gKG1baiAqIDMgKyBrXSAtIG1bayAqIDMgKyBqXSkgKiBmUm9vdDtcbiAgICBvdXRbal0gPSAobVtqICogMyArIGldICsgbVtpICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtrXSA9IChtW2sgKiAzICsgaV0gKyBtW2kgKiAzICsga10pICogZlJvb3Q7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlIHgsIHksIHouXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3h9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIGRlZ3JlZXMuXHJcbiAqIEBwYXJhbSB7eX0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBZIGF4aXMgaW4gZGVncmVlcy5cclxuICogQHBhcmFtIHt6fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFogYXhpcyBpbiBkZWdyZWVzLlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdWxlcihvdXQsIHgsIHksIHopIHtcbiAgdmFyIGhhbGZUb1JhZCA9IDAuNSAqIE1hdGguUEkgLyAxODAuMDtcbiAgeCAqPSBoYWxmVG9SYWQ7XG4gIHkgKj0gaGFsZlRvUmFkO1xuICB6ICo9IGhhbGZUb1JhZDtcbiAgdmFyIHN4ID0gTWF0aC5zaW4oeCk7XG4gIHZhciBjeCA9IE1hdGguY29zKHgpO1xuICB2YXIgc3kgPSBNYXRoLnNpbih5KTtcbiAgdmFyIGN5ID0gTWF0aC5jb3MoeSk7XG4gIHZhciBzeiA9IE1hdGguc2luKHopO1xuICB2YXIgY3ogPSBNYXRoLmNvcyh6KTtcbiAgb3V0WzBdID0gc3ggKiBjeSAqIGN6IC0gY3ggKiBzeSAqIHN6O1xuICBvdXRbMV0gPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XG4gIG91dFsyXSA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcbiAgb3V0WzNdID0gY3ggKiBjeSAqIGN6ICsgc3ggKiBzeSAqIHN6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInF1YXQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBjbG9uZSA9IHZlYzQuY2xvbmU7XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgY29weSA9IHZlYzQuY29weTtcbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNldCA9IHZlYzQuc2V0O1xuLyoqXHJcbiAqIEFkZHMgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGFkZCA9IHZlYzQuYWRkO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc2NhbGUgPSB2ZWM0LnNjYWxlO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRvdCA9IHZlYzQuZG90O1xuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZXJwID0gdmVjNC5sZXJwO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCB2YXIgbGVuZ3RoID0gdmVjNC5sZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIFRoZSBmaXJzdCBxdWF0ZXJuaW9uLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IHZhciBleGFjdEVxdWFscyA9IHZlYzQuZXhhY3RFcXVhbHM7XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgdmFyIGVxdWFscyA9IHZlYzQuZXF1YWxzO1xuLyoqXHJcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcclxuICogdmVjdG9yIHRvIGFub3RoZXIuXHJcbiAqXHJcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgdmFyIHJvdGF0aW9uVG8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLCAwLCAwKTtcbiAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG5cbiAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICBpZiAodmVjMy5sZW4odG1wdmVjMykgPCAwLjAwMDAwMSkgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICBzZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgb3V0WzBdID0gMDtcbiAgICAgIG91dFsxXSA9IDA7XG4gICAgICBvdXRbMl0gPSAwO1xuICAgICAgb3V0WzNdID0gMTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgfVxuICB9O1xufSgpO1xuLyoqXHJcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IHZhciBzcWxlcnAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZW1wMSA9IGNyZWF0ZSgpO1xuICB2YXIgdGVtcDIgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBzbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgc2xlcnAodGVtcDIsIGIsIGMsIHQpO1xuICAgIHNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCk7XG4vKipcclxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cclxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXHJcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IHZhciBzZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgIG1hdHJbNl0gPSByaWdodFsyXTtcbiAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgbWF0cls0XSA9IHVwWzFdO1xuICAgIG1hdHJbN10gPSB1cFsyXTtcbiAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgIG1hdHJbOF0gPSAtdmlld1syXTtcbiAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gIH07XG59KCk7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gXCIuL3F1YXQuanNcIjtcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSBcIi4vbWF0NC5qc1wiO1xuLyoqXHJcbiAqIER1YWwgUXVhdGVybmlvbjxicj5cclxuICogRm9ybWF0OiBbcmVhbCwgZHVhbF08YnI+XHJcbiAqIFF1YXRlcm5pb24gZm9ybWF0OiBYWVpXPGJyPlxyXG4gKiBNYWtlIHN1cmUgdG8gaGF2ZSBub3JtYWxpemVkIGR1YWwgcXVhdGVybmlvbnMsIG90aGVyd2lzZSB0aGUgZnVuY3Rpb25zIG1heSBub3Qgd29yayBhcyBpbnRlbmRlZC48YnI+XHJcbiAqIEBtb2R1bGUgcXVhdDJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGEgbmV3IGR1YWwgcXVhdGVybmlvbiBbcmVhbCAtPiByb3RhdGlvbiwgZHVhbCAtPiB0cmFuc2xhdGlvbl1cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIGRxWzBdID0gMDtcbiAgICBkcVsxXSA9IDA7XG4gICAgZHFbMl0gPSAwO1xuICAgIGRxWzRdID0gMDtcbiAgICBkcVs1XSA9IDA7XG4gICAgZHFbNl0gPSAwO1xuICAgIGRxWzddID0gMDtcbiAgfVxuXG4gIGRxWzNdID0gMTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdGVybmlvbiB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG5ldyBkdWFsIHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcbiAgZHFbMF0gPSBhWzBdO1xuICBkcVsxXSA9IGFbMV07XG4gIGRxWzJdID0gYVsyXTtcbiAgZHFbM10gPSBhWzNdO1xuICBkcVs0XSA9IGFbNF07XG4gIGRxWzVdID0gYVs1XTtcbiAgZHFbNl0gPSBhWzZdO1xuICBkcVs3XSA9IGFbN107XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgxIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejEgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFcgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTIgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MiBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG5ldyBkdWFsIHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6MiwgdzIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIGRxWzRdID0geDI7XG4gIGRxWzVdID0geTI7XG4gIGRxWzZdID0gejI7XG4gIGRxWzddID0gdzI7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBmcm9tIHRoZSBnaXZlbiB2YWx1ZXMgKHF1YXQgYW5kIHRyYW5zbGF0aW9uKVxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkyIFkgY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHJldHVybnMge3F1YXQyfSBuZXcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzKHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IHgxO1xuICBkcVsxXSA9IHkxO1xuICBkcVsyXSA9IHoxO1xuICBkcVszXSA9IHcxO1xuICB2YXIgYXggPSB4MiAqIDAuNSxcbiAgICAgIGF5ID0geTIgKiAwLjUsXG4gICAgICBheiA9IHoyICogMC41O1xuICBkcVs0XSA9IGF4ICogdzEgKyBheSAqIHoxIC0gYXogKiB5MTtcbiAgZHFbNV0gPSBheSAqIHcxICsgYXogKiB4MSAtIGF4ICogejE7XG4gIGRxWzZdID0gYXogKiB3MSArIGF4ICogeTEgLSBheSAqIHgxO1xuICBkcVs3XSA9IC1heCAqIHgxIC0gYXkgKiB5MSAtIGF6ICogejE7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgZHVhbCBxdWF0IGZyb20gYSBxdWF0ZXJuaW9uIGFuZCBhIHRyYW5zbGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIGEgbm9ybWFsaXplZCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB0IHRyYW5sYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdCkge1xuICB2YXIgYXggPSB0WzBdICogMC41LFxuICAgICAgYXkgPSB0WzFdICogMC41LFxuICAgICAgYXogPSB0WzJdICogMC41LFxuICAgICAgYnggPSBxWzBdLFxuICAgICAgYnkgPSBxWzFdLFxuICAgICAgYnogPSBxWzJdLFxuICAgICAgYncgPSBxWzNdO1xuICBvdXRbMF0gPSBieDtcbiAgb3V0WzFdID0gYnk7XG4gIG91dFsyXSA9IGJ6O1xuICBvdXRbM10gPSBidztcbiAgb3V0WzRdID0gYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbNV0gPSBheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFs2XSA9IGF6ICogYncgKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzddID0gLWF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgZHVhbCBxdWF0IGZyb20gYSB0cmFuc2xhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdCB0cmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB0WzBdICogMC41O1xuICBvdXRbNV0gPSB0WzFdICogMC41O1xuICBvdXRbNl0gPSB0WzJdICogMC41O1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgdGhlIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcSkge1xuICBvdXRbMF0gPSBxWzBdO1xuICBvdXRbMV0gPSBxWzFdO1xuICBvdXRbMl0gPSBxWzJdO1xuICBvdXRbM10gPSBxWzNdO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGZyb20gYSBtYXRyaXggKDR4NClcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgLy9UT0RPIE9wdGltaXplIHRoaXNcbiAgdmFyIG91dGVyID0gcXVhdC5jcmVhdGUoKTtcbiAgbWF0NC5nZXRSb3RhdGlvbihvdXRlciwgYSk7XG4gIHZhciB0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG1hdDQuZ2V0VHJhbnNsYXRpb24odCwgYSk7XG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgb3V0ZXIsIHQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBkdWFsIHF1YXQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBzb3VyY2UgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgZHVhbCBxdWF0IHRvIHRoZSBpZGVudGl0eSBkdWFsIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHgxIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejEgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFcgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTIgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MiBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6MiwgdzIpIHtcbiAgb3V0WzBdID0geDE7XG4gIG91dFsxXSA9IHkxO1xuICBvdXRbMl0gPSB6MTtcbiAgb3V0WzNdID0gdzE7XG4gIG91dFs0XSA9IHgyO1xuICBvdXRbNV0gPSB5MjtcbiAgb3V0WzZdID0gejI7XG4gIG91dFs3XSA9IHcyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldHMgdGhlIHJlYWwgcGFydCBvZiBhIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0gIHtxdWF0fSBvdXQgcmVhbCBwYXJ0XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge3F1YXR9IHJlYWwgcGFydFxyXG4gKi9cblxuZXhwb3J0IHZhciBnZXRSZWFsID0gcXVhdC5jb3B5O1xuLyoqXHJcbiAqIEdldHMgdGhlIGR1YWwgcGFydCBvZiBhIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0gIHtxdWF0fSBvdXQgZHVhbCBwYXJ0XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge3F1YXR9IGR1YWwgcGFydFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldER1YWwob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbNF07XG4gIG91dFsxXSA9IGFbNV07XG4gIG91dFsyXSA9IGFbNl07XG4gIG91dFszXSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSByZWFsIGNvbXBvbmVudCBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJlYWwgcGFydFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc2V0UmVhbCA9IHF1YXQuY29weTtcbi8qKlxyXG4gKiBTZXQgdGhlIGR1YWwgY29tcG9uZW50IG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgZHVhbCBwYXJ0XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldER1YWwob3V0LCBxKSB7XG4gIG91dFs0XSA9IHFbMF07XG4gIG91dFs1XSA9IHFbMV07XG4gIG91dFs2XSA9IHFbMl07XG4gIG91dFs3XSA9IHFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgdHJhbnNsYXRpb24gb2YgYSBub3JtYWxpemVkIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgdHJhbnNsYXRpb25cclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb24gdG8gYmUgZGVjb21wb3NlZFxyXG4gKiBAcmV0dXJuIHt2ZWMzfSB0cmFuc2xhdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgYSkge1xuICB2YXIgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdO1xuICBvdXRbMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICBvdXRbMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICBvdXRbMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZXMgYSBkdWFsIHF1YXQgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBheDEgPSBhWzBdLFxuICAgICAgYXkxID0gYVsxXSxcbiAgICAgIGF6MSA9IGFbMl0sXG4gICAgICBhdzEgPSBhWzNdLFxuICAgICAgYngxID0gdlswXSAqIDAuNSxcbiAgICAgIGJ5MSA9IHZbMV0gKiAwLjUsXG4gICAgICBiejEgPSB2WzJdICogMC41LFxuICAgICAgYXgyID0gYVs0XSxcbiAgICAgIGF5MiA9IGFbNV0sXG4gICAgICBhejIgPSBhWzZdLFxuICAgICAgYXcyID0gYVs3XTtcbiAgb3V0WzBdID0gYXgxO1xuICBvdXRbMV0gPSBheTE7XG4gIG91dFsyXSA9IGF6MTtcbiAgb3V0WzNdID0gYXcxO1xuICBvdXRbNF0gPSBhdzEgKiBieDEgKyBheTEgKiBiejEgLSBhejEgKiBieTEgKyBheDI7XG4gIG91dFs1XSA9IGF3MSAqIGJ5MSArIGF6MSAqIGJ4MSAtIGF4MSAqIGJ6MSArIGF5MjtcbiAgb3V0WzZdID0gYXcxICogYnoxICsgYXgxICogYnkxIC0gYXkxICogYngxICsgYXoyO1xuICBvdXRbN10gPSAtYXgxICogYngxIC0gYXkxICogYnkxIC0gYXoxICogYnoxICsgYXcyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBYIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGhvdyBmYXIgc2hvdWxkIHRoZSByb3RhdGlvbiBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGF4MSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksXG4gICAgICBheTEgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxuICAgICAgYXoxID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgIGF3MSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHF1YXQucm90YXRlWChvdXQsIGEsIHJhZCk7XG4gIGJ4ID0gb3V0WzBdO1xuICBieSA9IG91dFsxXTtcbiAgYnogPSBvdXRbMl07XG4gIGJ3ID0gb3V0WzNdO1xuICBvdXRbNF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzVdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFs2XSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbN10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCB0aGUgWSBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBheDEgPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxuICAgICAgYXkxID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcbiAgICAgIGF6MSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsXG4gICAgICBhdzEgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICBxdWF0LnJvdGF0ZVkob3V0LCBhLCByYWQpO1xuICBieCA9IG91dFswXTtcbiAgYnkgPSBvdXRbMV07XG4gIGJ6ID0gb3V0WzJdO1xuICBidyA9IG91dFszXTtcbiAgb3V0WzRdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFs1XSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbNl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzddID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgaG93IGZhciBzaG91bGQgdGhlIHJvdGF0aW9uIGJlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVaKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYnkgYSBnaXZlbiBxdWF0ZXJuaW9uIChhICogcSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdEFwcGVuZChvdXQsIGEsIHEpIHtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXSxcbiAgICAgIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKiBxdyArIGF3ICogcXggKyBheSAqIHF6IC0gYXogKiBxeTtcbiAgb3V0WzFdID0gYXkgKiBxdyArIGF3ICogcXkgKyBheiAqIHF4IC0gYXggKiBxejtcbiAgb3V0WzJdID0gYXogKiBxdyArIGF3ICogcXogKyBheCAqIHF5IC0gYXkgKiBxeDtcbiAgb3V0WzNdID0gYXcgKiBxdyAtIGF4ICogcXggLSBheSAqIHF5IC0gYXogKiBxejtcbiAgYXggPSBhWzRdO1xuICBheSA9IGFbNV07XG4gIGF6ID0gYVs2XTtcbiAgYXcgPSBhWzddO1xuICBvdXRbNF0gPSBheCAqIHF3ICsgYXcgKiBxeCArIGF5ICogcXogLSBheiAqIHF5O1xuICBvdXRbNV0gPSBheSAqIHF3ICsgYXcgKiBxeSArIGF6ICogcXggLSBheCAqIHF6O1xuICBvdXRbNl0gPSBheiAqIHF3ICsgYXcgKiBxeiArIGF4ICogcXkgLSBheSAqIHF4O1xuICBvdXRbN10gPSBhdyAqIHF3IC0gYXggKiBxeCAtIGF5ICogcXkgLSBheiAqIHF6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYnkgYSBnaXZlbiBxdWF0ZXJuaW9uIChxICogYSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdFByZXBlbmQob3V0LCBxLCBhKSB7XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM10sXG4gICAgICBieCA9IGFbMF0sXG4gICAgICBieSA9IGFbMV0sXG4gICAgICBieiA9IGFbMl0sXG4gICAgICBidyA9IGFbM107XG4gIG91dFswXSA9IHF4ICogYncgKyBxdyAqIGJ4ICsgcXkgKiBieiAtIHF6ICogYnk7XG4gIG91dFsxXSA9IHF5ICogYncgKyBxdyAqIGJ5ICsgcXogKiBieCAtIHF4ICogYno7XG4gIG91dFsyXSA9IHF6ICogYncgKyBxdyAqIGJ6ICsgcXggKiBieSAtIHF5ICogYng7XG4gIG91dFszXSA9IHF3ICogYncgLSBxeCAqIGJ4IC0gcXkgKiBieSAtIHF6ICogYno7XG4gIGJ4ID0gYVs0XTtcbiAgYnkgPSBhWzVdO1xuICBieiA9IGFbNl07XG4gIGJ3ID0gYVs3XTtcbiAgb3V0WzRdID0gcXggKiBidyArIHF3ICogYnggKyBxeSAqIGJ6IC0gcXogKiBieTtcbiAgb3V0WzVdID0gcXkgKiBidyArIHF3ICogYnkgKyBxeiAqIGJ4IC0gcXggKiBiejtcbiAgb3V0WzZdID0gcXogKiBidyArIHF3ICogYnogKyBxeCAqIGJ5IC0gcXkgKiBieDtcbiAgb3V0WzddID0gcXcgKiBidyAtIHF4ICogYnggLSBxeSAqIGJ5IC0gcXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCBhIGdpdmVuIGF4aXMuIERvZXMgdGhlIG5vcm1hbGlzYXRpb24gYXV0b21hdGljYWxseVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBob3cgZmFyIHRoZSByb3RhdGlvbiBzaG91bGQgYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVBcm91bmRBeGlzKG91dCwgYSwgYXhpcywgcmFkKSB7XG4gIC8vU3BlY2lhbCBjYXNlIGZvciByYWQgPSAwXG4gIGlmIChNYXRoLmFicyhyYWQpIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBjb3B5KG91dCwgYSk7XG4gIH1cblxuICB2YXIgYXhpc0xlbmd0aCA9IE1hdGguaHlwb3QoYXhpc1swXSwgYXhpc1sxXSwgYXhpc1syXSk7XG4gIHJhZCA9IHJhZCAqIDAuNTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYnggPSBzICogYXhpc1swXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBieSA9IHMgKiBheGlzWzFdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ6ID0gcyAqIGF4aXNbMl0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYncgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYXgxID0gYVswXSxcbiAgICAgIGF5MSA9IGFbMV0sXG4gICAgICBhejEgPSBhWzJdLFxuICAgICAgYXcxID0gYVszXTtcbiAgb3V0WzBdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFsxXSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbMl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzNdID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHZhciBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN107XG4gIG91dFs0XSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFs1XSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFs2XSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFs3XSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gZHVhbCBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIGR1YWwgcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYXgwID0gYVswXSxcbiAgICAgIGF5MCA9IGFbMV0sXG4gICAgICBhejAgPSBhWzJdLFxuICAgICAgYXcwID0gYVszXSxcbiAgICAgIGJ4MSA9IGJbNF0sXG4gICAgICBieTEgPSBiWzVdLFxuICAgICAgYnoxID0gYls2XSxcbiAgICAgIGJ3MSA9IGJbN10sXG4gICAgICBheDEgPSBhWzRdLFxuICAgICAgYXkxID0gYVs1XSxcbiAgICAgIGF6MSA9IGFbNl0sXG4gICAgICBhdzEgPSBhWzddLFxuICAgICAgYngwID0gYlswXSxcbiAgICAgIGJ5MCA9IGJbMV0sXG4gICAgICBiejAgPSBiWzJdLFxuICAgICAgYncwID0gYlszXTtcbiAgb3V0WzBdID0gYXgwICogYncwICsgYXcwICogYngwICsgYXkwICogYnowIC0gYXowICogYnkwO1xuICBvdXRbMV0gPSBheTAgKiBidzAgKyBhdzAgKiBieTAgKyBhejAgKiBieDAgLSBheDAgKiBiejA7XG4gIG91dFsyXSA9IGF6MCAqIGJ3MCArIGF3MCAqIGJ6MCArIGF4MCAqIGJ5MCAtIGF5MCAqIGJ4MDtcbiAgb3V0WzNdID0gYXcwICogYncwIC0gYXgwICogYngwIC0gYXkwICogYnkwIC0gYXowICogYnowO1xuICBvdXRbNF0gPSBheDAgKiBidzEgKyBhdzAgKiBieDEgKyBheTAgKiBiejEgLSBhejAgKiBieTEgKyBheDEgKiBidzAgKyBhdzEgKiBieDAgKyBheTEgKiBiejAgLSBhejEgKiBieTA7XG4gIG91dFs1XSA9IGF5MCAqIGJ3MSArIGF3MCAqIGJ5MSArIGF6MCAqIGJ4MSAtIGF4MCAqIGJ6MSArIGF5MSAqIGJ3MCArIGF3MSAqIGJ5MCArIGF6MSAqIGJ4MCAtIGF4MSAqIGJ6MDtcbiAgb3V0WzZdID0gYXowICogYncxICsgYXcwICogYnoxICsgYXgwICogYnkxIC0gYXkwICogYngxICsgYXoxICogYncwICsgYXcxICogYnowICsgYXgxICogYnkwIC0gYXkxICogYngwO1xuICBvdXRbN10gPSBhdzAgKiBidzEgLSBheDAgKiBieDEgLSBheTAgKiBieTEgLSBhejAgKiBiejEgKyBhdzEgKiBidzAgLSBheDEgKiBieDAgLSBheTEgKiBieTAgLSBhejEgKiBiejA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIFNjYWxlcyBhIGR1YWwgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgZHVhbCBxdWF0IGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIGR1YWwgcXVhdCdzIChUaGUgZG90IHByb2R1Y3Qgb2YgdGhlIHJlYWwgcGFydHMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRvdCA9IHF1YXQuZG90O1xuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gZHVhbCBxdWF0cydzXHJcbiAqIE5PVEU6IFRoZSByZXN1bHRpbmcgZHVhbCBxdWF0ZXJuaW9ucyB3b24ndCBhbHdheXMgYmUgbm9ybWFsaXplZCAoVGhlIGVycm9yIGlzIG1vc3Qgbm90aWNlYWJsZSB3aGVuIHQgPSAwLjUpXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIG10ID0gMSAtIHQ7XG4gIGlmIChkb3QoYSwgYikgPCAwKSB0ID0gLXQ7XG4gIG91dFswXSA9IGFbMF0gKiBtdCArIGJbMF0gKiB0O1xuICBvdXRbMV0gPSBhWzFdICogbXQgKyBiWzFdICogdDtcbiAgb3V0WzJdID0gYVsyXSAqIG10ICsgYlsyXSAqIHQ7XG4gIG91dFszXSA9IGFbM10gKiBtdCArIGJbM10gKiB0O1xuICBvdXRbNF0gPSBhWzRdICogbXQgKyBiWzRdICogdDtcbiAgb3V0WzVdID0gYVs1XSAqIG10ICsgYls1XSAqIHQ7XG4gIG91dFs2XSA9IGFbNl0gKiBtdCArIGJbNl0gKiB0O1xuICBvdXRbN10gPSBhWzddICogbXQgKyBiWzddICogdDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgZHVhbCBxdWF0LiBJZiB0aGV5IGFyZSBub3JtYWxpemVkLCBjb25qdWdhdGUgaXMgY2hlYXBlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIHNxbGVuID0gc3F1YXJlZExlbmd0aChhKTtcbiAgb3V0WzBdID0gLWFbMF0gLyBzcWxlbjtcbiAgb3V0WzFdID0gLWFbMV0gLyBzcWxlbjtcbiAgb3V0WzJdID0gLWFbMl0gLyBzcWxlbjtcbiAgb3V0WzNdID0gYVszXSAvIHNxbGVuO1xuICBvdXRbNF0gPSAtYVs0XSAvIHNxbGVuO1xuICBvdXRbNV0gPSAtYVs1XSAvIHNxbGVuO1xuICBvdXRbNl0gPSAtYVs2XSAvIHNxbGVuO1xuICBvdXRbN10gPSBhWzddIC8gc3FsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgZHVhbCBxdWF0XHJcbiAqIElmIHRoZSBkdWFsIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0Mi5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gLWFbNF07XG4gIG91dFs1XSA9IC1hWzVdO1xuICBvdXRbNl0gPSAtYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBkdWFsIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW5ndGggPSBxdWF0Lmxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXVhcmVkTGVuZ3RoID0gcXVhdC5zcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdDIuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogTm9ybWFsaXplIGEgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciBtYWduaXR1ZGUgPSBzcXVhcmVkTGVuZ3RoKGEpO1xuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgbWFnbml0dWRlID0gTWF0aC5zcXJ0KG1hZ25pdHVkZSk7XG4gICAgdmFyIGEwID0gYVswXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTEgPSBhWzFdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMiA9IGFbMl0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGEzID0gYVszXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYjAgPSBhWzRdO1xuICAgIHZhciBiMSA9IGFbNV07XG4gICAgdmFyIGIyID0gYVs2XTtcbiAgICB2YXIgYjMgPSBhWzddO1xuICAgIHZhciBhX2RvdF9iID0gYTAgKiBiMCArIGExICogYjEgKyBhMiAqIGIyICsgYTMgKiBiMztcbiAgICBvdXRbMF0gPSBhMDtcbiAgICBvdXRbMV0gPSBhMTtcbiAgICBvdXRbMl0gPSBhMjtcbiAgICBvdXRbM10gPSBhMztcbiAgICBvdXRbNF0gPSAoYjAgLSBhMCAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs1XSA9IChiMSAtIGExICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzZdID0gKGIyIC0gYTIgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbN10gPSAoYjMgLSBhMyAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZHVhbCBxdWF0ZW5pb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdGVybmlvbiB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkdWFsIHF1YXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJxdWF0MihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZHVhbCBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3QgZHVhbCBxdWF0ZXJuaW9uLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBkdWFsIHF1YXRlcm5pb24uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBkdWFsIHF1YXRlcm5pb25zIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkdWFsIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXQuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSk7XG59IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogMiBEaW1lbnNpb25hbCBWZWN0b3JcclxuICogQG1vZHVsZSB2ZWMyXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeTtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xyXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxyXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xyXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAyRCB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSB2ZWMyIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCBiLCByYWQpIHtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICB2YXIgcDAgPSBhWzBdIC0gYlswXSxcbiAgICAgIHAxID0gYVsxXSAtIGJbMV0sXG4gICAgICBzaW5DID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGNvc0MgPSBNYXRoLmNvcyhyYWQpOyAvL3BlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgb3V0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgeDEgPSBhWzBdLFxuICAgICAgeTEgPSBhWzFdLFxuICAgICAgeDIgPSBiWzBdLFxuICAgICAgeTIgPSBiWzFdLFxuICAgICAgLy8gbWFnIGlzIHRoZSBwcm9kdWN0IG9mIHRoZSBtYWduaXR1ZGVzIG9mIGEgYW5kIGJcbiAgbWFnID0gTWF0aC5zcXJ0KHgxICogeDEgKyB5MSAqIHkxKSAqIE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5MiksXG4gICAgICAvLyBtYWcgJiYuLiBzaG9ydCBjaXJjdWl0cyBpZiBtYWcgPT0gMFxuICBjb3NpbmUgPSBtYWcgJiYgKHgxICogeDIgKyB5MSAqIHkyKSAvIG1hZzsgLy8gTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpIGNsYW1wcyB0aGUgY29zaW5lIGJldHdlZW4gLTEgYW5kIDFcblxuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAyO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogMyBEaW1lbnNpb25hbCBWZWN0b3JcclxuICogQG1vZHVsZSB2ZWMzXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxyXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl07XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl07XG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgdmFyIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgdmFyIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIHZhciB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjA7XG4gIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGU7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXHJcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxyXG4gKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkdWFsIHF1YXRlcm5pb25zLiAoTXVsdGlwbHkgaXQgd2l0aCB0aGUgcmVhbCBwYXJ0KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTsgLy8gdmFyIHF2ZWMgPSBbcXgsIHF5LCBxel07XG4gIC8vIHZhciB1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIGEpO1xuXG4gIHZhciB1dnggPSBxeSAqIHogLSBxeiAqIHksXG4gICAgICB1dnkgPSBxeiAqIHggLSBxeCAqIHosXG4gICAgICB1dnogPSBxeCAqIHkgLSBxeSAqIHg7IC8vIHZhciB1dXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCB1dik7XG5cbiAgdmFyIHV1dnggPSBxeSAqIHV2eiAtIHF6ICogdXZ5LFxuICAgICAgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dnosXG4gICAgICB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDsgLy8gdmVjMy5zY2FsZSh1diwgdXYsIDIgKiB3KTtcblxuICB2YXIgdzIgPSBxdyAqIDI7XG4gIHV2eCAqPSB3MjtcbiAgdXZ5ICo9IHcyO1xuICB1dnogKj0gdzI7IC8vIHZlYzMuc2NhbGUodXV2LCB1dXYsIDIpO1xuXG4gIHV1dnggKj0gMjtcbiAgdXV2eSAqPSAyO1xuICB1dXZ6ICo9IDI7IC8vIHJldHVybiB2ZWMzLmFkZChvdXQsIGEsIHZlYzMuYWRkKG91dCwgdXYsIHV1dikpO1xuXG4gIG91dFswXSA9IHggKyB1dnggKyB1dXZ4O1xuICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgb3V0WzJdID0geiArIHV2eiArIHV1dno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF07XG4gIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMl0gKiBNYXRoLnNpbihyYWQpICsgcFswXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMV0gPSBwWzFdO1xuICByWzJdID0gcFsyXSAqIE1hdGguY29zKHJhZCkgLSBwWzBdICogTWF0aC5zaW4ocmFkKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzJdID0gcFsyXTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXSxcbiAgICAgIG1hZzEgPSBNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkgKyBheiAqIGF6KSxcbiAgICAgIG1hZzIgPSBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6KSxcbiAgICAgIG1hZyA9IG1hZzEgKiBtYWcyLFxuICAgICAgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cclxuICogQHJldHVybnMge0FycmF5fSBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMztcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIHZlY1syXSA9IGFbaSArIDJdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgICBhW2kgKyAyXSA9IHZlY1syXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiA0IERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHosIHcpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6LCB3KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5mbG9vcihhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHosIHcpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgdyA9IGFbM107XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbn1cbi8qKlxyXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IC1hWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0geCAqIGxlbjtcbiAgb3V0WzFdID0geSAqIGxlbjtcbiAgb3V0WzJdID0geiAqIGxlbjtcbiAgb3V0WzNdID0gdyAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNyb3NzLXByb2R1Y3Qgb2YgdGhyZWUgdmVjdG9ycyBpbiBhIDQtZGltZW5zaW9uYWwgc3BhY2VcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IHJlc3VsdCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gVSB0aGUgZmlyc3QgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBWIHRoZSBzZWNvbmQgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBXIHRoZSB0aGlyZCB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IHJlc3VsdFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgdSwgdiwgdykge1xuICB2YXIgQSA9IHZbMF0gKiB3WzFdIC0gdlsxXSAqIHdbMF0sXG4gICAgICBCID0gdlswXSAqIHdbMl0gLSB2WzJdICogd1swXSxcbiAgICAgIEMgPSB2WzBdICogd1szXSAtIHZbM10gKiB3WzBdLFxuICAgICAgRCA9IHZbMV0gKiB3WzJdIC0gdlsyXSAqIHdbMV0sXG4gICAgICBFID0gdlsxXSAqIHdbM10gLSB2WzNdICogd1sxXSxcbiAgICAgIEYgPSB2WzJdICogd1szXSAtIHZbM10gKiB3WzJdO1xuICB2YXIgRyA9IHVbMF07XG4gIHZhciBIID0gdVsxXTtcbiAgdmFyIEkgPSB1WzJdO1xuICB2YXIgSiA9IHVbM107XG4gIG91dFswXSA9IEggKiBGIC0gSSAqIEUgKyBKICogRDtcbiAgb3V0WzFdID0gLShHICogRikgKyBJICogQyAtIEogKiBCO1xuICBvdXRbMl0gPSBHICogRSAtIEggKiBDICsgSiAqIEE7XG4gIG91dFszXSA9IC0oRyAqIEQpICsgSCAqIEIgLSBJICogQTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgdmFyIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wOyAvLyBNYXJzYWdsaWEsIEdlb3JnZS4gQ2hvb3NpbmcgYSBQb2ludCBmcm9tIHRoZSBTdXJmYWNlIG9mIGFcbiAgLy8gU3BoZXJlLiBBbm4uIE1hdGguIFN0YXRpc3QuIDQzICgxOTcyKSwgbm8uIDIsIDY0NS0tNjQ2LlxuICAvLyBodHRwOi8vcHJvamVjdGV1Y2xpZC5vcmcvZXVjbGlkLmFvbXMvMTE3NzY5MjY0NDtcblxuICB2YXIgdjEsIHYyLCB2MywgdjQ7XG4gIHZhciBzMSwgczI7XG5cbiAgZG8ge1xuICAgIHYxID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2MiA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczEgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgfSB3aGlsZSAoczEgPj0gMSk7XG5cbiAgZG8ge1xuICAgIHYzID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2NCA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczIgPSB2MyAqIHYzICsgdjQgKiB2NDtcbiAgfSB3aGlsZSAoczIgPj0gMSk7XG5cbiAgdmFyIGQgPSBNYXRoLnNxcnQoKDEgLSBzMSkgLyBzMik7XG4gIG91dFswXSA9IHNjYWxlICogdjE7XG4gIG91dFsxXSA9IHNjYWxlICogdjI7XG4gIG91dFsyXSA9IHNjYWxlICogdjMgKiBkO1xuICBvdXRbM10gPSBzY2FsZSAqIHY0ICogZDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdOyAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuXG4gIHZhciBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgdmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICB2YXIgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gIHZhciBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7IC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gemVyb1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cclxuICogQHJldHVybnMge0FycmF5fSBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gNDtcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIHZlY1syXSA9IGFbaSArIDJdO1xuICAgICAgdmVjWzNdID0gYVtpICsgM107XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgICAgYVtpICsgM10gPSB2ZWNbM107XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBmcm9tKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYW5pbWF0aW9uLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQW5pbWF0aW9uIGV4dGVuZHMgUElYSS51dGlscy5FdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIF90aWNrZXI/OiBQSVhJLlRpY2tlclxuICBwcml2YXRlIF91cGRhdGU/OiAoLi4ucGFyYW1zOiBhbnlbXSkgPT4gdm9pZFxuXG4gIC8qKiBUaGUgZHVyYXRpb24gKGluIHNlY29uZHMpIG9mIHRoaXMgYW5pbWF0aW9uLiAqL1xuICBhYnN0cmFjdCByZWFkb25seSBkdXJhdGlvbjogbnVtYmVyXG5cbiAgLyoqIFRoZSBjdXJyZW50IHBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiB0aGlzIGFuaW1hdGlvbi4gKi9cbiAgYWJzdHJhY3QgcG9zaXRpb246IG51bWJlclxuXG4gIC8qKiBUaGUgc3BlZWQgdGhhdCB0aGUgYW5pbWF0aW9uIHdpbGwgcGxheSBhdC4gKi9cbiAgc3BlZWQgPSAxXG5cbiAgLyoqIEEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgYW5pbWF0aW9uIGlzIGxvb3BpbmcuICovXG4gIGxvb3AgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGFuaW1hdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICogQHBhcmFtIG5hbWUgTmFtZSBmb3IgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBwbGF5aW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIHNwZWNpZmllZCB0aWNrZXIuXG4gICAqIEBwYXJhbSB0aWNrZXIgVGhlIHRpY2tlciB0byB1c2UgZm9yIHVwZGF0aW5nIHRoZSBhbmltYXRpb24uIElmIGEgdGlja2VyIFxuICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBzaGFyZWQgdGlja2VyIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHBsYXkodGlja2VyID0gUElYSS5UaWNrZXIuc2hhcmVkKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IDBcbiAgICBpZiAoIXRoaXMuX3RpY2tlcikge1xuICAgICAgdGhpcy5fdXBkYXRlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aWNrZXIuZGVsdGFNUyAvIDEwMDAgKiB0aGlzLnNwZWVkKVxuICAgICAgfVxuICAgICAgdGhpcy5fdGlja2VyID0gdGlja2VyLmFkZCh0aGlzLl91cGRhdGUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHBsYXlpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tlciAmJiB0aGlzLl91cGRhdGUpIHtcbiAgICAgIHRoaXMuX3RpY2tlci5yZW1vdmUodGhpcy5fdXBkYXRlKVxuICAgICAgdGhpcy5fdGlja2VyID0gdGhpcy5fdXBkYXRlID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGFuaW1hdGlvbiBieSB0aGUgc3BlY2lmaWVkIGRlbHRhIHRpbWUuXG4gICAqIEBwYXJhbSBkZWx0YSBUaGUgdGltZSBpbiBzZWNvbmRzIHNpbmNlIGxhc3QgZnJhbWUuXG4gICAqL1xuICB1cGRhdGUoZGVsdGE6IG51bWJlcikge1xuICAgIHRoaXMucG9zaXRpb24gKz0gZGVsdGFcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA8IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICBpZiAodGhpcy5wb3NpdGlvbiA+IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gJSB0aGlzLmR1cmF0aW9uXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMuZHVyYXRpb25cbiAgICAgIHRoaXMuc3RvcCgpXG4gICAgfVxuICAgIHRoaXMuZW1pdChcImNvbXBsZXRlXCIpXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSBcIi4vY2FtZXJhXCJcbmltcG9ydCB7IFF1YXQgfSBmcm9tIFwiLi4vbWF0aC9xdWF0XCJcbmltcG9ydCB7IFZlYzMgfSBmcm9tIFwiLi4vbWF0aC92ZWMzXCJcblxuLyoqXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gY29udHJvbCB0aGUgY2FtZXJhIGJ5IG9yYml0aW5nIHRoZSB0YXJnZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYW1lcmFPcmJpdENvbnRyb2wge1xuICBwcml2YXRlIF9kaXN0YW5jZSA9IDVcbiAgcHJpdmF0ZSBfZ3JhYmJlZCA9IGZhbHNlXG5cbiAgcHJpdmF0ZSBfYW5nbGVzID0gbmV3IFBJWEkuT2JzZXJ2YWJsZVBvaW50KCgpID0+IHtcbiAgICB0aGlzLl9hbmdsZXMueCA9IE1hdGgubWluKE1hdGgubWF4KC04NSwgdGhpcy5fYW5nbGVzLngpLCA4NSlcbiAgfSwgdW5kZWZpbmVkLCAwLCAxODApXG5cbiAgLyoqXG4gICAqIE9yaWVudGF0aW9uIGV1bGVyIGFuZ2xlcyAoeC1heGlzIGFuZCB5LWF4aXMpLiBUaGUgYW5nbGUgZm9yIHRoZSB4LWF4aXMgXG4gICAqIHdpbGwgYmUgY2xhbXBlZCBiZXR3ZWVuIC04NSBhbmQgODUgZGVncmVlcy5cbiAgICovXG4gIGdldCBhbmdsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuZ2xlc1xuICB9XG5cbiAgLyoqIFRhcmdldCBwb3NpdGlvbiAoeCwgeSwgeikgdG8gb3JiaXQuICovXG4gIHRhcmdldCA9IHsgeDogMCwgeTogMCwgejogMCB9XG5cbiAgLyoqIEFsbG93cyB0aGUgY2FtZXJhIHRvIGJlIGNvbnRyb2xsZWQgYnkgdXNlci4gKi9cbiAgYWxsb3dDb250cm9sID0gdHJ1ZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNhbWVyYSBvcmJpdCBjb250cm9sLlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCBmb3IgbGlzdGVuaW5nIHRvIHVzZXIgZXZlbnRzLlxuICAgKiBAcGFyYW0gY2FtZXJhIFRoZSBjYW1lcmEgdG8gY29udHJvbC4gSWYgbm90IHNldCwgdGhlIG1haW4gY2FtZXJhIHdpbGwgYmUgdXNlZCBcbiAgICogYnkgZGVmYXVsdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwdWJsaWMgY2FtZXJhID0gQ2FtZXJhLm1haW4pIHtcbiAgICB0aGlzLmNhbWVyYS5yZW5kZXJlci5vbihcInByZXJlbmRlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUNhbWVyYSgpXG4gICAgfSlcbiAgICB0aGlzLmNhbWVyYS5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uLm9uKFwibW91c2Vkb3duXCIsIChlOiBQSVhJLkludGVyYWN0aW9uRXZlbnQpID0+IHtcbiAgICAgIGlmICghZS5zdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuX2dyYWJiZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2dyYWJiZWQgPSBmYWxzZVxuICAgIH0pXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWxsb3dDb250cm9sICYmIGV2ZW50LmJ1dHRvbnMgPT09IDEgJiYgdGhpcy5fZ3JhYmJlZCkge1xuICAgICAgICB0aGlzLl9hbmdsZXMueCArPSBldmVudC5tb3ZlbWVudFkgKiAwLjVcbiAgICAgICAgdGhpcy5fYW5nbGVzLnkgLT0gZXZlbnQubW92ZW1lbnRYICogMC41XG4gICAgICB9XG4gICAgfSlcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsIChldmVudDogRXZlbnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmFsbG93Q29udHJvbCkge1xuICAgICAgICB0aGlzLmRpc3RhbmNlICs9ICg8V2hlZWxFdmVudD5ldmVudCkuZGVsdGFZICogMC4wMVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gb2YgdGhlIGNhbWVyYS5cbiAgICovXG4gIHVwZGF0ZUNhbWVyYSgpIHtcbiAgICBsZXQgcm90ID0gUXVhdC5mcm9tRXVsZXIodGhpcy5fYW5nbGVzLngsIHRoaXMuX2FuZ2xlcy55LCAwLCBuZXcgRmxvYXQzMkFycmF5KDQpKVxuICAgIGxldCBkaXIgPSBWZWMzLnRyYW5zZm9ybVF1YXQoXG4gICAgICBWZWMzLnNldCgwLCAwLCAxLCBuZXcgRmxvYXQzMkFycmF5KDMpKSwgcm90LCBuZXcgRmxvYXQzMkFycmF5KDMpKVxuICAgIGxldCBwb3MgPSBWZWMzLnN1YnRyYWN0KFxuICAgICAgVmVjMy5zZXQodGhpcy50YXJnZXQueCwgdGhpcy50YXJnZXQueSwgdGhpcy50YXJnZXQueiwgbmV3IEZsb2F0MzJBcnJheSgzKSksIFZlYzMuc2NhbGUoZGlyLCB0aGlzLmRpc3RhbmNlLCBuZXcgRmxvYXQzMkFycmF5KDMpKSwgbmV3IEZsb2F0MzJBcnJheSgzKSlcblxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldChwb3NbMF0sIHBvc1sxXSwgcG9zWzJdKVxuICAgIHRoaXMuY2FtZXJhLnJvdGF0aW9uUXVhdGVybmlvbi5zZXQocm90WzBdLCByb3RbMV0sIHJvdFsyXSwgcm90WzNdKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3RhbmNlIGJldHdlZW4gY2FtZXJhIGFuZCB0aGUgdGFyZ2V0LiBEZWZhdWx0IHZhbHVlIGlzIDUuXG4gICAqL1xuICBnZXQgZGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlXG4gIH1cblxuICBzZXQgZGlzdGFuY2UodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLm1heCh2YWx1ZSwgMC4wMSksIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IENvbnRhaW5lcjNEIH0gZnJvbSBcIi4uL2NvbnRhaW5lclwiXG5pbXBvcnQgeyBNYXQ0IH0gZnJvbSBcIi4uL21hdGgvbWF0NFwiXG5pbXBvcnQgeyBSYXkgfSBmcm9tIFwiLi4vbWF0aC9yYXlcIlxuaW1wb3J0IHsgVmVjMyB9IGZyb20gXCIuLi9tYXRoL3ZlYzNcIlxuaW1wb3J0IHsgVmVjNCB9IGZyb20gXCIuLi9tYXRoL3ZlYzRcIlxuaW1wb3J0IHsgTWF0cml4Q29tcG9uZW50IH0gZnJvbSBcIi4uL3RyYW5zZm9ybS9tYXRyaXgtY29tcG9uZW50XCJcbmltcG9ydCB7IE9ic2VydmFibGVQb2ludDNEIH0gZnJvbSBcIi4uL3RyYW5zZm9ybS9vYnNlcnZhYmxlLXBvaW50XCJcbmltcG9ydCB7IFRyYW5zZm9ybUlkIH0gZnJvbSBcIi4uL3RyYW5zZm9ybS90cmFuc2Zvcm0taWRcIlxuXG5jb25zdCB2ZWMzID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuY29uc3QgbWF0NCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpXG5jb25zdCB2ZWM0ID0gbmV3IEZsb2F0MzJBcnJheSg0KVxuXG4vKipcbiAqIENhbWVyYSBpcyBhIGRldmljZSBmcm9tIHdoaWNoIHRoZSB3b3JsZCBpcyB2aWV3ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYW1lcmEgZXh0ZW5kcyBDb250YWluZXIzRCBpbXBsZW1lbnRzIFRyYW5zZm9ybUlkIHtcbiAgcHJpdmF0ZSBfdHJhbnNmb3JtSWQgPSAwXG5cbiAgZ2V0IHRyYW5zZm9ybUlkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCArIHRoaXMuX3RyYW5zZm9ybUlkXG4gIH1cblxuICBwcml2YXRlIF9wcm9qZWN0aW9uPzogTWF0cml4Q29tcG9uZW50XG4gIHByaXZhdGUgX3ZpZXc/OiBNYXRyaXhDb21wb25lbnRcbiAgcHJpdmF0ZSBfdmlld1Byb2plY3Rpb24/OiBNYXRyaXhDb21wb25lbnRcbiAgcHJpdmF0ZSBfb3J0aG9ncmFwaGljID0gZmFsc2VcbiAgcHJpdmF0ZSBfb3J0aG9ncmFwaGljU2l6ZSA9IDEwXG5cbiAgLyoqIE1haW4gY2FtZXJhIHdoaWNoIGlzIHVzZWQgYnkgZGVmYXVsdC4gKi9cbiAgc3RhdGljIG1haW46IENhbWVyYVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNhbWVyYSB1c2luZyB0aGUgc3BlY2lmaWVkIHJlbmRlcmVyLiBCeSBkZWZhdWx0IHRoZSBjYW1lcmFcbiAgICogbG9va3MgdG93YXJkcyBuZWdhdGl2ZSB6IGFuZCBpcyBwb3NpdGlvbmVkIGF0IHogPSA1LlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgUmVuZGVyZXIgdG8gdXNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgbGV0IGFzcGVjdCA9IHJlbmRlcmVyLndpZHRoIC8gcmVuZGVyZXIuaGVpZ2h0XG4gICAgbGV0IGxvY2FsSUQgPSAtMVxuXG4gICAgdGhpcy5yZW5kZXJlci5vbihcInByZXJlbmRlclwiLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2FzcGVjdCkge1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHNwZWNpZmljIGFzcGVjdCBzZXQsIHRoaXMgaXMgdXNlZCBmb3IgdGhlIFxuICAgICAgICAvLyBwcm9qZWN0aW9uIG1hdHJpeCB0byBhbHdheXMgdXBkYXRlIGVhY2ggZnJhbWUgKGluIGNhc2Ugd2hlbiB0aGUgXG4gICAgICAgIC8vIHJlbmRlcmVyIGFzcGVjdCByYXRpbyBoYXMgY2hhbmdlZCkuXG4gICAgICAgIGlmIChyZW5kZXJlci53aWR0aCAvIHJlbmRlcmVyLmhlaWdodCAhPT0gYXNwZWN0KSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmb3JtSWQrK1xuICAgICAgICAgIGFzcGVjdCA9IHJlbmRlcmVyLndpZHRoIC8gcmVuZGVyZXIuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmU6IF9sb2NhbElEIGRvIGV4aXN0LCBidXQgYmUgY2FyZWZ1bCBpZiB0aGlzIGNoYW5nZXMuXG4gICAgICBpZiAoIXRoaXMucGFyZW50ICYmIGxvY2FsSUQgIT09IHRoaXMudHJhbnNmb3JtLl9sb2NhbElEKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGNhbWVyYSBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIHNjZW5lIGhpZXJhcmNoeSB0aGUgdHJhbnNmb3JtIFxuICAgICAgICAvLyBuZWVkcyB0byBiZSB1cGRhdGVkIG1hbnVhbGx5LlxuICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0oKVxuICAgICAgICAvLyBAdHMtaWdub3JlOiBfbG9jYWxJRCBkbyBleGlzdCwgYnV0IGJlIGNhcmVmdWwgaWYgdGhpcyBjaGFuZ2VzLlxuICAgICAgICBsb2NhbElEID0gdGhpcy50cmFuc2Zvcm0uX2xvY2FsSURcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmICghQ2FtZXJhLm1haW4pIHtcbiAgICAgIENhbWVyYS5tYWluID0gdGhpc1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi56ID0gNVxuICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uUXVhdGVybmlvbi5zZXRFdWxlckFuZ2xlcygwLCAxODAsIDApXG4gIH1cblxuICBkZXN0cm95KG9wdGlvbnM/OiBib29sZWFuIHwgUElYSS5JRGVzdHJveU9wdGlvbnMpIHtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpXG4gICAgaWYgKHRoaXMgPT09IENhbWVyYS5tYWluKSB7XG4gICAgICAvLyBAdHMtaWdub3JlIEl0J3Mgb2ssIG1haW4gY2FtZXJhIHdhcyBkZXN0cm95ZWQuXG4gICAgICBDYW1lcmEubWFpbiA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2FtZXJhJ3MgaGFsZi1zaXplIHdoZW4gaW4gb3J0aG9ncmFwaGljIG1vZGUuIFRoZSB2aXNpYmxlIGFyZWEgZnJvbSBcbiAgICogY2VudGVyIG9mIHRoZSBzY3JlZW4gdG8gdGhlIHRvcC5cbiAgICovXG4gIGdldCBvcnRob2dyYXBoaWNTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9vcnRob2dyYXBoaWNTaXplXG4gIH1cblxuICBzZXQgb3J0aG9ncmFwaGljU2l6ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX29ydGhvZ3JhcGhpY1NpemUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9vcnRob2dyYXBoaWNTaXplID0gdmFsdWU7IHRoaXMuX3RyYW5zZm9ybUlkKytcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDYW1lcmEgd2lsbCByZW5kZXIgb2JqZWN0cyB1bmlmb3JtbHksIHdpdGggbm8gc2Vuc2Ugb2YgcGVyc3BlY3RpdmUuXG4gICAqL1xuICBnZXQgb3J0aG9ncmFwaGljKCkge1xuICAgIHJldHVybiB0aGlzLl9vcnRob2dyYXBoaWNcbiAgfVxuXG4gIHNldCBvcnRob2dyYXBoaWModmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5fb3J0aG9ncmFwaGljICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fb3J0aG9ncmFwaGljID0gdmFsdWU7IHRoaXMuX3RyYW5zZm9ybUlkKytcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgc2NyZWVuIGNvb3JkaW5hdGVzIHRvIGEgcmF5LlxuICAgKiBAcGFyYW0geCBTY3JlZW4geCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0geSBTY3JlZW4geSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0gdmlld1NpemUgVGhlIHNpemUgb2YgdGhlIHZpZXcgd2hlbiBub3QgcmVuZGVyaW5nIHRvIHRoZSBlbnRpcmUgc2NyZWVuLlxuICAgKi9cbiAgc2NyZWVuVG9SYXkoeDogbnVtYmVyLCB5OiBudW1iZXIsIHZpZXdTaXplOiB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0gPSB0aGlzLnJlbmRlcmVyLnNjcmVlbikge1xuICAgIGxldCBzY3JlZW4gPSB0aGlzLnNjcmVlblRvV29ybGQoeCwgeSwgMSwgdW5kZWZpbmVkLCB2aWV3U2l6ZSlcbiAgICBpZiAoc2NyZWVuKSB7XG4gICAgICByZXR1cm4gbmV3IFJheSh0aGlzLndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uLFxuICAgICAgICBWZWMzLnN1YnRyYWN0KHNjcmVlbi5hcnJheSwgdGhpcy53b3JsZFRyYW5zZm9ybS5wb3NpdGlvbiwgdmVjMykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHNjcmVlbiBjb29yZGluYXRlcyB0byB3b3JsZCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHggU2NyZWVuIHggY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHkgU2NyZWVuIHkgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIGRpc3RhbmNlIERpc3RhbmNlIGZyb20gdGhlIGNhbWVyYS5cbiAgICogQHBhcmFtIHBvaW50IFBvaW50IHRvIHNldC5cbiAgICogQHBhcmFtIHZpZXdTaXplIFRoZSBzaXplIG9mIHRoZSB2aWV3IHdoZW4gbm90IHJlbmRlcmluZyB0byB0aGUgZW50aXJlIHNjcmVlbi5cbiAgICovXG4gIHNjcmVlblRvV29ybGQoeDogbnVtYmVyLCB5OiBudW1iZXIsIGRpc3RhbmNlOiBudW1iZXIsIHBvaW50ID0gbmV3IE9ic2VydmFibGVQb2ludDNEKCgpID0+IHsgfSwgdW5kZWZpbmVkKSwgdmlld1NpemU6IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSA9IHRoaXMucmVuZGVyZXIuc2NyZWVuKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0cmFuc2Zvcm0gaXMgdXBkYXRlZCBpbiBjYXNlIHNvbWV0aGluZyBoYXMgYmVlbiBjaGFuZ2VkLCBcbiAgICAvLyBvdGhlcndpc2UgaXQgbWF5IGJlIHVzaW5nIHdyb25nIHZhbHVlcy5cbiAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQ/LnRyYW5zZm9ybSlcblxuICAgIGxldCBmYXIgPSB0aGlzLmZhclxuXG4gICAgLy8gQmVmb3JlIGRvaW5nIHRoZSBjYWxjdWxhdGlvbnMsIHRoZSBmYXIgY2xpcCBwbGFuZSBpcyBjaGFuZ2VkIHRvIHRoZSBzYW1lIFxuICAgIC8vIHZhbHVlIGFzIGRpc3RhbmNlIGZyb20gdGhlIGNhbWVyYS4gQnkgZG9pbmcgdGhpcyB3ZSBjYW4ganVzdCBzZXQgeiB2YWx1ZSBcbiAgICAvLyBmb3IgdGhlIGNsaXAgc3BhY2UgdG8gMSBhbmQgdGhlIGRlc2lyZWQgeiBwb3NpdGlvbiB3aWxsIGJlIGNvcnJlY3QuXG4gICAgdGhpcy5mYXIgPSBkaXN0YW5jZVxuXG4gICAgbGV0IGludmVydGVkVmlld1Byb2plY3Rpb24gPSBNYXQ0LmludmVydCh0aGlzLnZpZXdQcm9qZWN0aW9uLCBtYXQ0KVxuICAgIGlmIChpbnZlcnRlZFZpZXdQcm9qZWN0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IGNsaXBTcGFjZSA9IFZlYzQuc2V0KFxuICAgICAgKHggLyB2aWV3U2l6ZS53aWR0aCkgKiAyIC0gMSwgKCh5IC8gdmlld1NpemUuaGVpZ2h0KSAqIDIgLSAxKSAqIC0xLCAxLCAxLCB2ZWM0XG4gICAgKVxuICAgIHRoaXMuZmFyID0gZmFyXG5cbiAgICBsZXQgd29ybGRTcGFjZSA9IFZlYzQudHJhbnNmb3JtTWF0NChjbGlwU3BhY2UsIGludmVydGVkVmlld1Byb2plY3Rpb24sIHZlYzQpXG4gICAgd29ybGRTcGFjZVszXSA9IDEuMCAvIHdvcmxkU3BhY2VbM11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgd29ybGRTcGFjZVtpXSAqPSB3b3JsZFNwYWNlWzNdXG4gICAgfVxuICAgIHJldHVybiBwb2ludC5zZXQod29ybGRTcGFjZVswXSwgd29ybGRTcGFjZVsxXSwgd29ybGRTcGFjZVsyXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB3b3JsZCBjb29yZGluYXRlcyB0byBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB4IFdvcmxkIHggY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHkgV29ybGQgeSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0geiBXb3JsZCB6IGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSBwb2ludCBQb2ludCB0byBzZXQuXG4gICAqIEBwYXJhbSB2aWV3U2l6ZSBUaGUgc2l6ZSBvZiB0aGUgdmlldyB3aGVuIG5vdCByZW5kZXJpbmcgdG8gdGhlIGVudGlyZSBzY3JlZW4uXG4gICAqL1xuICB3b3JsZFRvU2NyZWVuKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIsIHBvaW50ID0gbmV3IFBJWEkuUG9pbnQoKSwgdmlld1NpemU6IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSA9IHRoaXMucmVuZGVyZXIuc2NyZWVuKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0cmFuc2Zvcm0gaXMgdXBkYXRlZCBpbiBjYXNlIHNvbWV0aGluZyBoYXMgYmVlbiBjaGFuZ2VkLCBcbiAgICAvLyBvdGhlcndpc2UgaXQgbWF5IGJlIHVzaW5nIHdyb25nIHZhbHVlcy5cbiAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQ/LnRyYW5zZm9ybSlcblxuICAgIGxldCB3b3JsZFNwYWNlID0gVmVjNC5zZXQoeCwgeSwgeiwgMSwgdmVjNClcbiAgICBsZXQgY2xpcFNwYWNlID0gVmVjNC50cmFuc2Zvcm1NYXQ0KFxuICAgICAgVmVjNC50cmFuc2Zvcm1NYXQ0KHdvcmxkU3BhY2UsIHRoaXMudmlldywgdmVjNCksIHRoaXMucHJvamVjdGlvbiwgdmVjNFxuICAgIClcbiAgICBpZiAoY2xpcFNwYWNlWzNdICE9PSAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBjbGlwU3BhY2VbaV0gLz0gY2xpcFNwYWNlWzNdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb2ludC5zZXQoKFxuICAgICAgY2xpcFNwYWNlWzBdICsgMSkgLyAyICogdmlld1NpemUud2lkdGgsIHZpZXdTaXplLmhlaWdodCAtIChjbGlwU3BhY2VbMV0gKyAxKSAvIDIgKiB2aWV3U2l6ZS5oZWlnaHQpXG4gIH1cblxuICBwcml2YXRlIF9maWVsZE9mVmlldyA9IDYwXG4gIHByaXZhdGUgX25lYXIgPSAwLjFcbiAgcHJpdmF0ZSBfZmFyID0gMTAwMFxuICBwcml2YXRlIF9hc3BlY3Q/OiBudW1iZXJcblxuICAvKipcbiAgICogVGhlIGFzcGVjdCByYXRpbyAod2lkdGggZGl2aWRlZCBieSBoZWlnaHQpLiBJZiBub3Qgc2V0LCB0aGUgYXNwZWN0IHJhdGlvIG9mIFxuICAgKiB0aGUgcmVuZGVyZXIgd2lsbCBiZSB1c2VkIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBnZXQgYXNwZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9hc3BlY3RcbiAgfVxuXG4gIHNldCBhc3BlY3QodmFsdWU6IG51bWJlciB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLl9hc3BlY3QgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9hc3BlY3QgPSB2YWx1ZTsgdGhpcy5fdHJhbnNmb3JtSWQrK1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGUgdmVydGljYWwgZmllbGQgb2YgdmlldyBpbiBkZWdyZWVzLCA2MCBpcyB0aGUgZGVmYXVsdCB2YWx1ZS4gKi9cbiAgZ2V0IGZpZWxkT2ZWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9maWVsZE9mVmlld1xuICB9XG5cbiAgc2V0IGZpZWxkT2ZWaWV3KHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5fZmllbGRPZlZpZXcgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9maWVsZE9mVmlldyA9IHZhbHVlOyB0aGlzLl90cmFuc2Zvcm1JZCsrXG4gICAgfVxuICB9XG5cbiAgLyoqIFRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIGRpc3RhbmNlLCAwLjEgaXMgdGhlIGRlZmF1bHQgdmFsdWUuICovXG4gIGdldCBuZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9uZWFyXG4gIH1cblxuICBzZXQgbmVhcih2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX25lYXIgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9uZWFyID0gdmFsdWU7IHRoaXMuX3RyYW5zZm9ybUlkKytcbiAgICB9XG4gIH1cblxuICAvKiogVGhlIGZhciBjbGlwcGluZyBwbGFuZSBkaXN0YW5jZSwgMTAwMCBpcyB0aGUgZGVmYXVsdCB2YWx1ZS4gKi9cbiAgZ2V0IGZhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmFyXG4gIH1cblxuICBzZXQgZmFyKHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5fZmFyICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZmFyID0gdmFsdWU7IHRoaXMuX3RyYW5zZm9ybUlkKytcbiAgICB9XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgcHJvamVjdGlvbiBtYXRyaXguICovXG4gIGdldCBwcm9qZWN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcHJvamVjdGlvbikge1xuICAgICAgdGhpcy5fcHJvamVjdGlvbiA9IG5ldyBNYXRyaXhDb21wb25lbnQodGhpcywgMTYsIGRhdGEgPT4ge1xuICAgICAgICBjb25zdCBhc3BlY3QgPSB0aGlzLl9hc3BlY3QgfHwgdGhpcy5yZW5kZXJlci53aWR0aCAvIHRoaXMucmVuZGVyZXIuaGVpZ2h0XG4gICAgICAgIGlmICh0aGlzLl9vcnRob2dyYXBoaWMpIHtcbiAgICAgICAgICBNYXQ0Lm9ydGhvKC10aGlzLl9vcnRob2dyYXBoaWNTaXplICogYXNwZWN0LCB0aGlzLl9vcnRob2dyYXBoaWNTaXplICogYXNwZWN0LCAtdGhpcy5fb3J0aG9ncmFwaGljU2l6ZSwgdGhpcy5fb3J0aG9ncmFwaGljU2l6ZSwgdGhpcy5fbmVhciwgdGhpcy5fZmFyLCBkYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE1hdDQucGVyc3BlY3RpdmUodGhpcy5fZmllbGRPZlZpZXcgKiBQSVhJLkRFR19UT19SQUQsIGFzcGVjdCwgdGhpcy5fbmVhciwgdGhpcy5fZmFyLCBkYXRhKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdGlvbi5hcnJheVxuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHZpZXcgbWF0cml4LiAqL1xuICBnZXQgdmlldygpIHtcbiAgICBpZiAoIXRoaXMuX3ZpZXcpIHtcbiAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgTWF0cml4Q29tcG9uZW50KHRoaXMsIDE2LCBkYXRhID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gVmVjMy5hZGQoXG4gICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5wb3NpdGlvbiwgdGhpcy53b3JsZFRyYW5zZm9ybS5mb3J3YXJkLCB2ZWMzKVxuICAgICAgICBNYXQ0Lmxvb2tBdCh0aGlzLndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uLFxuICAgICAgICAgIHRhcmdldCwgdGhpcy53b3JsZFRyYW5zZm9ybS51cCwgZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92aWV3LmFycmF5XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgdmlldyBwcm9qZWN0aW9uIG1hdHJpeC4gKi9cbiAgZ2V0IHZpZXdQcm9qZWN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fdmlld1Byb2plY3Rpb24pIHtcbiAgICAgIHRoaXMuX3ZpZXdQcm9qZWN0aW9uID0gbmV3IE1hdHJpeENvbXBvbmVudCh0aGlzLCAxNiwgZGF0YSA9PiB7XG4gICAgICAgIE1hdDQubXVsdGlwbHkodGhpcy5wcm9qZWN0aW9uLCB0aGlzLnZpZXcsIGRhdGEpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmlld1Byb2plY3Rpb24uYXJyYXlcbiAgfVxufVxuXG5QSVhJLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKFwiY2FtZXJhXCIsIENhbWVyYSkiLCIvKipcbiAqIFJlcHJlc2VudHMgYSBjb2xvciBjb250YWluaW5nIFJHQkEgY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbG9yIHtcbiAgcHJpdmF0ZSBfYXJyYXk0OiBGbG9hdDMyQXJyYXlcbiAgcHJpdmF0ZSBfYXJyYXkzOiBGbG9hdDMyQXJyYXlcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb2xvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29tcG9uZW50cyAoaW4gcmFuZ2UgMC0xKS5cbiAgICogQHBhcmFtIHIgVGhlIFIgKHJlZCkgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZyBUaGUgRyAoZ3JlZW4pIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGIgVGhlIEIgKGJsdWUpIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGEgVGhlIEEgKGFscGhhKSBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMSkge1xuICAgIHRoaXMuX2FycmF5NCA9IG5ldyBGbG9hdDMyQXJyYXkoW3IsIGcsIGIsIGFdKVxuICAgIHRoaXMuX2FycmF5MyA9IHRoaXMuX2FycmF5NC5zdWJhcnJheSgwLCAzKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29sb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbXBvbmVudHMgKGluIHJhbmdlIDAtMjU1KS5cbiAgICogQHBhcmFtIHIgVGhlIFIgKHJlZCkgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZyBUaGUgRyAoZ3JlZW4pIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGIgVGhlIEIgKGJsdWUpIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGEgVGhlIEEgKGFscGhhKSBjb21wb25lbnQuXG4gICAqL1xuICBzdGF0aWMgZnJvbUJ5dGVzKHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAyNTUpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKHIgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTUsIGEgLyAyNTUpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb2xvciBmcm9tIHRoZSBzcGVjaWZpZWQgaGV4IHZhbHVlLlxuICAgKiBAcGFyYW0gaGV4IFRoZSBoZXggdmFsdWUgYXMgYSBzdHJpbmcgb3IgYSBudW1iZXIuXG4gICAqL1xuICBzdGF0aWMgZnJvbUhleChoZXg6IG51bWJlciB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoZXggPSBwYXJzZUludChoZXgucmVwbGFjZSgvW14wLTlBLUZdL2dpLCBcIlwiKSwgMTYpXG4gICAgfVxuICAgIHJldHVybiBDb2xvci5mcm9tQnl0ZXMoKGhleCA+PiAxNikgJiAyNTUsIChoZXggPj4gOCkgJiAyNTUsIGhleCAmIDI1NSlcbn1cblxuICAvKiogVGhlIGNvbG9yIGFzIGFuIHR5cGVkIGFycmF5IGNvbnRhaW5pbmcgUkdCLiAqL1xuICBnZXQgcmdiKCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheTNcbiAgfVxuXG4gIC8qKiBUaGUgY29sb3IgYXMgYW4gdHlwZWQgYXJyYXkgY29udGFpbmluZyBSR0JBLiAqL1xuICBnZXQgcmdiYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXk0XG4gIH1cblxuICAvKiogVGhlIFIgKHJlZCkgY29tcG9uZW50LiAqL1xuICBnZXQgcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXk0WzBdXG4gIH1cblxuICBzZXQgcih2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fYXJyYXk0WzBdID0gdmFsdWVcbiAgfVxuXG4gIC8qKiBUaGUgRyAoZ3JlZW4pIGNvbXBvbmVudC4gKi9cbiAgZ2V0IGcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5NFsxXVxuICB9XG5cbiAgc2V0IGcodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX2FycmF5NFsxXSA9IHZhbHVlXG4gIH1cblxuICAvKiogVGhlIEIgKGJsdWUpIGNvbXBvbmVudC4gKi9cbiAgZ2V0IGIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5NFsyXVxuICB9XG5cbiAgc2V0IGIodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX2FycmF5NFsyXSA9IHZhbHVlXG4gIH1cblxuICAvKiogVGhlIEEgKGFscGhhKSBjb21wb25lbnQuICovXG4gIGdldCBhKCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheTRbM11cbiAgfVxuXG4gIHNldCBhKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9hcnJheTRbM10gPSB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29sb3IgZnJvbSB0aGUgc3BlY2lmaWVkIHNvdXJjZS5cbiAgICogQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIHRvIGNyZWF0ZSB0aGUgY29sb3IgZnJvbS5cbiAgICovXG4gIHN0YXRpYyBmcm9tKHNvdXJjZTogbnVtYmVyW10gfCBGbG9hdDMyQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKC4uLnNvdXJjZSlcbiAgfVxufSIsImV4cG9ydCBuYW1lc3BhY2UgQ29uc29sZSB7XG4gIGxldCBtZXNzYWdlczogc3RyaW5nW10gPSBbXVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBpZiAobWVzc2FnZXMuaW5jbHVkZXMobWVzc2FnZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpXG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IE9ic2VydmFibGVRdWF0ZXJuaW9uIH0gZnJvbSBcIi4vdHJhbnNmb3JtL29ic2VydmFibGUtcXVhdGVybmlvblwiXG5pbXBvcnQgeyBUcmFuc2Zvcm0zRCB9IGZyb20gXCIuL3RyYW5zZm9ybS90cmFuc2Zvcm1cIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZVBvaW50M0QgfSBmcm9tIFwiLi90cmFuc2Zvcm0vb2JzZXJ2YWJsZS1wb2ludFwiXG5cbi8qKlxuICogQSBjb250YWluZXIgcmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgM0Qgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRhaW5lcjNEIGV4dGVuZHMgUElYSS5Db250YWluZXIge1xuICB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtM0QoKVxuXG4gIHNldCBwb3NpdGlvbih2YWx1ZTogT2JzZXJ2YWJsZVBvaW50M0QpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSlcbiAgfVxuXG4gIGdldCBwb3NpdGlvbigpOiBPYnNlcnZhYmxlUG9pbnQzRCB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uXG4gIH1cblxuICBzZXQgc2NhbGUodmFsdWU6IE9ic2VydmFibGVQb2ludDNEKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUuY29weUZyb20odmFsdWUpXG4gIH1cblxuICBnZXQgc2NhbGUoKTogT2JzZXJ2YWJsZVBvaW50M0Qge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5zY2FsZVxuICB9XG5cbiAgc2V0IHJvdGF0aW9uUXVhdGVybmlvbih2YWx1ZTogT2JzZXJ2YWJsZVF1YXRlcm5pb24pIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvblF1YXRlcm5pb24uY29weUZyb20odmFsdWUpXG4gIH1cblxuICAvKiogVGhlIHF1YXRlcm5pb24gcm90YXRpb24gb2YgdGhlIG9iamVjdC4gKi9cbiAgZ2V0IHJvdGF0aW9uUXVhdGVybmlvbigpOiBPYnNlcnZhYmxlUXVhdGVybmlvbiB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uUXVhdGVybmlvblxuICB9XG5cbiAgLyoqIFRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0IG9uIHRoZSB6IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIFxuICAgKiBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LiAqL1xuICBnZXQgeigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24uelxuICB9XG5cbiAgc2V0IHoodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLnogPSB2YWx1ZVxuICB9XG5cbiAgZ2V0IGxvY2FsVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybVxuICB9XG5cbiAgZ2V0IHdvcmxkVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IEN1YmVSZXNvdXJjZSB9IGZyb20gXCIuLi9waXhpL2N1YmUtcmVzb3VyY2VcIlxuaW1wb3J0IHsgTWlwbWFwUmVzb3VyY2UgfSBmcm9tIFwiLi9taXBtYXAtcmVzb3VyY2VcIlxuXG5leHBvcnQgdHlwZSBNaXBtYXBSZXNvdXJjZUFycmF5ID0gW1xuICBNaXBtYXBSZXNvdXJjZSxcbiAgTWlwbWFwUmVzb3VyY2UsXG4gIE1pcG1hcFJlc291cmNlLFxuICBNaXBtYXBSZXNvdXJjZSxcbiAgTWlwbWFwUmVzb3VyY2UsXG4gIE1pcG1hcFJlc291cmNlXG5dXG5cbmV4cG9ydCBjbGFzcyBDdWJlbWFwUmVzb3VyY2UgZXh0ZW5kcyBDdWJlUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IE1pcG1hcFJlc291cmNlQXJyYXksIHB1YmxpYyBsZXZlbHMgPSAxKSB7XG4gICAgc3VwZXIoc291cmNlKVxuICB9XG5cbiAgc3R5bGUocmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICBsZXQgZ2wgPSByZW5kZXJlci5nbFxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgICBpZiAodGhpcy5sZXZlbHMgPiAxKSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgTWlwbWFwUmVzb3VyY2UgfSBmcm9tIFwiLi9taXBtYXAtcmVzb3VyY2VcIlxuaW1wb3J0IHsgQ3ViZW1hcFJlc291cmNlLCBNaXBtYXBSZXNvdXJjZUFycmF5IH0gZnJvbSBcIi4vY3ViZW1hcC1yZXNvdXJjZVwiXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuLi9jb2xvclwiXG5pbXBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9IGZyb20gXCIuLi9waXhpL2J1ZmZlci1yZXNvdXJjZVwiXG5pbXBvcnQgeyBDdWJlbWFwRmFjZXMgfSBmcm9tIFwiLi9jdWJlbWFwLWZhY2VzXCJcblxuLyoqXG4gKiBDdWJlbWFwIHdoaWNoIHN1cHBvcnRzIG11bHRpcGxlIHVzZXIgc3BlY2lmaWVkIG1pcG1hcHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDdWJlbWFwIGV4dGVuZHMgUElYSS5CYXNlVGV4dHVyZTxDdWJlbWFwUmVzb3VyY2U+IHtcblxuICAvKiogUmV0dXJucyBhbiBhcnJheSBvZiBmYWNlcy4gKi9cbiAgc3RhdGljIGdldCBmYWNlcygpOiBbXCJwb3N4XCIsIFwibmVneFwiLCBcInBvc3lcIiwgXCJuZWd5XCIsIFwicG9zelwiLCBcIm5lZ3pcIl0ge1xuICAgIHJldHVybiBbXCJwb3N4XCIsIFwibmVneFwiLCBcInBvc3lcIiwgXCJuZWd5XCIsIFwicG9zelwiLCBcIm5lZ3pcIl1cbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlwbWFwIGxldmVscy4gKi9cbiAgZ2V0IGxldmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZS5sZXZlbHNcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGN1YmVtYXAgZnJvbSB0aGUgc3BlY2lmaWVkIGZhY2VzLlxuICAgKiBAcGFyYW0gZmFjZXMgVGhlIGZhY2VzIHRvIGNyZWF0ZSB0aGUgY3ViZW1hcCBmcm9tLlxuICAgKi9cbiAgc3RhdGljIGZyb21GYWNlcyhmYWNlczogQ3ViZW1hcEZhY2VzIHwgQ3ViZW1hcEZhY2VzW10pIHtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmlzQXJyYXkoZmFjZXMpID8gZmFjZXMgOiBbZmFjZXNdXG4gICAgY29uc3QgcmVzb3VyY2VzID0gPE1pcG1hcFJlc291cmNlQXJyYXk+Q3ViZW1hcC5mYWNlcy5tYXAoKGZhY2UsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gbmV3IE1pcG1hcFJlc291cmNlKGFycmF5Lm1hcChmID0+IGZbZmFjZV0pLFxuICAgICAgICBQSVhJLlRBUkdFVFMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaW5kZXgpXG4gICAgfSlcbiAgICByZXR1cm4gbmV3IEN1YmVtYXAoXG4gICAgICBuZXcgQ3ViZW1hcFJlc291cmNlKHJlc291cmNlcywgYXJyYXkubGVuZ3RoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGN1YmVtYXAgZnJvbSB0aGUgc3BlY2lmaWVkIGNvbG9ycy5cbiAgICogQHBhcmFtIHBvc3ggVGhlIGNvbG9yIGZvciBwb3NpdGl2ZSB4LlxuICAgKiBAcGFyYW0gbmVneCBUaGUgY29sb3IgZm9yIG5lZ2F0aXZlIHguXG4gICAqIEBwYXJhbSBwb3N5IFRoZSBjb2xvciBmb3IgcG9zaXRpdmUgeS5cbiAgICogQHBhcmFtIG5lZ3kgVGhlIGNvbG9yIGZvciBuZWdhdGl2ZSB5LlxuICAgKiBAcGFyYW0gcG9zeiBUaGUgY29sb3IgZm9yIHBvc2l0aXZlIHouXG4gICAqIEBwYXJhbSBuZWd6IFRoZSBjb2xvciBmb3IgbmVnYXRpdmUgei5cbiAgICovXG4gIHN0YXRpYyBmcm9tQ29sb3JzKHBvc3g6IENvbG9yLCBuZWd4ID0gcG9zeCwgcG9zeSA9IHBvc3gsIG5lZ3kgPSBwb3N4LCBwb3N6ID0gcG9zeCwgbmVneiA9IHBvc3gpIHtcbiAgICBjb25zdCByZXNvdXJjZXM6IE1pcG1hcFJlc291cmNlW10gPSBbXVxuICAgIGNvbnN0IGNvbG9ycyA9IFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBCdWZmZXJSZXNvdXJjZShcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoY29sb3JzW2ldLnJnYmEubWFwKGMgPT4gYyAqIDI1NSkpLCB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSlcbiAgICAgIGxldCB0ZXh0dXJlID0gbmV3IFBJWEkuVGV4dHVyZShuZXcgUElYSS5CYXNlVGV4dHVyZShyZXNvdXJjZSwge1xuICAgICAgICB0eXBlOiBQSVhJLlRZUEVTLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIGZvcm1hdDogUElYSS5GT1JNQVRTLlJHQixcbiAgICAgICAgYWxwaGFNb2RlOiBQSVhJLkFMUEhBX01PREVTLk5PX1BSRU1VTFRJUExJRURfQUxQSEEsXG4gICAgICB9KSlcbiAgICAgIHJlc291cmNlcy5wdXNoKG5ldyBNaXBtYXBSZXNvdXJjZShbdGV4dHVyZV0sXG4gICAgICAgIFBJWEkuVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpKSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDdWJlbWFwKFxuICAgICAgbmV3IEN1YmVtYXBSZXNvdXJjZSg8TWlwbWFwUmVzb3VyY2VBcnJheT5yZXNvdXJjZXMsIDEpKVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IEFycmF5UmVzb3VyY2UgfSBmcm9tIFwiLi4vcGl4aS9hcnJheS1yZXNvdXJjZVwiXG5pbXBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gXCIuLi9waXhpL2Jhc2UtaW1hZ2UtcmVzb3VyY2VcIlxuaW1wb3J0IHsgQnVmZmVyUmVzb3VyY2UgfSBmcm9tIFwiLi4vcGl4aS9idWZmZXItcmVzb3VyY2VcIlxuXG5leHBvcnQgY2xhc3MgTWlwbWFwUmVzb3VyY2UgZXh0ZW5kcyBBcnJheVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlOiAoc3RyaW5nIHwgUElYSS5UZXh0dXJlKVtdLCBwdWJsaWMgdGFyZ2V0OiBudW1iZXIpIHtcbiAgICBzdXBlcihzb3VyY2UpXG4gIH1cblxuICB1cGxvYWQocmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIsIGJhc2VUZXh0dXJlOiBQSVhJLkJhc2VUZXh0dXJlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMuaXRlbXNbaV0ucmVzb3VyY2VcbiAgICAgIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIEJ1ZmZlclJlc291cmNlKSB7XG4gICAgICAgIHJlbmRlcmVyLmdsLnRleEltYWdlMkQodGhpcy50YXJnZXQsIGksIDxQSVhJLkZPUk1BVFM+YmFzZVRleHR1cmUuZm9ybWF0LFxuICAgICAgICAgIHJlc291cmNlLndpZHRoLCByZXNvdXJjZS5oZWlnaHQsIDAsIDxQSVhJLkZPUk1BVFM+YmFzZVRleHR1cmUuZm9ybWF0LCA8UElYSS5UWVBFUz5iYXNlVGV4dHVyZS50eXBlLCByZXNvdXJjZS5kYXRhKVxuICAgICAgfVxuICAgICAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgQmFzZUltYWdlUmVzb3VyY2UpIHtcbiAgICAgICAgcmVuZGVyZXIuZ2wudGV4SW1hZ2UyRCh0aGlzLnRhcmdldCwgaSwgPFBJWEkuRk9STUFUUz5iYXNlVGV4dHVyZS5mb3JtYXQsXG4gICAgICAgICAgPFBJWEkuRk9STUFUUz5iYXNlVGV4dHVyZS5mb3JtYXQsIDxQSVhJLlRZUEVTPmJhc2VUZXh0dXJlLnR5cGUsIHJlc291cmNlLnNvdXJjZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufSIsImltcG9ydCB7IEFuaW1hdGlvbiB9IGZyb20gXCIuLi8uLi9hbmltYXRpb25cIlxuaW1wb3J0IHsgZ2xURkNoYW5uZWwgfSBmcm9tIFwiLi9nbHRmLWNoYW5uZWxcIlxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYW5pbWF0aW9uIGxvYWRlZCBmcm9tIGEgZ2xURiBtb2RlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIGdsVEZBbmltYXRpb24gZXh0ZW5kcyBBbmltYXRpb24ge1xuICBwcml2YXRlIF9kdXJhdGlvbiA9IDBcbiAgcHJpdmF0ZSBfcG9zaXRpb24gPSAwXG4gIHByaXZhdGUgX2NoYW5uZWxzOiBnbFRGQ2hhbm5lbFtdID0gW11cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBnbFRGIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIGNoYW5uZWxzIFRoZSBjaGFubmVscyB1c2VkIGJ5IHRoaXMgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBmb3IgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNoYW5uZWxzOiBnbFRGQ2hhbm5lbFtdLCBuYW1lPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobmFtZSlcbiAgICBmb3IgKGxldCBjaGFubmVsIG9mIGNoYW5uZWxzKSB7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGgubWF4KHRoaXMuX2R1cmF0aW9uLCBjaGFubmVsLmR1cmF0aW9uKVxuICAgIH1cbiAgICB0aGlzLl9jaGFubmVscyA9IGNoYW5uZWxzXG4gIH1cblxuICAvKiogVGhlIGR1cmF0aW9uIChpbiBzZWNvbmRzKSBvZiB0aGlzIGFuaW1hdGlvbi4gKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kdXJhdGlvblxuICB9XG5cbiAgLyoqIFRoZSBjdXJyZW50IHBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiB0aGlzIGFuaW1hdGlvbi4gKi9cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblxuICB9XG5cbiAgc2V0IHBvc2l0aW9uKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IHZhbHVlXG4gICAgZm9yIChsZXQgY2hhbm5lbCBvZiB0aGlzLl9jaGFubmVscykge1xuICAgICAgY2hhbm5lbC5wb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uXG4gICAgfVxuICB9XG59XG5cbiIsIi8qKlxuICogUmVwcmVzZW50cyBhbiBnbFRGIGFuaW1hdGlvbiBjaGFubmVsIHdoaWNoIHRhcmdldHMgYSBzcGVjaWZpYyBub2RlLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgZ2xURkNoYW5uZWwge1xuICBwcml2YXRlIF9wb3NpdGlvbiA9IDBcbiAgcHJpdmF0ZSBfZnJhbWUgPSAwXG4gIHByaXZhdGUgX2ludGVycG9sYXRpb246IGdsVEZJbnRlcnBvbGF0aW9uXG4gIHByaXZhdGUgX2lucHV0OiBBcnJheUxpa2U8bnVtYmVyPlxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNoYW5uZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0IGFuZCBpbnRlcnBvbGF0aW9uLlxuICAgKiBAcGFyYW0gaW5wdXQgQW4gYXJyYXkgb2YgaW5wdXRzIHJlcHJlc2VudGluZyBsaW5lYXIgdGltZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBUaGUgaW50ZXJwb2xhdGlvbiBtZXRob2QgdG8gdXNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5wdXQ6IEFycmF5TGlrZTxudW1iZXI+LCBpbnRlcnBvbGF0aW9uOiBnbFRGSW50ZXJwb2xhdGlvbikge1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXRcbiAgICB0aGlzLl9pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvblxuICB9XG5cbiAgLyoqIFRoZSBwb3NpdGlvbiAoaW4gc2Vjb25kcykgZm9yIHRoaXMgY2hhbm5lbC4gKi9cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblxuICB9XG5cbiAgc2V0IHBvc2l0aW9uKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLnNldFBvc2l0aW9uKHZhbHVlKVxuICB9XG5cbiAgLyoqIFRoZSBkdXJhdGlvbiAoaW4gc2Vjb25kcykgZm9yIHRoaXMgY2hhbm5lbC4gKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dFt0aGlzLl9pbnB1dC5sZW5ndGggLSAxXVxuICB9XG5cbiAgLyoqIFRoZSBjdXJyZW50IGZyYW1lIGZvciB0aGlzIGNoYW5uZWwuICovXG4gIGdldCBmcmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJhbWVcbiAgfVxuXG4gIC8qKiBUaGUgbnVtYmVyIG9mIGZyYW1lcyBmb3IgdGhpcyBjaGFubmVsLiAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dC5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgdXBkYXRlcyB0aGUgY3VycmVudCBmcmFtZSBhbmQgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIHNldCBmb3IgdGhpcyBjaGFubmVsLlxuICAgKi9cbiAgc2V0UG9zaXRpb24ocG9zaXRpb246IG51bWJlcikge1xuICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb25cbiAgICB0aGlzLl9mcmFtZSA9IHRoaXMuY2FsY3VsYXRlRnJhbWUodGhpcy5fcG9zaXRpb24pXG4gICAgdGhpcy51cGRhdGVUYXJnZXQoXG4gICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uLmludGVycG9sYXRlKFxuICAgICAgICB0aGlzLl9mcmFtZSwgdGhpcy5jYWxjdWxhdGVGcmFtZVBvc2l0aW9uKHRoaXMuX2ZyYW1lLCB0aGlzLl9wb3NpdGlvbikpKVxuICB9XG5cbiAgYWJzdHJhY3QgdXBkYXRlVGFyZ2V0KGRhdGE6IEFycmF5TGlrZTxudW1iZXI+KTogdm9pZFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjaGFubmVsIHdpdGggdGhlIHNwZWNpZmllZCBkZWx0YSB0aW1lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSBkZWx0YSBUaGUgdGltZSAoaW4gc2Vjb25kcykgc2luY2UgbGFzdCBmcmFtZS5cbiAgICovXG4gIHVwZGF0ZShkZWx0YTogbnVtYmVyKSB7XG4gICAgdGhpcy5wb3NpdGlvbiArPSBkZWx0YVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGZyYW1lLlxuICAgKiBAcGFyYW0gZnJhbWUgVGhlIGZyYW1lIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4uXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhpcyBjaGFubmVsLlxuICAgKi9cbiAgY2FsY3VsYXRlRnJhbWVQb3NpdGlvbihmcmFtZTogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgaWYgKGZyYW1lID09PSB0aGlzLl9pbnB1dC5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gKHBvc2l0aW9uIC0gdGhpcy5faW5wdXRbZnJhbWVdKSAvICh0aGlzLl9pbnB1dFtmcmFtZSArIDFdIC0gdGhpcy5faW5wdXRbZnJhbWVdKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgZnJhbWUgZm9yIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhpcyBjaGFubmVsLlxuICAgKi9cbiAgY2FsY3VsYXRlRnJhbWUocG9zaXRpb246IG51bWJlcikge1xuICAgIGlmIChwb3NpdGlvbiA8IHRoaXMuX2lucHV0WzBdKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKHBvc2l0aW9uID49IHRoaXMuX2lucHV0W2ldICYmIHBvc2l0aW9uIDwgdGhpcy5faW5wdXRbaSArIDFdKSB7XG4gICAgICAgIHJldHVybiBpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnB1dC5sZW5ndGggLSAxXG4gIH1cblxuICBzdGF0aWMgZnJvbShpbnB1dDogQXJyYXlMaWtlPG51bWJlcj4sIG91dHB1dDogQXJyYXlMaWtlPG51bWJlcj4sIGludGVycG9sYXRpb246IHN0cmluZywgcGF0aDogc3RyaW5nLCB0YXJnZXQ6IENvbnRhaW5lcjNEKSB7XG4gICAgaWYgKHBhdGggPT09IFwidHJhbnNsYXRpb25cIikge1xuICAgICAgcmV0dXJuIG5ldyBnbFRGVHJhbnNsYXRpb24odGFyZ2V0LnRyYW5zZm9ybSwgaW5wdXQsXG4gICAgICAgIGdsVEZJbnRlcnBvbGF0aW9uLmZyb20oaW50ZXJwb2xhdGlvbiwgaW5wdXQsIG91dHB1dCwgMykpXG4gICAgfVxuICAgIGlmIChwYXRoID09PSBcInNjYWxlXCIpIHtcbiAgICAgIHJldHVybiBuZXcgZ2xURlNjYWxlKHRhcmdldC50cmFuc2Zvcm0sIGlucHV0LFxuICAgICAgICBnbFRGSW50ZXJwb2xhdGlvbi5mcm9tKGludGVycG9sYXRpb24sIGlucHV0LCBvdXRwdXQsIDMpKVxuICAgIH1cbiAgICBpZiAocGF0aCA9PT0gXCJyb3RhdGlvblwiKSB7XG4gICAgICBpZiAoaW50ZXJwb2xhdGlvbiA9PT0gXCJMSU5FQVJcIikge1xuICAgICAgICByZXR1cm4gbmV3IGdsVEZSb3RhdGlvbih0YXJnZXQudHJhbnNmb3JtLCBpbnB1dCxcbiAgICAgICAgICBuZXcgZ2xURlNwaGVyaWNhbExpbmVhcihvdXRwdXQpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBnbFRGUm90YXRpb24odGFyZ2V0LnRyYW5zZm9ybSwgaW5wdXQsXG4gICAgICAgIGdsVEZJbnRlcnBvbGF0aW9uLmZyb20oaW50ZXJwb2xhdGlvbiwgaW5wdXQsIG91dHB1dCwgNCkpXG4gICAgfVxuICAgIGlmIChwYXRoID09PSBcIndlaWdodHNcIikge1xuICAgICAgbGV0IHdlaWdodHMgPSAoPE1lc2gzRD50YXJnZXQuY2hpbGRyZW5bMF0pLm1vcnBoV2VpZ2h0c1xuICAgICAgaWYgKCF3ZWlnaHRzKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZ2xURldlaWdodHMod2VpZ2h0cywgaW5wdXQsXG4gICAgICAgIGdsVEZJbnRlcnBvbGF0aW9uLmZyb20oaW50ZXJwb2xhdGlvbiwgaW5wdXQsIG91dHB1dCwgd2VpZ2h0cy5sZW5ndGgpKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFBJWEkzRDogVW5rbm93biBjaGFubmVsIHBhdGggXCIke3BhdGh9XCJgKVxuICB9XG59XG5cbi8vIEZpeGVzIGNpcmN1bGFyIGRlcGVuZGVuY3kgaW4gd2VicGFja1xuaW1wb3J0IHsgQ29udGFpbmVyM0QgfSBmcm9tIFwiLi4vLi4vY29udGFpbmVyXCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuLi8uLi9tZXNoL21lc2hcIlxuaW1wb3J0IHsgZ2xURkludGVycG9sYXRpb24gfSBmcm9tIFwiLi9nbHRmLWludGVycG9sYXRpb25cIlxuaW1wb3J0IHsgZ2xURlNwaGVyaWNhbExpbmVhciB9IGZyb20gXCIuL2dsdGYtc3BoZXJpY2FsLWxpbmVhclwiXG5pbXBvcnQgeyBnbFRGU2NhbGUgfSBmcm9tIFwiLi9nbHRmLXNjYWxlXCJcbmltcG9ydCB7IGdsVEZXZWlnaHRzIH0gZnJvbSBcIi4vZ2x0Zi13ZWlnaHRzXCJcbmltcG9ydCB7IGdsVEZSb3RhdGlvbiB9IGZyb20gXCIuL2dsdGYtcm90YXRpb25cIlxuaW1wb3J0IHsgZ2xURlRyYW5zbGF0aW9uIH0gZnJvbSBcIi4vZ2x0Zi10cmFuc2xhdGlvblwiIiwiaW1wb3J0IHsgZ2xURkludGVycG9sYXRpb24gfSBmcm9tIFwiLi9nbHRmLWludGVycG9sYXRpb25cIlxuXG5leHBvcnQgY2xhc3MgZ2xURkN1YmljU3BsaW5lIGV4dGVuZHMgZ2xURkludGVycG9sYXRpb24ge1xuICBwcml2YXRlIF9kYXRhOiBGbG9hdDMyQXJyYXlcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pbnB1dDogQXJyYXlMaWtlPG51bWJlcj4sIHByaXZhdGUgX291dHB1dDogQXJyYXlMaWtlPG51bWJlcj4sIHByaXZhdGUgX3N0cmlkZTogbnVtYmVyKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KF9zdHJpZGUpXG4gIH1cblxuICBpbnRlcnBvbGF0ZShmcmFtZTogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgY29uc3QgZGlmZiA9IHRoaXMuX2lucHV0W2ZyYW1lICsgMV0gLSB0aGlzLl9pbnB1dFtmcmFtZV1cbiAgICBjb25zdCBwb3MxID0gKGZyYW1lICsgMCkgKiB0aGlzLl9zdHJpZGUgKiAzXG4gICAgY29uc3QgcG9zMiA9IChmcmFtZSArIDEpICogdGhpcy5fc3RyaWRlICogM1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc3RyaWRlOyBpKyspIHtcbiAgICAgIHRoaXMuX2RhdGFbaV0gPSBnbFRGQ3ViaWNTcGxpbmUuY2FsY3VsYXRlKFxuICAgICAgICBwb3NpdGlvbiwgdGhpcy5fb3V0cHV0W3BvczEgKyBpICsgMSAqIHRoaXMuX3N0cmlkZV0sIHRoaXMuX291dHB1dFtwb3MyICsgaSArIDEgKiB0aGlzLl9zdHJpZGVdLCBkaWZmICogdGhpcy5fb3V0cHV0W3BvczIgKyBpXSwgZGlmZiAqIHRoaXMuX291dHB1dFtwb3MxICsgaSArIDIgKiB0aGlzLl9zdHJpZGVdKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9XG5cbiAgc3RhdGljIGNhbGN1bGF0ZSh0OiBudW1iZXIsIHAwOiBudW1iZXIsIHAxOiBudW1iZXIsIG0wOiBudW1iZXIsIG0xOiBudW1iZXIpIHtcbiAgICByZXR1cm4gKCgyICogKHQgKiogMykgLSAzICogKHQgKiogMikgKyAxKSAqIHAwKSArICgoKHQgKiogMykgLSAyICogKHQgKiogMikgKyB0KSAqIG0wKSArICgoLTIgKiAodCAqKiAzKSArIDMgKiAodCAqKiAyKSkgKiBwMSkgKyAoKCh0ICoqIDMpIC0gKHQgKiogMikpICogbTEpXG4gIH1cbn1cblxuIiwiLyoqXG4gKiBSZXByZXNlbnRzIGEgc3BlY2lmaWMgaW50ZXJwb2xhdGlvbiBtZXRob2QuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBnbFRGSW50ZXJwb2xhdGlvbiB7XG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZXMgd2l0aGluIGFuIGFuaW1hdGlvbiBmcmFtZSBhbmQgcmV0dXJucyB0aGUgb3V0cHV0LlxuICAgKiBAcGFyYW0gZnJhbWUgVGhlIGFuaW1hdGlvbiBmcmFtZSB0byBpbnRlcnBvbGF0ZS5cbiAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGFuaW1hdGlvbiBmcmFtZSAoYmV0d2VlbiAwLTEpLlxuICAgKi9cbiAgYWJzdHJhY3QgaW50ZXJwb2xhdGUoZnJhbWU6IG51bWJlciwgcG9zaXRpb246IG51bWJlcik6IEZsb2F0MzJBcnJheVxuXG4gIHN0YXRpYyBmcm9tKHR5cGU6IHN0cmluZywgaW5wdXQ6IEFycmF5TGlrZTxudW1iZXI+LCBvdXRwdXQ6IEFycmF5TGlrZTxudW1iZXI+LCBzdHJpZGU6IG51bWJlcikge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkxJTkVBUlwiOiB7XG4gICAgICAgIHJldHVybiBuZXcgZ2xURkxpbmVhcihvdXRwdXQsIHN0cmlkZSlcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJDVUJJQ1NQTElORVwiOiB7XG4gICAgICAgIHJldHVybiBuZXcgZ2xURkN1YmljU3BsaW5lKGlucHV0LCBvdXRwdXQsIHN0cmlkZSlcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJTVEVQXCI6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBnbFRGU3RlcChvdXRwdXQsIHN0cmlkZSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBQSVhJM0Q6IFVua25vd24gaW50ZXJwb2xhdGlvbiB0eXBlIFwiJHt0eXBlfVwiYClcbiAgfVxufVxuXG4vLyBGaXhlcyBjaXJjdWxhciBkZXBlbmRlbmN5IGluIHdlYnBhY2tcbmltcG9ydCB7IGdsVEZMaW5lYXIgfSBmcm9tIFwiLi9nbHRmLWxpbmVhclwiXG5pbXBvcnQgeyBnbFRGQ3ViaWNTcGxpbmUgfSBmcm9tIFwiLi9nbHRmLWN1YmljLXNwbGluZVwiXG5pbXBvcnQgeyBnbFRGU3RlcCB9IGZyb20gXCIuL2dsdGYtc3RlcFwiIiwiaW1wb3J0IHsgZ2xURkludGVycG9sYXRpb24gfSBmcm9tIFwiLi9nbHRmLWludGVycG9sYXRpb25cIlxuXG5leHBvcnQgY2xhc3MgZ2xURkxpbmVhciBleHRlbmRzIGdsVEZJbnRlcnBvbGF0aW9uIHtcbiAgcHJpdmF0ZSBfZGF0YTogRmxvYXQzMkFycmF5XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfb3V0cHV0OiBBcnJheUxpa2U8bnVtYmVyPiwgcHJpdmF0ZSBfc3RyaWRlOiBudW1iZXIpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoX3N0cmlkZSlcbiAgfVxuXG4gIGludGVycG9sYXRlKGZyYW1lOiBudW1iZXIsIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICBsZXQgcG9zMSA9IChmcmFtZSArIDApICogdGhpcy5fc3RyaWRlXG4gICAgbGV0IHBvczIgPSAoZnJhbWUgKyAxKSAqIHRoaXMuX3N0cmlkZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc3RyaWRlOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9vdXRwdXQubGVuZ3RoID4gcG9zMikge1xuICAgICAgICB0aGlzLl9kYXRhW2ldID0gKDEgLSBwb3NpdGlvbikgKiB0aGlzLl9vdXRwdXRbcG9zMSArIGldICsgcG9zaXRpb24gKiB0aGlzLl9vdXRwdXRbcG9zMiArIGldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kYXRhW2ldID0gdGhpcy5fb3V0cHV0W3BvczEgKyBpXVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9XG59IiwiaW1wb3J0IHsgZ2xURkNoYW5uZWwgfSBmcm9tIFwiLi9nbHRmLWNoYW5uZWxcIlxuaW1wb3J0IHsgZ2xURkludGVycG9sYXRpb24gfSBmcm9tIFwiLi9nbHRmLWludGVycG9sYXRpb25cIlxuaW1wb3J0IHsgVHJhbnNmb3JtM0QgfSBmcm9tIFwiLi4vLi4vdHJhbnNmb3JtL3RyYW5zZm9ybVwiXG5cbmV4cG9ydCBjbGFzcyBnbFRGUm90YXRpb24gZXh0ZW5kcyBnbFRGQ2hhbm5lbCB7XG4gIHByaXZhdGUgX3RyYW5zZm9ybTogVHJhbnNmb3JtM0RcblxuICBjb25zdHJ1Y3Rvcih0cmFuc2Zvcm06IFRyYW5zZm9ybTNELCBpbnB1dDogQXJyYXlMaWtlPG51bWJlcj4sIGludGVycG9sYXRpb246IGdsVEZJbnRlcnBvbGF0aW9uKSB7XG4gICAgc3VwZXIoaW5wdXQsIGludGVycG9sYXRpb24pXG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG4gIH1cblxuICB1cGRhdGVUYXJnZXQoZGF0YTogQXJyYXlMaWtlPG51bWJlcj4pIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0ucm90YXRpb25RdWF0ZXJuaW9uLnNldChkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKVxuICB9XG59IiwiaW1wb3J0IHsgZ2xURkNoYW5uZWwgfSBmcm9tIFwiLi9nbHRmLWNoYW5uZWxcIlxuaW1wb3J0IHsgZ2xURkludGVycG9sYXRpb24gfSBmcm9tIFwiLi9nbHRmLWludGVycG9sYXRpb25cIlxuaW1wb3J0IHsgVHJhbnNmb3JtM0QgfSBmcm9tIFwiLi4vLi4vdHJhbnNmb3JtL3RyYW5zZm9ybVwiXG5cbmV4cG9ydCBjbGFzcyBnbFRGU2NhbGUgZXh0ZW5kcyBnbFRGQ2hhbm5lbCB7XG4gIHByaXZhdGUgX3RyYW5zZm9ybTogVHJhbnNmb3JtM0RcblxuICBjb25zdHJ1Y3Rvcih0cmFuc2Zvcm06IFRyYW5zZm9ybTNELCBpbnB1dDogQXJyYXlMaWtlPG51bWJlcj4sIGludGVycG9sYXRpb246IGdsVEZJbnRlcnBvbGF0aW9uKSB7XG4gICAgc3VwZXIoaW5wdXQsIGludGVycG9sYXRpb24pXG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG4gIH1cblxuICB1cGRhdGVUYXJnZXQoZGF0YTogQXJyYXlMaWtlPG51bWJlcj4pIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0uc2NhbGUuc2V0KGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pXG4gIH1cbn0iLCJpbXBvcnQgeyBRdWF0IH0gZnJvbSBcIi4uLy4uL21hdGgvcXVhdFwiXG5pbXBvcnQgeyBnbFRGSW50ZXJwb2xhdGlvbiB9IGZyb20gXCIuL2dsdGYtaW50ZXJwb2xhdGlvblwiXG5cbmV4cG9ydCBjbGFzcyBnbFRGU3BoZXJpY2FsTGluZWFyIGV4dGVuZHMgZ2xURkludGVycG9sYXRpb24ge1xuICBwcml2YXRlIF9kYXRhOiBGbG9hdDMyQXJyYXlcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdXRwdXQ6IEFycmF5TGlrZTxudW1iZXI+KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG4gIH1cblxuICBpbnRlcnBvbGF0ZShmcmFtZTogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgbGV0IHBvczEgPSAoZnJhbWUgKyAwKSAqIDRcbiAgICBsZXQgcG9zMiA9IChmcmFtZSArIDEpICogNFxuICAgIGxldCBhID0gUXVhdC5zZXQoXG4gICAgICB0aGlzLl9vdXRwdXRbcG9zMV0sIHRoaXMuX291dHB1dFtwb3MxICsgMV0sIHRoaXMuX291dHB1dFtwb3MxICsgMl0sIHRoaXMuX291dHB1dFtwb3MxICsgM10sIG5ldyBGbG9hdDMyQXJyYXkoNClcbiAgICApXG4gICAgaWYgKHRoaXMuX291dHB1dC5sZW5ndGggPD0gcG9zMikge1xuICAgICAgcmV0dXJuIFF1YXQubm9ybWFsaXplKGEsIHRoaXMuX2RhdGEpXG4gICAgfVxuICAgIGxldCBiID0gUXVhdC5zZXQoXG4gICAgICB0aGlzLl9vdXRwdXRbcG9zMl0sIHRoaXMuX291dHB1dFtwb3MyICsgMV0sIHRoaXMuX291dHB1dFtwb3MyICsgMl0sIHRoaXMuX291dHB1dFtwb3MyICsgM10sIG5ldyBGbG9hdDMyQXJyYXkoNClcbiAgICApXG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+UXVhdC5ub3JtYWxpemUoXG4gICAgICBRdWF0LnNsZXJwKGEsIGIsIHBvc2l0aW9uLCB0aGlzLl9kYXRhKSwgdGhpcy5fZGF0YSlcbiAgfVxufSIsImltcG9ydCB7IGdsVEZJbnRlcnBvbGF0aW9uIH0gZnJvbSBcIi4vZ2x0Zi1pbnRlcnBvbGF0aW9uXCJcblxuZXhwb3J0IGNsYXNzIGdsVEZTdGVwIGV4dGVuZHMgZ2xURkludGVycG9sYXRpb24ge1xuICBwcml2YXRlIF9kYXRhOiBGbG9hdDMyQXJyYXlcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdXRwdXQ6IEFycmF5TGlrZTxudW1iZXI+LCBwcml2YXRlIF9zdHJpZGU6IG51bWJlcikge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9kYXRhID0gbmV3IEZsb2F0MzJBcnJheShfc3RyaWRlKVxuICB9XG5cbiAgaW50ZXJwb2xhdGUoZnJhbWU6IG51bWJlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc3RyaWRlOyBpKyspIHtcbiAgICAgIHRoaXMuX2RhdGFbaV0gPSB0aGlzLl9vdXRwdXRbZnJhbWUgKiB0aGlzLl9zdHJpZGUgKyBpXVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9XG59IiwiaW1wb3J0IHsgZ2xURkNoYW5uZWwgfSBmcm9tIFwiLi9nbHRmLWNoYW5uZWxcIlxuaW1wb3J0IHsgZ2xURkludGVycG9sYXRpb24gfSBmcm9tIFwiLi9nbHRmLWludGVycG9sYXRpb25cIlxuaW1wb3J0IHsgVHJhbnNmb3JtM0QgfSBmcm9tIFwiLi4vLi4vdHJhbnNmb3JtL3RyYW5zZm9ybVwiXG5cbmV4cG9ydCBjbGFzcyBnbFRGVHJhbnNsYXRpb24gZXh0ZW5kcyBnbFRGQ2hhbm5lbCB7XG4gIHByaXZhdGUgX3RyYW5zZm9ybTogVHJhbnNmb3JtM0RcblxuICBjb25zdHJ1Y3Rvcih0cmFuc2Zvcm06IFRyYW5zZm9ybTNELCBpbnB1dDogQXJyYXlMaWtlPG51bWJlcj4sIGludGVycG9sYXRpb246IGdsVEZJbnRlcnBvbGF0aW9uKSB7XG4gICAgc3VwZXIoaW5wdXQsIGludGVycG9sYXRpb24pXG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG4gIH1cblxuICB1cGRhdGVUYXJnZXQoZGF0YTogQXJyYXlMaWtlPG51bWJlcj4pIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0ucG9zaXRpb24uc2V0KGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pXG4gIH1cbn0iLCJpbXBvcnQgeyBnbFRGQ2hhbm5lbCB9IGZyb20gXCIuL2dsdGYtY2hhbm5lbFwiXG5pbXBvcnQgeyBnbFRGSW50ZXJwb2xhdGlvbiB9IGZyb20gXCIuL2dsdGYtaW50ZXJwb2xhdGlvblwiXG5cbmV4cG9ydCBjbGFzcyBnbFRGV2VpZ2h0cyBleHRlbmRzIGdsVEZDaGFubmVsIHtcbiAgcHJpdmF0ZSBfd2VpZ2h0czogbnVtYmVyW11cblxuICBjb25zdHJ1Y3Rvcih3ZWlnaHRzOiBudW1iZXJbXSwgaW5wdXQ6IEFycmF5TGlrZTxudW1iZXI+LCBpbnRlcnBvbGF0aW9uOiBnbFRGSW50ZXJwb2xhdGlvbikge1xuICAgIHN1cGVyKGlucHV0LCBpbnRlcnBvbGF0aW9uKVxuICAgIHRoaXMuX3dlaWdodHMgPSB3ZWlnaHRzXG4gIH1cblxuICB1cGRhdGVUYXJnZXQoZGF0YTogQXJyYXlMaWtlPG51bWJlcj4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3dlaWdodHNbaV0gPSBkYXRhW2ldXG4gICAgfVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbi8qKlxuICogZ2xURiBhc3NldHMgYXJlIEpTT04gZmlsZXMgcGx1cyBzdXBwb3J0aW5nIGV4dGVybmFsIGRhdGEuXG4gKi9cbmV4cG9ydCBjbGFzcyBnbFRGQXNzZXQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBnbFRGIGFzc2V0IHVzaW5nIHRoZSBzcGVjaWZpZWQgSlNPTiBkZXNjcmlwdG9yLlxuICAgKiBAcGFyYW0gZGVzY3JpcHRvciBUaGUgSlNPTiBkZXNjcmlwdG9yIHRvIGNyZWF0ZSB0aGUgYXNzZXQgZnJvbS5cbiAgICogQHBhcmFtIGJ1ZmZlcnMgVGhlIGJ1ZmZlcnMgdXNlZCBieSB0aGlzIGFzc2V0LlxuICAgKiBAcGFyYW0gaW1hZ2VzIFRoZSBpbWFnZXMgdXNlZCBieSB0aGlzIGFzc2V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgZGVzY3JpcHRvcjogYW55LCByZWFkb25seSBidWZmZXJzOiBBcnJheUJ1ZmZlcltdID0gW10sIHJlYWRvbmx5IGltYWdlczogUElYSS5UZXh0dXJlW10gPSBbXSkgeyB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgbmV3IGdsVEYgYXNzZXQgKGluY2x1ZGluZyByZXNvdXJjZXMpIHVzaW5nIHRoZSBzcGVjaWZpZWQgSlNPTiBcbiAgICogZGVzY3JpcHRvci5cbiAgICogQHBhcmFtIGRlc2NyaXB0b3IgVGhlIEpTT04gZGVzY3JpcHRvciB0byBjcmVhdGUgdGhlIGFzc2V0IGZyb20uXG4gICAqIEBwYXJhbSBsb2FkZXIgVGhlIHJlc291cmNlIGxvYWRlciB0byB1c2UgZm9yIGV4dGVybmFsIHJlc291cmNlcy4gVGhlIFxuICAgKiBsb2FkZXIgY2FuIGJlIGVtcHR5IHdoZW4gYWxsIHJlc291cmNlcyBpbiB0aGUgZGVzY3JpcHRvciBpcyBlbWJlZGRlZC5cbiAgICovXG4gIHN0YXRpYyBsb2FkKGRlc2NyaXB0b3I6IGFueSwgbG9hZGVyPzogZ2xURkFzc2V0UmVzb3VyY2VMb2FkZXIpIHtcbiAgICBsZXQgYXNzZXQgPSBuZXcgZ2xURkFzc2V0KGRlc2NyaXB0b3IpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2NyaXB0b3IuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGJ1ZmZlcjogeyB1cmk6IHN0cmluZyB9ID0gZGVzY3JpcHRvci5idWZmZXJzW2ldXG4gICAgICBpZiAoZ2xURkFzc2V0LmlzRW1iZWRkZWRSZXNvdXJjZShidWZmZXIudXJpKSkge1xuICAgICAgICBhc3NldC5idWZmZXJzW2ldID0gZ2xURkFzc2V0LmdldEVtYmVkZGVkQnVmZmVyKGJ1ZmZlci51cmkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWxvYWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBJWEkzRDogQSByZXNvdXJjZSBsb2FkZXIgaXMgcmVxdWlyZWQgd2hlbiBidWZmZXIgaXMgbm90IGVtYmVkZGVkLlwiKVxuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5sb2FkKGJ1ZmZlci51cmksIChyZXNvdXJjZSkgPT4ge1xuICAgICAgICAgIGFzc2V0LmJ1ZmZlcnNbaV0gPSByZXNvdXJjZS5kYXRhXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZGVzY3JpcHRvci5pbWFnZXMpIHtcbiAgICAgIHJldHVybiBhc3NldFxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2NyaXB0b3IuaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaW1hZ2U6IHsgdXJpOiBzdHJpbmcgfSA9IGRlc2NyaXB0b3IuaW1hZ2VzW2ldXG4gICAgICBpZiAoZ2xURkFzc2V0LmlzRW1iZWRkZWRSZXNvdXJjZShpbWFnZS51cmkpKSB7XG4gICAgICAgIGFzc2V0LmltYWdlc1tpXSA9IFBJWEkuVGV4dHVyZS5mcm9tKGltYWdlLnVyaSwge1xuICAgICAgICAgIHdyYXBNb2RlOiBQSVhJLldSQVBfTU9ERVMuUkVQRUFUXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWxvYWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBJWEkzRDogQSByZXNvdXJjZSBsb2FkZXIgaXMgcmVxdWlyZWQgd2hlbiBpbWFnZSBpcyBub3QgZW1iZWRkZWQuXCIpXG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmxvYWQoaW1hZ2UudXJpLCAocmVzb3VyY2UpID0+IHtcbiAgICAgICAgICBpZiAocmVzb3VyY2UudGV4dHVyZSkge1xuICAgICAgICAgICAgcmVzb3VyY2UudGV4dHVyZS5iYXNlVGV4dHVyZS53cmFwTW9kZSA9IFBJWEkuV1JBUF9NT0RFUy5SRVBFQVRcbiAgICAgICAgICAgIGFzc2V0LmltYWdlc1tpXSA9IHJlc291cmNlLnRleHR1cmVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhc3NldFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBzcGVjaWZpZWQgZGF0YSBidWZmZXIgaXMgYSB2YWxpZCBnbFRGLlxuICAgKiBAcGFyYW0gZGF0YSBUaGUgYnVmZmVyIGRhdGEgdG8gdmFsaWRhdGUuXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZChkYXRhOiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50MzJBcnJheShkYXRhLCAwLCAzKVxuICAgIGlmIChoZWFkZXJbMF0gPT09IDB4NDY1NDZDNjcgJiYgaGVhZGVyWzFdID09PSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGdsVEYgYXNzZXQgZnJvbSBiaW5hcnkgKGdsYikgYnVmZmVyIGRhdGEuXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBiaW5hcnkgYnVmZmVyIGRhdGEgdG8gcmVhZCBmcm9tLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHdoaWNoIGdldHMgY2FsbGVkIHdoZW4gdGhlIGFzc2V0IGhhcyBiZWVuIFxuICAgKiBjcmVhdGVkLlxuICAgKi9cbiAgc3RhdGljIGZyb21CdWZmZXIoZGF0YTogQXJyYXlCdWZmZXIsIGNhbGxiYWNrOiAoZ2x0ZjogZ2xURkFzc2V0KSA9PiB2b2lkKSB7XG4gICAgY29uc3QgY2h1bmtzOiB7IHR5cGU6IG51bWJlciwgb2Zmc2V0OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyIH1bXSA9IFtdXG4gICAgbGV0IG9mZnNldCA9IDMgKiA0XG4gICAgd2hpbGUgKG9mZnNldCA8IGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEsIG9mZnNldCwgMylcbiAgICAgIGNodW5rcy5wdXNoKHtcbiAgICAgICAgbGVuZ3RoOiBoZWFkZXJbMF0sIHR5cGU6IGhlYWRlclsxXSwgb2Zmc2V0OiBvZmZzZXQgKyAyICogNFxuICAgICAgfSlcbiAgICAgIG9mZnNldCArPSBoZWFkZXJbMF0gKyAyICogNFxuICAgIH1cbiAgICBjb25zdCBqc29uID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgY2h1bmtzWzBdLm9mZnNldCwgY2h1bmtzWzBdLmxlbmd0aClcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gSlNPTi5wYXJzZShuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKS5kZWNvZGUoanNvbikpXG4gICAgY29uc3QgYnVmZmVyczogQXJyYXlCdWZmZXJbXSA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhLnNsaWNlKGNodW5rc1tpXS5vZmZzZXQsIGNodW5rc1tpXS5vZmZzZXQgKyBjaHVua3NbaV0ubGVuZ3RoKSlcbiAgICB9XG4gICAgaWYgKCFkZXNjcmlwdG9yLmltYWdlcyB8fCBkZXNjcmlwdG9yLmltYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBnbFRGQXNzZXQoZGVzY3JpcHRvciwgYnVmZmVycykpXG4gICAgfVxuICAgIGNvbnN0IGltYWdlczogUElYSS5UZXh0dXJlW10gPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBkZXNjcmlwdG9yLmltYWdlcyAmJiBpIDwgZGVzY3JpcHRvci5pbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGltYWdlID0gZGVzY3JpcHRvci5pbWFnZXNbaV1cbiAgICAgIGlmIChpbWFnZS5idWZmZXJWaWV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZpZXcgPSBkZXNjcmlwdG9yLmJ1ZmZlclZpZXdzW2ltYWdlLmJ1ZmZlclZpZXddXG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW3ZpZXcuYnVmZmVyXVxuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIHZpZXcuYnl0ZU9mZnNldCwgdmlldy5ieXRlTGVuZ3RoKVxuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFthcnJheV0sIHsgXCJ0eXBlXCI6IGltYWdlLm1pbWVUeXBlIH0pXG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBpbWFnZXNbaV0gPSBQSVhJLlRleHR1cmUuZnJvbSg8c3RyaW5nPnJlYWRlci5yZXN1bHQpXG4gICAgICAgIGltYWdlc1tpXS5iYXNlVGV4dHVyZS53cmFwTW9kZSA9IFBJWEkuV1JBUF9NT0RFUy5SRVBFQVRcbiAgICAgICAgaWYgKGltYWdlcy5sZW5ndGggPT09IGRlc2NyaXB0b3IuaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBnbFRGQXNzZXQoZGVzY3JpcHRvciwgYnVmZmVycywgaW1hZ2VzKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYilcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgaXNFbWJlZGRlZFJlc291cmNlKHVyaTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHVyaS5zdGFydHNXaXRoKFwiZGF0YTpcIilcbiAgfVxuXG4gIHN0YXRpYyBnZXRFbWJlZGRlZEJ1ZmZlcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhdG9iKHZhbHVlLnNwbGl0KFwiLFwiKVsxXSksIGMgPT4gYy5jaGFyQ29kZUF0KDApKS5idWZmZXJcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsb2FkZXIgZm9yIGdsVEYgYXNzZXQgcmVzb3VyY2VzIChidWZmZXJzIGFuZCBpbWFnZXMpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIGdsVEZBc3NldFJlc291cmNlTG9hZGVyIHtcbiAgLyoqXG4gICAqIExvYWRzIHRoZSByZXNvdXJjZSBmcm9tIHRoZSBzcGVjaWZpZWQgdXJpLlxuICAgKiBAcGFyYW0gdXJpIFRoZSB1cmkgdG8gbG9hZCBmcm9tLlxuICAgKiBAcGFyYW0gb25Db21wbGV0ZSBDYWxsYmFjayB3aGVuIGxvYWRpbmcgaXMgY29tcGxldGVkLlxuICAgKi9cbiAgbG9hZCh1cmk6IHN0cmluZyxcbiAgICBvbkNvbXBsZXRlOiAocmVzb3VyY2U6IFBJWEkuSUxvYWRlclJlc291cmNlKSA9PiB2b2lkKTogdm9pZFxufSIsIi8qKlxuICogUmVwcmVzZW50cyBhIHN1YnNldCBvZiBkYXRhIGluIGEgYnVmZmVyLlxuICovXG5leHBvcnQgY2xhc3MgZ2xURkJ1ZmZlclZpZXcge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgYnVmZmVyOiBVaW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEludDhBcnJheSB8IFVpbnQ4QXJyYXkgfCBJbnQxNkFycmF5IHwgVWludDE2QXJyYXksIHB1YmxpYyBjb21wb25lbnRUeXBlOiBudW1iZXIsIHB1YmxpYyBzdHJpZGUgPSAwKSB7XG4gIH1cblxuICBzdGF0aWMgZnJvbShjb21wb25lbnRUeXBlOiBudW1iZXIsIGJ1ZmZlcjogQXJyYXlCdWZmZXIsIG9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIsIHN0cmlkZT86IG51bWJlcikge1xuICAgIHN3aXRjaCAoY29tcG9uZW50VHlwZSkge1xuICAgICAgY2FzZSA1MTI1OiByZXR1cm4gbmV3IGdsVEZCdWZmZXJWaWV3KFxuICAgICAgICBuZXcgVWludDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIHNpemUpLCBjb21wb25lbnRUeXBlLCBzdHJpZGUpXG4gICAgICBjYXNlIDUxMjY6IHJldHVybiBuZXcgZ2xURkJ1ZmZlclZpZXcoXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIHNpemUpLCBjb21wb25lbnRUeXBlLCBzdHJpZGUpXG4gICAgICBjYXNlIDUxMjA6IHJldHVybiBuZXcgZ2xURkJ1ZmZlclZpZXcoXG4gICAgICAgIG5ldyBJbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIHNpemUpLCBjb21wb25lbnRUeXBlLCBzdHJpZGUpXG4gICAgICBjYXNlIDUxMjE6IHJldHVybiBuZXcgZ2xURkJ1ZmZlclZpZXcoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSwgY29tcG9uZW50VHlwZSwgc3RyaWRlKVxuICAgICAgY2FzZSA1MTIyOiByZXR1cm4gbmV3IGdsVEZCdWZmZXJWaWV3KFxuICAgICAgICBuZXcgSW50MTZBcnJheShidWZmZXIsIG9mZnNldCwgc2l6ZSksIGNvbXBvbmVudFR5cGUsIHN0cmlkZSlcbiAgICAgIGNhc2UgNTEyMzogcmV0dXJuIG5ldyBnbFRGQnVmZmVyVmlldyhcbiAgICAgICAgbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSwgY29tcG9uZW50VHlwZSwgc3RyaWRlKVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBJWEkzRDogVW5rbm93biBjb21wb25lbnQgdHlwZSBcIiR7Y29tcG9uZW50VHlwZX1cIi5gKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG4vKipcbiAqIGdsVEYgZGVmaW5lcyBtYXRlcmlhbHMgdXNpbmcgYSBjb21tb24gc2V0IG9mIHBhcmFtZXRlcnMgdGhhdCBhcmUgYmFzZWQgb24gXG4gKiB3aWRlbHkgdXNlZCBtYXRlcmlhbCByZXByZXNlbnRhdGlvbnMgZnJvbSBQaHlzaWNhbGx5LUJhc2VkIFJlbmRlcmluZyAoUEJSKS5cbiAqL1xuZXhwb3J0IGNsYXNzIGdsVEZNYXRlcmlhbCB7XG4gIGFscGhhQ3V0b2ZmID0gMC41XG4gIGFscGhhTW9kZSA9IFwiT1BBUVVFXCJcbiAgZG91YmxlU2lkZWQgPSBmYWxzZVxuICByb3VnaG5lc3MgPSAxXG4gIG1ldGFsbGljID0gMVxuICBiYXNlQ29sb3JUZXh0dXJlPzogUElYSS5UZXh0dXJlXG4gIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT86IFBJWEkuVGV4dHVyZVxuICBub3JtYWxUZXh0dXJlPzogUElYSS5UZXh0dXJlXG4gIG9jY2x1c2lvblRleHR1cmU/OiBQSVhJLlRleHR1cmVcbiAgZW1pc3NpdmVUZXh0dXJlPzogUElYSS5UZXh0dXJlXG4gIGVtaXNzaXZlID0gWzAsIDAsIDBdXG4gIGJhc2VDb2xvciA9IFsxLCAxLCAxLCAxXVxuICB1bmxpdCA9IGZhbHNlXG59IiwiaW1wb3J0IHsgZ2xURkNoYW5uZWwgfSBmcm9tIFwiLi9hbmltYXRpb24vZ2x0Zi1jaGFubmVsXCJcbmltcG9ydCB7IGdsVEZBc3NldCB9IGZyb20gXCIuL2dsdGYtYXNzZXRcIlxuaW1wb3J0IHsgZ2xURkFuaW1hdGlvbiB9IGZyb20gXCIuL2FuaW1hdGlvbi9nbHRmLWFuaW1hdGlvblwiXG5pbXBvcnQgeyBnbFRGQnVmZmVyVmlldyB9IGZyb20gXCIuL2dsdGYtYnVmZmVyLXZpZXdcIlxuaW1wb3J0IHsgZ2xURk1hdGVyaWFsIH0gZnJvbSBcIi4vZ2x0Zi1tYXRlcmlhbFwiXG5pbXBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCJcbmltcG9ydCB7IENvbnRhaW5lcjNEIH0gZnJvbSBcIi4uL2NvbnRhaW5lclwiXG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbC9tYXRlcmlhbFwiXG5pbXBvcnQgeyBNYXRlcmlhbEZhY3RvcnkgfSBmcm9tIFwiLi4vbWF0ZXJpYWwvbWF0ZXJpYWwtZmFjdG9yeVwiXG5pbXBvcnQgeyBTdGFuZGFyZE1hdGVyaWFsIH0gZnJvbSBcIi4uL21hdGVyaWFsL3N0YW5kYXJkL3N0YW5kYXJkLW1hdGVyaWFsXCJcbmltcG9ydCB7IE1lc2hHZW9tZXRyeTNEIH0gZnJvbSBcIi4uL21lc2gvZ2VvbWV0cnkvbWVzaC1nZW9tZXRyeVwiXG5pbXBvcnQgeyBNb2RlbCB9IGZyb20gXCIuLi9tb2RlbFwiXG5pbXBvcnQgeyBUcmFuc2Zvcm1NYXRyaXggfSBmcm9tIFwiLi4vdHJhbnNmb3JtL3RyYW5zZm9ybS1tYXRyaXhcIlxuaW1wb3J0IHsgU2tpbiB9IGZyb20gXCIuLi9za2lubmluZy9za2luXCJcbmltcG9ydCB7IEpvaW50IH0gZnJvbSBcIi4uL3NraW5uaW5nL2pvaW50XCJcbmltcG9ydCB7IFRleHR1cmVUcmFuc2Zvcm0gfSBmcm9tIFwiLi4vdGV4dHVyZS90ZXh0dXJlVHJhbnNmb3JtXCJcblxuLyoqXG4gKiBQYXJzZXMgZ2xURiBhc3NldHMgYW5kIGNyZWF0ZXMgbW9kZWxzIGFuZCBtZXNoZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBnbFRGUGFyc2VyIHtcbiAgcHJpdmF0ZSBfYXNzZXQ6IGdsVEZBc3NldFxuICBwcml2YXRlIF9tYXRlcmlhbEZhY3Rvcnk6IE1hdGVyaWFsRmFjdG9yeVxuICBwcml2YXRlIF9kZXNjcmlwdG9yOiBhbnlcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwYXJzZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBhc3NldC5cbiAgICogQHBhcmFtIGFzc2V0IFRoZSBhc3NldCB0byBwYXJzZS5cbiAgICogQHBhcmFtIG1hdGVyaWFsRmFjdG9yeSBUaGUgbWF0ZXJpYWwgZmFjdG9yeSB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihhc3NldDogZ2xURkFzc2V0LCBtYXRlcmlhbEZhY3Rvcnk/OiBNYXRlcmlhbEZhY3RvcnkpIHtcbiAgICB0aGlzLl9hc3NldCA9IGFzc2V0XG4gICAgdGhpcy5fbWF0ZXJpYWxGYWN0b3J5ID0gbWF0ZXJpYWxGYWN0b3J5IHx8IFN0YW5kYXJkTWF0ZXJpYWxcbiAgICB0aGlzLl9kZXNjcmlwdG9yID0gdGhpcy5fYXNzZXQuZGVzY3JpcHRvclxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtb2RlbCBmcm9tIHRoZSBzcGVjaWZpZWQgYXNzZXQuXG4gICAqIEBwYXJhbSBhc3NldCBUaGUgYXNzZXQgdG8gY3JlYXRlIHRoZSBtb2RlbCBmcm9tLlxuICAgKiBAcGFyYW0gbWF0ZXJpYWxGYWN0b3J5IFRoZSBtYXRlcmlhbCBmYWN0b3J5IHRvIHVzZS5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVNb2RlbChhc3NldDogZ2xURkFzc2V0LCBtYXRlcmlhbEZhY3Rvcnk/OiBNYXRlcmlhbEZhY3RvcnkpIHtcbiAgICByZXR1cm4gbmV3IGdsVEZQYXJzZXIoYXNzZXQsIG1hdGVyaWFsRmFjdG9yeSkucGFyc2VNb2RlbCgpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1lc2ggZnJvbSB0aGUgc3BlY2lmaWVkIGFzc2V0LlxuICAgKiBAcGFyYW0gYXNzZXQgVGhlIGFzc2V0IHRvIGNyZWF0ZSB0aGUgbWVzaCBmcm9tLlxuICAgKiBAcGFyYW0gbWF0ZXJpYWxGYWN0b3J5IFRoZSBtYXRlcmlhbCBmYWN0b3J5IHRvIHVzZS5cbiAgICogQHBhcmFtIG1lc2ggVGhlIG1lc2ggaW5kZXggaW4gdGhlIEpTT04gZGVzY3JpcHRvci5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVNZXNoKGFzc2V0OiBnbFRGQXNzZXQsIG1hdGVyaWFsRmFjdG9yeT86IE1hdGVyaWFsRmFjdG9yeSwgbWVzaCA9IDApIHtcbiAgICByZXR1cm4gbmV3IGdsVEZQYXJzZXIoYXNzZXQsIG1hdGVyaWFsRmFjdG9yeSkucGFyc2VNZXNoKG1lc2gpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgdmlldyBmcm9tIHRoZSBzcGVjaWZpZWQgYWNjZXNzb3IuXG4gICAqIEBwYXJhbSBhY2Nlc3NvciBUaGUgYWNjZXNzb3Igb2JqZWN0IG9yIGluZGV4LlxuICAgKi9cbiAgcGFyc2VCdWZmZXIoYWNjZXNzb3I6IGFueSkge1xuICAgIGlmIChhY2Nlc3NvciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQgfVxuICAgIGlmICh0eXBlb2YgYWNjZXNzb3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGFjY2Vzc29yID0gdGhpcy5fYXNzZXQuZGVzY3JpcHRvci5hY2Nlc3NvcnNbYWNjZXNzb3JdXG4gICAgfVxuICAgIGxldCBidWZmZXJWaWV3ID0gdGhpcy5fZGVzY3JpcHRvci5idWZmZXJWaWV3c1thY2Nlc3Nvci5idWZmZXJWaWV3IHx8IDBdXG4gICAgbGV0IG9mZnNldCA9IGFjY2Vzc29yLmJ5dGVPZmZzZXQgfHwgMFxuICAgIGlmIChidWZmZXJWaWV3LmJ5dGVPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2Zmc2V0ICs9IGJ1ZmZlclZpZXcuYnl0ZU9mZnNldFxuICAgIH1cbiAgICBsZXQgc2l6ZSA9IGFjY2Vzc29yLmNvdW50ICogY29tcG9uZW50Q291bnRbYWNjZXNzb3IudHlwZV1cbiAgICBpZiAoYnVmZmVyVmlldy5ieXRlU3RyaWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNpemUgKj0gYnVmZmVyVmlldy5ieXRlU3RyaWRlIC8gY29tcG9uZW50U2l6ZVthY2Nlc3Nvci5jb21wb25lbnRUeXBlXSAvIGNvbXBvbmVudENvdW50W2FjY2Vzc29yLnR5cGVdXG4gICAgfVxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9hc3NldC5idWZmZXJzW2J1ZmZlclZpZXcuYnVmZmVyXVxuXG4gICAgcmV0dXJuIGdsVEZCdWZmZXJWaWV3LmZyb20oXG4gICAgICBhY2Nlc3Nvci5jb21wb25lbnRUeXBlLCBidWZmZXIsIG9mZnNldCwgc2l6ZSwgYnVmZmVyVmlldy5ieXRlU3RyaWRlKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYW5pbWF0aW9uIGZyb20gdGhlIHNwZWNpZmllZCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIHNvdXJjZSBhbmltYXRpb24gb2JqZWN0IG9yIGluZGV4LlxuICAgKiBAcGFyYW0gbm9kZXMgVGhlIGFycmF5IG9mIG5vZGVzIHdoaWNoIGFyZSBwb3RlbnRpYWwgdGFyZ2V0cyBmb3IgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIHBhcnNlQW5pbWF0aW9uKGFuaW1hdGlvbjogYW55LCBub2RlczogQ29udGFpbmVyM0RbXSkge1xuICAgIGlmICh0eXBlb2YgYW5pbWF0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICBhbmltYXRpb24gPSB0aGlzLl9hc3NldC5kZXNjcmlwdG9yLmFuaW1hdGlvbnNbYW5pbWF0aW9uXVxuICAgIH1cbiAgICBsZXQgY2hhbm5lbHM6IGdsVEZDaGFubmVsW10gPSBbXVxuICAgIGZvciAobGV0IGNoYW5uZWwgb2YgYW5pbWF0aW9uLmNoYW5uZWxzKSB7XG4gICAgICBsZXQgc2FtcGxlciA9IGFuaW1hdGlvbi5zYW1wbGVyc1tjaGFubmVsLnNhbXBsZXJdXG4gICAgICBsZXQgaW5wdXQgPSB0aGlzLnBhcnNlQnVmZmVyKHNhbXBsZXIuaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGV0IG91dHB1dCA9IHRoaXMucGFyc2VCdWZmZXIoc2FtcGxlci5vdXRwdXQpXG4gICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxldCBhbmltYXRpb25DaGFubmVsID0gZ2xURkNoYW5uZWwuZnJvbShcbiAgICAgICAgaW5wdXQuYnVmZmVyLCBvdXRwdXQuYnVmZmVyLCBzYW1wbGVyLmludGVycG9sYXRpb24gfHwgXCJMSU5FQVJcIiwgY2hhbm5lbC50YXJnZXQucGF0aCwgbm9kZXNbY2hhbm5lbC50YXJnZXQubm9kZV0pXG4gICAgICBpZiAoYW5pbWF0aW9uQ2hhbm5lbCkge1xuICAgICAgICBjaGFubmVscy5wdXNoKGFuaW1hdGlvbkNoYW5uZWwpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgZ2xURkFuaW1hdGlvbihjaGFubmVscywgYW5pbWF0aW9uLm5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hdGVyaWFsIGZyb20gdGhlIHNwZWNpZmllZCBzb3VyY2UuXG4gICAqIEBwYXJhbSBtYXRlcmlhbCBUaGUgc291cmNlIG1hdGVyaWFsIG9iamVjdCBvciBpbmRleC5cbiAgICovXG4gIHBhcnNlTWF0ZXJpYWwobWF0ZXJpYWw/OiBhbnkpIHtcbiAgICBpZiAodHlwZW9mIG1hdGVyaWFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICBtYXRlcmlhbCA9IHRoaXMuX2Fzc2V0LmRlc2NyaXB0b3IubWF0ZXJpYWxzW21hdGVyaWFsXVxuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gbmV3IGdsVEZNYXRlcmlhbCgpXG4gICAgaWYgKCFtYXRlcmlhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsRmFjdG9yeS5jcmVhdGUocmVzdWx0KVxuICAgIH1cbiAgICByZXN1bHQub2NjbHVzaW9uVGV4dHVyZSA9IHRoaXMucGFyc2VUZXh0dXJlKG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUpXG4gICAgcmVzdWx0Lm5vcm1hbFRleHR1cmUgPSB0aGlzLnBhcnNlVGV4dHVyZShtYXRlcmlhbC5ub3JtYWxUZXh0dXJlKVxuICAgIHJlc3VsdC5lbWlzc2l2ZVRleHR1cmUgPSB0aGlzLnBhcnNlVGV4dHVyZShtYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUpXG5cbiAgICBpZiAobWF0ZXJpYWwuZG91YmxlU2lkZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0LmRvdWJsZVNpZGVkID0gbWF0ZXJpYWwuZG91YmxlU2lkZWRcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsLmVtaXNzaXZlKSB7XG4gICAgICByZXN1bHQuZW1pc3NpdmUgPSBtYXRlcmlhbC5lbWlzc2l2ZVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWwuYWxwaGFNb2RlKSB7XG4gICAgICByZXN1bHQuYWxwaGFNb2RlID0gbWF0ZXJpYWwuYWxwaGFNb2RlXG4gICAgfVxuICAgIGlmIChtYXRlcmlhbC5hbHBoYUN1dG9mZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHQuYWxwaGFDdXRvZmYgPSBtYXRlcmlhbC5hbHBoYUN1dG9mZlxuICAgIH1cbiAgICBsZXQgcGJyID0gbWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3NcbiAgICByZXN1bHQubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlID0gdGhpcy5wYXJzZVRleHR1cmUocGJyPy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpXG4gICAgaWYgKHBicj8uYmFzZUNvbG9yRmFjdG9yKSB7XG4gICAgICByZXN1bHQuYmFzZUNvbG9yID0gcGJyLmJhc2VDb2xvckZhY3RvclxuICAgIH1cbiAgICByZXN1bHQuYmFzZUNvbG9yVGV4dHVyZSA9IHRoaXMucGFyc2VUZXh0dXJlKHBicj8uYmFzZUNvbG9yVGV4dHVyZSlcbiAgICBpZiAocGJyPy5tZXRhbGxpY0ZhY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHQubWV0YWxsaWMgPSBwYnIubWV0YWxsaWNGYWN0b3JcbiAgICB9XG4gICAgaWYgKHBicj8ucm91Z2huZXNzRmFjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdC5yb3VnaG5lc3MgPSBwYnIucm91Z2huZXNzRmFjdG9yXG4gICAgfVxuICAgIGlmIChtYXRlcmlhbC5leHRlbnNpb25zKSB7XG4gICAgICByZXN1bHQudW5saXQgPSBtYXRlcmlhbC5leHRlbnNpb25zW1wiS0hSX21hdGVyaWFsc191bmxpdFwiXSAhPSB1bmRlZmluZWRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsRmFjdG9yeS5jcmVhdGUocmVzdWx0KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRleHR1cmUgdXNlZCBieSB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAgICogQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvciBpbmRleC5cbiAgICovXG4gIHBhcnNlVGV4dHVyZShzb3VyY2U6IGFueSkge1xuICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgc291cmNlID0geyBpbmRleDogc291cmNlIH1cbiAgICB9XG4gICAgbGV0IHRleHR1cmUgPSB0aGlzLl9hc3NldC5pbWFnZXNbdGhpcy5fZGVzY3JpcHRvci50ZXh0dXJlc1tzb3VyY2UuaW5kZXhdLnNvdXJjZV07XG5cdCAgaWYgKHNvdXJjZS5leHRlbnNpb25zICYmIHNvdXJjZS5leHRlbnNpb25zLktIUl90ZXh0dXJlX3RyYW5zZm9ybSkge1xuXHQgICAgVGV4dHVyZVRyYW5zZm9ybS5jYWxjdWxhdGVVVlRyYW5zZm9ybShzb3VyY2UuZXh0ZW5zaW9ucy5LSFJfdGV4dHVyZV90cmFuc2Zvcm0sIHRleHR1cmUpO1xuICAgIH0gICAgXG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBtZXNoZXMgZnJvbSB0aGUgc3BlY2lmaWVkIG1lc2guXG4gICAqIEBwYXJhbSBtZXNoIFRoZSBzb3VyY2UgbWVzaCBvYmplY3Qgb3IgaW5kZXguXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdoaWNoIGNvbnRhaW4gYXJyYXlzIG9mIG1lc2hlcy4gVGhpcyBpcyBiZWNhdXNlIG9mIHRoZSBcbiAgICogc3RydWN0dXJlIHVzZWQgaW4gZ2xURiwgd2hlcmUgZWFjaCBtZXNoIGNvbnRhaW4gYSBudW1iZXIgb2YgcHJpbWl0aXZlcy4gXG4gICAqIFJlYWQgbW9yZSBhYm91dCB0aGlzIGluIGRpc2N1c3Npb24gYXQgaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2lzc3Vlcy84MjFcbiAgICovXG4gIHBhcnNlTWVzaChtZXNoOiBhbnkpIHtcbiAgICBpZiAodHlwZW9mIG1lc2ggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG1lc2ggPSB0aGlzLl9hc3NldC5kZXNjcmlwdG9yLm1lc2hlc1ttZXNoXVxuICAgIH1cbiAgICBsZXQgd2VpZ2h0cyA9IG1lc2gud2VpZ2h0cyB8fCBbXVxuICAgIHJldHVybiA8TWVzaDNEW10+bWVzaC5wcmltaXRpdmVzLm1hcCgocHJpbWl0aXZlOiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduPE1lc2gzRCwgUGFydGlhbDxNZXNoM0Q+Pih0aGlzLnBhcnNlUHJpbWl0aXZlKHByaW1pdGl2ZSksIHtcbiAgICAgICAgbmFtZTogbWVzaC5uYW1lLFxuICAgICAgICBtb3JwaFdlaWdodHM6IHdlaWdodHNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2tpbiBmcm9tIHRoZSBzcGVjaWZpZWQgc291cmNlLlxuICAgKiBAcGFyYW0gc2tpbiBUaGUgc291cmNlIHNraW4gb2JqZWN0IG9yIGluZGV4LlxuICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgY29udGFpbmVyIGZvciB0aGUgc2tpbi5cbiAgICogQHBhcmFtIG5vZGVzIFRoZSBhcnJheSBvZiBub2RlcyB3aGljaCBhcmUgcG90ZW50aWFsIHRhcmdldHMgZm9yIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICBwYXJzZVNraW4oc2tpbjogYW55LCB0YXJnZXQ6IENvbnRhaW5lcjNELCBub2RlczogQ29udGFpbmVyM0RbXSkge1xuICAgIGlmICh0eXBlb2Ygc2tpbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgc2tpbiA9IHRoaXMuX2Fzc2V0LmRlc2NyaXB0b3Iuc2tpbnNbc2tpbl1cbiAgICB9XG4gICAgbGV0IGludmVyc2VCaW5kTWF0cmljZXMgPSB0aGlzLnBhcnNlQnVmZmVyKHNraW4uaW52ZXJzZUJpbmRNYXRyaWNlcylcbiAgICBsZXQgam9pbnRzOiBKb2ludFtdID0gW11cbiAgICBpZiAoaW52ZXJzZUJpbmRNYXRyaWNlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBza2luLmpvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBqb2ludHMucHVzaChuZXcgSm9pbnQobm9kZXNbc2tpbi5qb2ludHNbaV1dLFxuICAgICAgICAgIDxGbG9hdDMyQXJyYXk+aW52ZXJzZUJpbmRNYXRyaWNlcy5idWZmZXIuc2xpY2UoaSAqIDE2LCBpICogMTYgKyAxNikpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFNraW4odGFyZ2V0LCBqb2ludHMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1lc2ggZnJvbSB0aGUgc3BlY2lmaWVkIHByaW1pdGl2ZS5cbiAgICogQHBhcmFtIHByaW1pdGl2ZSBUaGUgc291cmNlIHByaW1pdGl2ZSBvYmplY3QuXG4gICAqL1xuICBwYXJzZVByaW1pdGl2ZShwcmltaXRpdmU6IGFueSkge1xuICAgIGxldCB7IGF0dHJpYnV0ZXMsIHRhcmdldHMgfSA9IHByaW1pdGl2ZVxuXG4gICAgbGV0IGdlb21ldHJ5ID0gT2JqZWN0LmFzc2lnbjxNZXNoR2VvbWV0cnkzRCwgUGFydGlhbDxNZXNoR2VvbWV0cnkzRD4+KG5ldyBNZXNoR2VvbWV0cnkzRCgpLCB7XG4gICAgICBpbmRpY2VzOiB0aGlzLnBhcnNlQnVmZmVyKHByaW1pdGl2ZS5pbmRpY2VzKSxcbiAgICAgIHBvc2l0aW9uczogdGhpcy5wYXJzZUJ1ZmZlcihhdHRyaWJ1dGVzW1wiUE9TSVRJT05cIl0pLFxuICAgICAgbm9ybWFsczogdGhpcy5wYXJzZUJ1ZmZlcihhdHRyaWJ1dGVzW1wiTk9STUFMXCJdKSxcbiAgICAgIHRhbmdlbnRzOiB0aGlzLnBhcnNlQnVmZmVyKGF0dHJpYnV0ZXNbXCJUQU5HRU5UXCJdKSxcbiAgICAgIGpvaW50czogdGhpcy5wYXJzZUJ1ZmZlcihhdHRyaWJ1dGVzW1wiSk9JTlRTXzBcIl0pLFxuICAgICAgd2VpZ2h0czogdGhpcy5wYXJzZUJ1ZmZlcihhdHRyaWJ1dGVzW1wiV0VJR0hUU18wXCJdKSxcbiAgICB9KVxuICAgIGZvciAobGV0IGkgPSAwOyB0cnVlOyBpKyspIHtcbiAgICAgIGxldCBidWZmZXIgPSB0aGlzLnBhcnNlQnVmZmVyKGF0dHJpYnV0ZXNbYFRFWENPT1JEXyR7aX1gXSlcbiAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkudXZzID0gZ2VvbWV0cnkudXZzIHx8IFtdXG4gICAgICBnZW9tZXRyeS51dnMucHVzaChidWZmZXIpXG4gICAgfVxuICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ2VvbWV0cnkudGFyZ2V0cyA9IGdlb21ldHJ5LnRhcmdldHMgfHwgW11cbiAgICAgICAgZ2VvbWV0cnkudGFyZ2V0cy5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbnM6IHRoaXMucGFyc2VCdWZmZXIodGFyZ2V0c1tpXVtcIlBPU0lUSU9OXCJdKSxcbiAgICAgICAgICBub3JtYWxzOiB0aGlzLnBhcnNlQnVmZmVyKHRhcmdldHNbaV1bXCJOT1JNQUxcIl0pLFxuICAgICAgICAgIHRhbmdlbnRzOiB0aGlzLnBhcnNlQnVmZmVyKHRhcmdldHNbaV1bXCJUQU5HRU5UXCJdKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0ZXJpYWw6IE1hdGVyaWFsXG4gICAgaWYgKHByaW1pdGl2ZS5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtYXRlcmlhbCA9IHRoaXMucGFyc2VNYXRlcmlhbChcbiAgICAgICAgdGhpcy5fYXNzZXQuZGVzY3JpcHRvci5tYXRlcmlhbHNbcHJpbWl0aXZlLm1hdGVyaWFsXSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0ZXJpYWwgPSB0aGlzLnBhcnNlTWF0ZXJpYWwoKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE1lc2gzRChnZW9tZXRyeSwgbWF0ZXJpYWwpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbnRhaW5lciBmcm9tIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAgICogQHBhcmFtIG5vZGUgVGhlIHNvdXJjZSBub2RlIG9iamVjdCBvciBpbmRleC5cbiAgICovXG4gIHBhcnNlTm9kZShub2RlOiBhbnkpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG5vZGUgPSB0aGlzLl9hc3NldC5kZXNjcmlwdG9yLm5vZGVzW25vZGVdXG4gICAgfVxuICAgIGxldCBjb250YWluZXIgPSBPYmplY3QuYXNzaWduPENvbnRhaW5lcjNELCBQYXJ0aWFsPENvbnRhaW5lcjNEPj4obmV3IENvbnRhaW5lcjNEKCksIHtcbiAgICAgIG5hbWU6IG5vZGUubmFtZVxuICAgIH0pXG4gICAgaWYgKG5vZGUudHJhbnNsYXRpb24pIHtcbiAgICAgIGNvbnRhaW5lci5wb3NpdGlvbi5zZXQoXG4gICAgICAgIG5vZGUudHJhbnNsYXRpb25bMF0sIG5vZGUudHJhbnNsYXRpb25bMV0sIG5vZGUudHJhbnNsYXRpb25bMl1cbiAgICAgIClcbiAgICB9XG4gICAgaWYgKG5vZGUucm90YXRpb24pIHtcbiAgICAgIGNvbnRhaW5lci5yb3RhdGlvblF1YXRlcm5pb24uc2V0KFxuICAgICAgICBub2RlLnJvdGF0aW9uWzBdLCBub2RlLnJvdGF0aW9uWzFdLCBub2RlLnJvdGF0aW9uWzJdLCBub2RlLnJvdGF0aW9uWzNdXG4gICAgICApXG4gICAgfVxuICAgIGlmIChub2RlLnNjYWxlKSB7XG4gICAgICBjb250YWluZXIuc2NhbGUuc2V0KG5vZGUuc2NhbGVbMF0sIG5vZGUuc2NhbGVbMV0sIG5vZGUuc2NhbGVbMl0pXG4gICAgfVxuICAgIGlmIChub2RlLm1hdHJpeCkge1xuICAgICAgY29udGFpbmVyLnRyYW5zZm9ybS5zZXRGcm9tTWF0cml4KG5ldyBUcmFuc2Zvcm1NYXRyaXgobm9kZS5tYXRyaXgpKVxuICAgIH1cbiAgICByZXR1cm4gPENvbnRhaW5lcjNEPmNvbnRhaW5lclxuICB9XG5cbiAgcGFyc2VNb2RlbCgpIHtcbiAgICBsZXQgbm9kZXMgPSA8Q29udGFpbmVyM0RbXT50aGlzLl9kZXNjcmlwdG9yLm5vZGVzLm1hcCgobjogYW55KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU5vZGUobilcbiAgICB9KVxuICAgIGxldCBzY2VuZSA9IHRoaXMuX2Rlc2NyaXB0b3Iuc2NlbmVzW3RoaXMuX2Fzc2V0LmRlc2NyaXB0b3Iuc2NlbmUgfHwgMF1cbiAgICBsZXQgbW9kZWwgPSBuZXcgTW9kZWwoKVxuXG4gICAgbGV0IGNyZWF0ZUhpZXJhcmNoeSA9IChwYXJlbnQ6IENvbnRhaW5lcjNELCBub2RlOiBudW1iZXIpID0+IHtcbiAgICAgIGxldCBtZXNoID0gdGhpcy5fYXNzZXQuZGVzY3JpcHRvci5ub2Rlc1tub2RlXS5tZXNoXG4gICAgICBsZXQgc2tpbjogU2tpbiB8IHVuZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuX2Fzc2V0LmRlc2NyaXB0b3Iubm9kZXNbbm9kZV0uc2tpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNraW4gPSB0aGlzLnBhcnNlU2tpbih0aGlzLl9hc3NldC5kZXNjcmlwdG9yLm5vZGVzW25vZGVdLnNraW4sIG5vZGVzW25vZGVdLCBub2RlcylcbiAgICAgIH1cblxuICAgICAgaWYgKG1lc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGxldCBwcmltaXRpdmUgb2YgdGhpcy5wYXJzZU1lc2gobWVzaCkpIHtcbiAgICAgICAgICBtb2RlbC5tZXNoZXMucHVzaChub2Rlc1tub2RlXS5hZGRDaGlsZChwcmltaXRpdmUpKVxuICAgICAgICAgIG1vZGVsLm1lc2hlc1ttb2RlbC5tZXNoZXMubGVuZ3RoIC0gMV0uc2tpbiA9IHNraW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFyZW50LmFkZENoaWxkKG5vZGVzW25vZGVdKVxuICAgICAgaWYgKCF0aGlzLl9hc3NldC5kZXNjcmlwdG9yLm5vZGVzW25vZGVdLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5fYXNzZXQuZGVzY3JpcHRvci5ub2Rlc1tub2RlXS5jaGlsZHJlbikge1xuICAgICAgICBjcmVhdGVIaWVyYXJjaHkobm9kZXNbbm9kZV0sIGNoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBub2RlIG9mIHNjZW5lLm5vZGVzKSB7XG4gICAgICBjcmVhdGVIaWVyYXJjaHkobW9kZWwsIG5vZGUpXG4gICAgfVxuICAgIGlmICh0aGlzLl9hc3NldC5kZXNjcmlwdG9yLmFuaW1hdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGFuaW1hdGlvbiBvZiB0aGlzLl9hc3NldC5kZXNjcmlwdG9yLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgbW9kZWwuYW5pbWF0aW9ucy5wdXNoKHRoaXMucGFyc2VBbmltYXRpb24oYW5pbWF0aW9uLCBub2RlcykpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RlbFxuICB9XG59XG5cbmNvbnN0IGNvbXBvbmVudENvdW50OiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfSA9IHtcbiAgU0NBTEFSOiAxLCBWRUMyOiAyLCBWRUMzOiAzLCBWRUM0OiA0LCBNQVQyOiA0LCBNQVQzOiA5LCBNQVQ0OiAxNlxufVxuXG5jb25zdCBjb21wb25lbnRTaXplOiB7IFtuYW1lOiBudW1iZXJdOiBudW1iZXIgfSA9IHtcbiAgWzUxMjBdOiAxLCBbNTEyMV06IDEsIFs1MTIyXTogMiwgWzUxMjNdOiAyLCBbNTEyNV06IDQsIFs1MTI2XTogNFxufSIsImV4cG9ydCB7IGdsVEZMb2FkZXIgfSBmcm9tIFwiLi9sb2FkZXIvZ2x0Zi1sb2FkZXJcIlxuZXhwb3J0IHsgZ2xURkJpbmFyeUxvYWRlciB9IGZyb20gXCIuL2xvYWRlci9nbHRmLWJpbmFyeS1sb2FkZXJcIlxuZXhwb3J0IHsgZ2xURkFzc2V0IH0gZnJvbSBcIi4vZ2x0Zi9nbHRmLWFzc2V0XCJcbmV4cG9ydCB7IE9ic2VydmFibGVQb2ludDNEIH0gZnJvbSBcIi4vdHJhbnNmb3JtL29ic2VydmFibGUtcG9pbnRcIlxuZXhwb3J0IHsgT2JzZXJ2YWJsZVF1YXRlcm5pb24gfSBmcm9tIFwiLi90cmFuc2Zvcm0vb2JzZXJ2YWJsZS1xdWF0ZXJuaW9uXCJcbmV4cG9ydCB7IFRyYW5zZm9ybTNEIH0gZnJvbSBcIi4vdHJhbnNmb3JtL3RyYW5zZm9ybVwiXG5leHBvcnQgeyBUcmFuc2Zvcm1NYXRyaXggfSBmcm9tIFwiLi90cmFuc2Zvcm0vdHJhbnNmb3JtLW1hdHJpeFwiXG5leHBvcnQgeyBDb250YWluZXIzRCB9IGZyb20gXCIuL2NvbnRhaW5lclwiXG5leHBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiLi9jYW1lcmEvY2FtZXJhXCJcbmV4cG9ydCB7IENhbWVyYU9yYml0Q29udHJvbCB9IGZyb20gXCIuL2NhbWVyYS9jYW1lcmEtb3JiaXQtY29udHJvbFwiXG5leHBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi9tZXNoL21lc2hcIlxuZXhwb3J0IHsgTWVzaEdlb21ldHJ5M0QgfSBmcm9tIFwiLi9tZXNoL2dlb21ldHJ5L21lc2gtZ2VvbWV0cnlcIlxuZXhwb3J0IHsgTWVzaFNoYWRlciB9IGZyb20gXCIuL21lc2gvbWVzaC1zaGFkZXJcIlxuZXhwb3J0IHsgTW9kZWwgfSBmcm9tIFwiLi9tb2RlbFwiXG5leHBvcnQgeyBBbmltYXRpb24gfSBmcm9tIFwiLi9hbmltYXRpb25cIlxuZXhwb3J0IHsgTGlnaHRUeXBlIH0gZnJvbSBcIi4vbGlnaHRpbmcvbGlnaHQtdHlwZVwiXG5leHBvcnQgeyBMaWdodCB9IGZyb20gXCIuL2xpZ2h0aW5nL2xpZ2h0XCJcbmV4cG9ydCB7IExpZ2h0aW5nRW52aXJvbm1lbnQgfSBmcm9tIFwiLi9saWdodGluZy9saWdodGluZy1lbnZpcm9ubWVudFwiXG5leHBvcnQgeyBJbWFnZUJhc2VkTGlnaHRpbmcgfSBmcm9tIFwiLi9saWdodGluZy9pbWFnZS1iYXNlZC1saWdodGluZ1wiXG5leHBvcnQgeyBTdGFuZGFyZFBpcGVsaW5lIH0gZnJvbSBcIi4vcGlwZWxpbmUvc3RhbmRhcmQtcGlwZWxpbmVcIlxuZXhwb3J0IHsgTWF0ZXJpYWxSZW5kZXJQYXNzIH0gZnJvbSBcIi4vcGlwZWxpbmUvbWF0ZXJpYWwtcmVuZGVyLXBhc3NcIlxuZXhwb3J0IHsgTWF0ZXJpYWwgfSBmcm9tIFwiLi9tYXRlcmlhbC9tYXRlcmlhbFwiXG5leHBvcnQgeyBNYXRlcmlhbFJlbmRlclNvcnRUeXBlIH0gZnJvbSBcIi4vbWF0ZXJpYWwvbWF0ZXJpYWwtcmVuZGVyLXNvcnQtdHlwZVwiO1xuZXhwb3J0IHsgQ3ViZW1hcExvYWRlciB9IGZyb20gXCIuL2xvYWRlci9jdWJlbWFwLWxvYWRlclwiXG5leHBvcnQgeyBDdWJlbWFwIH0gZnJvbSBcIi4vY3ViZW1hcC9jdWJlbWFwXCJcbmV4cG9ydCB7IFNoYWRlclNvdXJjZUxvYWRlciB9IGZyb20gXCIuL2xvYWRlci9zaGFkZXItc291cmNlLWxvYWRlclwiXG5leHBvcnQgeyBTa3lib3ggfSBmcm9tIFwiLi9za3lib3gvc2t5Ym94XCJcbmV4cG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWwgfSBmcm9tIFwiLi9tYXRlcmlhbC9zdGFuZGFyZC9zdGFuZGFyZC1tYXRlcmlhbFwiXG5leHBvcnQgeyBTdGFuZGFyZE1hdGVyaWFsQWxwaGFNb2RlIH0gZnJvbSBcIi4vbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtbWF0ZXJpYWwtYWxwaGEtbW9kZVwiXG5leHBvcnQgeyBTdGFuZGFyZE1hdGVyaWFsRGVidWdNb2RlIH0gZnJvbSBcIi4vbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtbWF0ZXJpYWwtZGVidWctbW9kZVwiXG5leHBvcnQgeyBQaWNraW5nSGl0QXJlYSB9IGZyb20gXCIuL3BpY2tpbmcvcGlja2luZy1oaXRhcmVhXCJcbmV4cG9ydCB7IFBpY2tpbmdNYW5hZ2VyIH0gZnJvbSBcIi4vcGlja2luZy9waWNraW5nLW1hbmFnZXJcIlxuZXhwb3J0IHsgU2tpbiB9IGZyb20gXCIuL3NraW5uaW5nL3NraW5cIlxuZXhwb3J0IHsgSm9pbnQgfSBmcm9tIFwiLi9za2lubmluZy9qb2ludFwiXG5leHBvcnQgeyBTaGFkb3dSZW5kZXJQYXNzIH0gZnJvbSBcIi4vc2hhZG93L3NoYWRvdy1yZW5kZXItcGFzc1wiXG5leHBvcnQgeyBTaGFkb3dDYXN0aW5nTGlnaHQgfSBmcm9tIFwiLi9zaGFkb3cvc2hhZG93LWNhc3RpbmctbGlnaHRcIlxuZXhwb3J0IHsgU2hhZG93UXVhbGl0eSB9IGZyb20gXCIuL3NoYWRvdy9zaGFkb3ctcXVhbGl0eVwiXG5leHBvcnQgeyBQb3N0UHJvY2Vzc2luZ1Nwcml0ZSB9IGZyb20gXCIuL3Nwcml0ZS9wb3N0LXByb2Nlc3Npbmctc3ByaXRlXCJcbmV4cG9ydCB7IFJheSB9IGZyb20gXCIuL21hdGgvcmF5XCJcbmV4cG9ydCB7IFBsYW5lIH0gZnJvbSBcIi4vbWF0aC9wbGFuZVwiXG5leHBvcnQgeyBWZWMzIH0gZnJvbSBcIi4vbWF0aC92ZWMzXCJcbmV4cG9ydCB7IE1hdDQgfSBmcm9tIFwiLi9tYXRoL21hdDRcIlxuZXhwb3J0IHsgUXVhdCB9IGZyb20gXCIuL21hdGgvcXVhdFwiXG5leHBvcnQgeyBDb2xvciB9IGZyb20gXCIuL2NvbG9yXCJcbmV4cG9ydCB7IEN1YmVtYXBGYWNlcyB9IGZyb20gXCIuL2N1YmVtYXAvY3ViZW1hcC1mYWNlc1wiXG5leHBvcnQgeyBDdWJlbWFwUmVzb3VyY2UgfSBmcm9tIFwiLi9jdWJlbWFwL2N1YmVtYXAtcmVzb3VyY2VcIlxuZXhwb3J0IHsgU3ByaXRlM0QgfSBmcm9tIFwiLi9zcHJpdGUvc3ByaXRlXCJcbmV4cG9ydCB7IFNwcml0ZUJhdGNoUmVuZGVyZXIgfSBmcm9tIFwiLi9zcHJpdGUvc3ByaXRlLWJhdGNoLXJlbmRlcmVyXCJcbmV4cG9ydCB7IFNwcml0ZUJpbGxib2FyZFR5cGUgfSBmcm9tIFwiLi9zcHJpdGUvc3ByaXRlLWJpbGxib2FyZC10eXBlXCIiLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgSW5zdGFuY2VkTWVzaDNEIH0gZnJvbSBcIi4vbWVzaC9pbnN0YW5jZWQtbWVzaFwiXG5pbXBvcnQgeyBDb250YWluZXIzRCB9IGZyb20gXCIuL2NvbnRhaW5lclwiXG5pbXBvcnQgeyBNb2RlbCB9IGZyb20gXCIuL21vZGVsXCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuL21lc2gvbWVzaFwiXG5cbmV4cG9ydCBjbGFzcyBJbnN0YW5jZWRNb2RlbCBleHRlbmRzIENvbnRhaW5lcjNEIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbWVzaGVzOiBJbnN0YW5jZWRNZXNoM0RbXSkge1xuICAgIHN1cGVyKClcbiAgICBmb3IgKGxldCBtZXNoIG9mIG1lc2hlcykge1xuICAgICAgdGhpcy5hZGRDaGlsZChtZXNoKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kob3B0aW9uczogYm9vbGVhbiB8IFBJWEkuSURlc3Ryb3lPcHRpb25zIHwgdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKVxuICAgIGZvciAobGV0IG1lc2ggb2YgdGhpcy5tZXNoZXMpIHtcbiAgICAgIG1lc2guZGVzdHJveShvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tKG1vZGVsOiBNb2RlbCkge1xuICAgIGNvbnN0IG1lc2hlczogSW5zdGFuY2VkTWVzaDNEW10gPSBbXVxuICAgIGNvbnN0IGNsb25lQ2hpbGRyZW4gPSA8VCBleHRlbmRzIENvbnRhaW5lcjNEPihub2RlOiBDb250YWluZXIzRCwgcGFyZW50OiBUKSA9PiB7XG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gzRCkge1xuICAgICAgICAgIGNvbnN0IG1lc2ggPSBjaGlsZC5jcmVhdGVJbnN0YW5jZSgpXG4gICAgICAgICAgbWVzaC5uYW1lID0gY2hpbGQubmFtZVxuICAgICAgICAgIG1lc2hlcy5wdXNoKHBhcmVudC5hZGRDaGlsZChtZXNoKSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lcjNEKSB7XG4gICAgICAgICAgY29uc3QgY29weSA9IG5ldyBDb250YWluZXIzRCgpXG4gICAgICAgICAgY29weS5uYW1lID0gbm9kZS5uYW1lXG4gICAgICAgICAgY29weS5wb3NpdGlvbiA9IGNoaWxkLnBvc2l0aW9uXG4gICAgICAgICAgY29weS5zY2FsZSA9IGNoaWxkLnNjYWxlXG4gICAgICAgICAgY29weS5yb3RhdGlvblF1YXRlcm5pb24gPSBjaGlsZC5yb3RhdGlvblF1YXRlcm5pb25cbiAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGQoY29weSlcbiAgICAgICAgICBjbG9uZUNoaWxkcmVuKGNoaWxkLCBjb3B5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50XG4gICAgfVxuICAgIHJldHVybiBjbG9uZUNoaWxkcmVuKG1vZGVsLCBuZXcgSW5zdGFuY2VkTW9kZWwobWVzaGVzKSlcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJQUFBQUNBQ0FJQUFBQk1YUGFjQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUNCalNGSk5BQUI2SlFBQWdJTUFBUG4vQUFDQTZRQUFkVEFBQU9wZ0FBQTZtQUFBRjIrU1g4VkdBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBQUIzUkpUVVVINHdzWERnZ1RvT043WndBQUZmWkpSRUZVZU5yTlhXdXYyenFTckthVTNFeHdMN0RBL1B2OXBRdkVJdmVEK09nblJjaytaOFk0TUNpS2txMnE2dW9tSlNmMHYzLy9sVit2UWxTQVVsQVEvQlVVQUxJVDhRQjR3MFNqQlAydG9UcnRlN2lyak1QZDkzbm40dDcxQWJ5aDJxK2NkN3hlNVhWWXJPMGZ2SDdGd1RYdXZCRnpjQnYwaGZlVlhZLzduekZCd0U1RVJBQkFIVHNLT0tCeEFwSkExeDZxbVBhOXhNYVFiUFR4ZGpCTjN4VWZhc0RZVzhUSWlJQnZROXdOZ2d6c0JGQUJrUmdSdmhvRy9XcGxOMis1eDEzdlVGaXZmQjMzRUdMc090d3p0dHhOZVAyUEc0b0pEdDFPQk9JZEY0RFZYVE9BcHVCcG1GcGcrU0F1Qk1Ra1VDNDdKNXVmd2hyVFR0UUl1SXRqRTFkNDNLS0FnODlhT1hxSkF3S1ZWY2wvVU9tTG5aSUE5Nkt2NG1BZFU5WG54Z0dWRy9KZkhjWTRtTU45QytLb2dRWFZ4eEh3YVE2SVJrVTRPWUhLSHhIV3Q2eEd3RW9nbHJmbUtLOWd2V2cxMFFDMUtTM29FUWVQODhIaStMdm5tQjl1b3pCS0FHb1h2TDJUVHNUUkk1T3djcVV2OENMWFc5elRyT1NQbFVvR0trUlkwbnJIWjJpdEUxUEpHd3V5VmRCTkRucU1YMkMyL0xwVjNzdzNCN0lFbEJ1Z1QvWXV0aGQzQlZYUUFnY2lvVC9LeVE4R3ovM0VCb1N3QXBrTUxMN3ZnejRoSU9xcEJEZ3F2aE1IWFdMcnNOcmhRcmxtR2pYWE82NGlBTk5ENEVVR1BIcFVld0o2QWRJQ0pTTUN1dm11NTJSZDFkNlBBN2V5dElNbkJlaWNBNFdwTWlLRkY3d2dtS0J2TTJxWmJsNFEwTCs0dU1qbE9DaG1QdUhQUG01NjBXUnlFRUVQTTBaOEdXWkU4SmpBVkxZcnJuS3J4eVJoWS9ScUxqT0dRYXNKOGdvbnNLN1hPV0J4ZVdsQjhDSUFVVFJJT0ZaY1pSSGM5V0VFN0RBSVdvRFVOUFZhenUvbDVFVm5tMytJbmNTQmtjcURBSks4K2FibHlUVVpXOWRFWHpWWWlpQnpFT3NSbitHVjJHOXk0QzVVVEdaOGwvTWdXT0diNWF3SDlqMjV2bklGd0RtQVRnTGdjbkRWYzMweFZ4ZTU2RVdjQTZmZk85bmRTdVlXdm91ZXM3SUxLZ2tYRDNHYWNnQ0p0VGJaT0YxUEJrd0k2VTVJVjVLUE51MTNpNXpFbVI0dEFMck9CRlVDYU55TklUam1vMWl4cU5ucnNUS2ZYQSttMG5idE84cTZsN2pyQWMzWkZPaTNVdlJkaHRRcnpnSEJabWs5WkRnb2J1ZjlPZHJGS0ZNUnJNZ2ZVMHpoSFJzQkdpb3BQaVM2SElncVNLR3NoTytWUmpDM1pZcFhzNzdKUVZUUElHNGpOaFlOWWhTNG1IVis4RFdTc0NxNjFhWGJnRDBIT0NWUU1GVU91Vm5nUVBOaEpnZUluUWV4dFBuZUZWM2JvOTU1NlJ4ZzRYTTMrejBXa2owa1BjZS9aeW5sNXN5UExpZHhKdVhNdnkvL3FsRnBxS0p6RWRsYmhFMEdOd3Zpc3JWYThzSkM1RzE1NjVWellQc25sNmpLelhDTTk4WG0ydS85RkovMFdTZzhPd1JxSGpBQlduMi9jNU80TlVFc2NsM0dnWnVyUmR0d0VFNFRaUVVGdzkwNk5BVklqM0M4UkJsVEQ1UnJRV2M5R3MxdGVNVkdBQVFONTBuVWJNQVBEamh6Tk9lTFgzbEJkeTFkSlV0WVZ6N2s5b3prQ201YUdBYXhGc1NzZkRLL1BPbXhFemRpb2FEU3NwdDd4WmRkNHlBYVBxOVNMaU9BRm5yV29iKzF0eVhodnMxOUp1SUErbGtINTFhZlNjdDkzenpyK2lTVmVZZjNEV01nTGx6K0tqL2QzVVVMblR1YUJmRmx3Z2tIYXBpZG5SYm9sQUE1VGJzOVZZNHZvTWlUM0RyMk1hejhBMWNnZGp0N1JkQWlvSU5Jc3h3QXBseTd5WTBlM2hOUnl2ckQydGRlNkFwR1QwMDhPc2t0WFNOZ1Y1RmsyenNrWkZCcGJlcEZvblN6RDhPNmEyZW00T1A5a0o5Mkc5bW5jVERmdFJJMzh4NjNQU1ppSUMza3lVemZsa2syQXhkTHFxd2RmZCtmbEVhUDFIMDNBMGN6RllxUFdzYzkrcmdXQVIzS0Jma0xGYXVVZTA2cWkrQUEzbkpGS2ZvN1hVelRGdFVkREl1a3JTd2lUWTlhWjJKbFUwZkFnRjdKMzlXN2JCT2JBWndqUlFMd3BxeDJBZUNkZk9ENitJcFJyQ08rdU92dXNGMTg2UWFsdU5xRnRGemlUZlFNQVlPTFhWbTZ3OEhNcjY4S1V6S25GTmJzVWJpQzhzcDRuUU42Y3hUNEZ2b21YWkp5MXJjSjFmUDRmR0loTDJ4MFJsaFBPYUNWT0xocElJOHhwYlc5dmUwa1lXNGRPaE80OHVmbFRiQjZZUXNoeUkrNHhucmk1aXQ1TWpDaVZaR2F3OTlCZjlJWUVZQXIrWWVkcXY2UmFSbmVYZVZpZXVhQU92MHIrQVordFNqVkIyamVJcVpaRU91dUNlQksvaXRsVWdueWdZVW00cUIzaGhEUDk3NGh6emZoWGh5Z2N3RGFUTGc0U3piWEhQQWN3TTg1T0lDRTJNb3o0SURpNExodXQ4T2ZnQ3NKZHNGOWs0eWlJbURtUWl1K3BQaVExK0RZMFVwa21FN1haRzdoKy9FQno4WTdFU0FhSHZUaFlwSHlIK2dady9nU0NrM1BpeHpKVDREMmRDb2E5NFc4aU85SFRyTHJEbkhmSkNSalZENUJXaDRGbFFGZGU3ZFhGNjF3Y0VOM3l4em96c2NITG84WkVWRFlTbHhwZXEvL2JFRkhQSUorT2x2bVk0cEVNd0pYY1RBUis5eXMxM0ZaUC96dVNlWmpkdDNkSkcrbkFxcEhTSHVoTkxMQ0o4K0wzQUVVRDd1VUtzbXozWUwrL1FHWFIrMmc5aGhFcTM5SzdFTEZRQit0SUZGMGN3ME1RWVdhQ29zSWJuYlVaeUgyMzczVFhuN0tJaVdsVzFDQlFML2JUbTJVOGF5SzVXQUVoT3drdTZ4ay9jZWthRnJoNEQwbzU4TSs4RUZyUEozcmdDSUo2d2pvWUVuUUJSbXlvZUYyUGFwdCtxQmJ4UVdzdU1tQXlydkEyZE8raWZYa3ZRQjc2Wjl3R1FHQitUZ0xSMjRhOFB6SGh6am1ZTzRNcXQrNVpzKytMc240N0xzbTRFU3dvUDZCUWRmUjU4SWZVUUxSV0p5cFVkRFdnRnFrSkVrekRtTHNKbUwvQnVqZGo1QlZVQmxsS0UvRnhhTFBDbE9BUlU4N0ZYbkVkTTl4L2NkeW9QQmRsV283dno5bXZuZDZ5UHh6SC9CWExhaEdnUEVjbFlHN0VZVVJ3RlEvSHZqcFZoUGwzb0FENittVHNMaVUvRHdJYnNYTkE2Qm5CSnluNmRDakcxR1IxbFRFSEUxRXdNTENVU2VEb0R2SmExdlFPZUxYSEtpVHZFZkQxeEpRK2p5Z3lWZEFMM0VmNzJDaHdEYTU2Z3VDS29qejRYSEFRWGNwc1lqZmE2eTUwR05XN0lCcEJFRER6ZWNFS2lWMHVLUEpXdWthbC8wQzkvYmhNKzBiQ2MvYTd1QXJudTRDZlRjT0l1aDUveWhEdTlWMERqSU1FMTNFWnJtQ2lIVmE0WE15MEhDUkhGZy82U1JaMWFzUTRTZVpRMnl4V0hlblorbGhFaE5wV0JCWUVqWk13S1FCbVBleDlOYml3ekVmcS9xT0kvY0VMdzRVeEQ0SE1KdUtOZzdFZHlXSmFNRFpTS0lLS3FiQmNDOUs5VnphYUxydWo3WlI1YUJ2Z2pVZ09kQ05xellod0gzTnRWYTAvM0YzY2lPZzVRQXkyZytDNEh3VmlUdWEyRXVMZ05MSXVNZ0VIYThPcXhjSHJycko4R0VIT1B4ZFlmMFIzQytqZ2I4WFlNK01nRnlRcVRiQ0dyVGgzajJuOVBxblA1ZElqQU00WkpBMEpSVUgybjlNTW5BNWNHektFSE1ML1UvNXp5UTRSQVJrVi80c0NJYjhQZlJGL2RQdFNFYkFjQ0VKTGc4SXE5a1ZJd3A5YVJJZmI1ZXo3OGdmUURyLzdlaENLRW44YTkwWmdnL3dJSmkvSkRFS2ZhMzNCajFKNklYa09kYVI0Y3hqd3UxNWxBYnVJczY5UG5xdlNUalRBUDAwbnl4RDRUeEMxYUJhL3N4NWVCVWs3RWpwM2FwK3drb1VFRzFoL1ZaTXZHayt0NEpnTWpJRGUwblNnZ2k1dE0yKzVOQ0NZSnpTZTFHTEVqSEtscTIyczFHaW9FK3RKNmxka3pZdWt2TWtCend6L1djNUFFRFNaV2dRQWZBcUgyN2xYZjcxN041RXdYVWg4dUtnTjVLTDNRSzQwVkdMUWZDbHVOdVQ3UG0wSUVMT05ldU9DT0RWcDR3bVYvNGduYVVoL1lmc0JLMjVtVzg0QzBhazJvdXNJRDdxZTlESHlBSE5na3BDTHNpMkhKSitVdnJ2bVNETmZVS1BHdzBzRGl3SHlRdUwwNGpTQ3RiektWdmMrVzNhUjg4Qm1aQVo5SllBSGdIY3dJZjJUWDVXd2gvY3NEZzROMzBPUEJBdkhXa2Q5RnYrRTFuSFk5V3I4OVFjb05EWE5haVVzaVdCVEg3VzhXRVRlTGNqeThGQ05JUkpJZ0tkZ09MVVM0czBmQmIzM3BtQVBhY1dBZm1hZ0FtZS9EVm14UjdXSWVMdFBURU9FaVRpVnViUnZPeHFNZU5aQkh3RWQyRkI1enlnQURtaFpFRUF6QzhwSE56ZEpUbWJIaVQ2a0o0VGFkWmhRdTI5c3Y0NTdvdlF2Mi8zTGl2VmduSkNKaHhBQm82RVhGb2hWTm82YzFjK2c5U1Z2d0djTVNFSjYzb0hnZUFFZ1VvR2dnbURzdXRGbjRYK0k3YkRZV0FFRUhKQzhTd0kxbitDSDhnUlJvR2tGeUZrY0JCRUhJaTFoOENJa2dlMHNLT3IxU0VzMEhBTCtydUlSNXN5QXBMZ1FHaS9HRHhKa0dNcWU4bTJlMU9zWndLd1RHc2lvT2NBeThkRS9oV2pxU01oN3RSWWwzRHZDdTRMQlBRa2ZEWUtTa1k1Y3dUSHNkMWc2VmVPZHBFOVlXajBGZUlRb09zN1ltNFo2Z2JCMmxUNTBuOG1mRXprZjVlQXllYXdvSnh4bk8rb2s3SlM1SDlBd0JMbUNYTnVIQlFtYzY1MS9tRXFEc1E4QUhIcEtjdDhKd2dtMVZIN3RGRjZCcmNoMTZGLzRQdnpnS2dSY0ZCRFB5Rm5QUXVyOHV3dTFHYWt3SGhndEJ1VlkvNThMc2FnaDJ2aUV2Y1RhSlYxZFNhNCtZZWdjUmZ1ZGNsUGhna0xPakJjcUpaQWpRY3V0Nkg5VnFTV25weUwvbURuMWIxSTh0RkRJYzNKVUNHeXpBUVdPSWlFL0tia2hRMUlNQVlCUjBZbUhRRjlVSUVBQWtBbXBLNTkrYit2d254R0IzcmdEbVkrQ0ZkK1ZCQWtTUVo1OGZFbUIyK0tQVUxjNWVCczdFZkNrWkNCQXpoeVhaSXJ6SWFvdlo5WG13dFNteUxVLzQ5V1RkYkk0NEVMMzdJaTBVOWVQckRGcUM2SHZLb1VDelNzY0xDNGVkbXZ4clFja0hDZ3pzVnFDYVFrM0R3K2w1YVlUOVVYblREUXNrSlNad0M3RWUrR0FzSWdFUG1XQjBFMFNZNFJmNVlHbmdHOWVPeCtuQllFNU5Jc0tESDM3MzlOZEptQVV2Mm5ORExBYzRiOEpOVWVNeS9aazA0SkcxUGk4bGRwSUlJK3VrT0ptSU1aRTBWM1JuS09kazMyamdnNDBUOXluUlgzR1VDOTFBSTZRUzkxeGx2bDMzRDNac2Y2azhUMTg4VE9tRWdzTjR4OHE5QzMvdU90Qy9YWWRaZmsxb05nVWUrUE9kaVBoSVB3YWk1VVRndEt3dnJyVit6YVo0alhDTWhzMC92U2xvUEVBOEtGa3JWblNmaU8vOHh4ZDFBdXEwemNJb04vM0g1c09EYVdBekpLRXVrM01mbHo3Zk1JUUJKNUd3V1VmUTdFbjZxT2xCMHByL2NXNDFibUFWZ200TTBnNFBpdWNNTWlJT0VvalFCVVRFbVdRQU5aNHovbjZwMU9YR2x3WUNIbWVkWDZ5YkFnbUhwVXhjcGFEVHJoNERFQmR6bUlObHNWSkFub21CSzNuYlpTZlI0cGJsanlDTWp0Q2hOSUV1TklIdHJpRTY4NDQyU3JYQWhyQk9pR1NiQXUzQ3VxanpSK3Via2ZXeU9nNEZ3WDZrcXY4TWs1UVMwOTJZMWpEdjJwZlhUdE53NkV1bGtDaU53OFVUQkE1dHZGdTVJMkF1ejd4NkZYUUVjOSs1SHdTamdLWG1YNHo2bml0QTN6b1M3L2s0TWtqS2dpM3VGbTJvZFplQmhlYjZKaGpGRXpMNi9PV1UrL1N1OFBuT2NkNkNNbWFFVEFodGNaQVkyQTAxdExtL1JTZDU1U3l5UXhBY3VnczJyS2JRRTFnMUx6b3M1S2wvOTV2d1ZqTTdYSHhKSXI4TjdKNjZJdnk3MWoweXh0elJQQUF5WUE3Szh6QXM2NUdJM2JNWW5sM2xNK1ErK0VrcG56b0FVQmk0REtDb2YrQkYzR0FTLzhPZTREZWpnMXo4cjZ6d01DYnNuL0V0KzVIZlZ2VW5QQUs3VU1qR0U0OVluTTVqekVzakV3ektyZk5xZ3hMa0ZYNzZmdGRFVVA2TjNrN0MxS0x5NUJUd2hZa3Y4VmpvK3pyazdDcjIxRVFIKys2dFRtTUI5VCs0T0EzTzZ4Wk9ZNXFYRnd5cjlEejIvMk5tbHpZeGt1RkMrM1hhTS8vYWxlUk1NN3dyK0Z0ZHV6SDZubWdQNG9DcHIxSy9QaEtiY3dEdXBWblkwVDlEUWFLWU9vNVZ2dkdZakloWGdqQlNpUHhPQTlmcnN1L1A4STlHY25pNEJtTE1STXBrWTlxelg3N2VKNk42Wm5xZ3dpSUlFQW5PaDM2NmNtZVhQblBTa1htandJTkZsL05wSWZtN0xTdnlILzRuVitGUDBXQVJ2T1BIdyttRTU1K0E5YW5zd0ZLYmNJT0QySDJrUlhKY01PZlFLaHlsK1RVY3phVG5laHN5RXIwV1RpdzZWblhmNlJ6RDl1OXhQaDkvZjlkYTRGbmMvRVpYYkxsMm0vMzNzNUk2Q2FEMEEwNWx6OTFCVWREajNKVlg1NTJ6MXgrU3Vyd1lCKy9qekVISDFmK0lIR24wRi9GLzMrcWhiMDJtb0pSQmorYzJvL0ExdHU5N2xZQkJSaXF3N2QyWU8vMUl5b2d1ZzlCdW9LL0VITjg2enNXYVRoTWRCUlp5TWdzVitiTWlZSzZyd1gzSUlZOUVPa2lZRlZodlhyaHZlWXlleXgzUHNFdU9pdkZ6eFI1NXZRUi8zN0srRlBRazRvYUE5d2w2cnkzRGJyTTBLNVBlZmNBTzNucFRaUEhnbWdNTkI1eGRML1dCVTA1c0E5QjhTT2Yva2txRXZBQ3ZTTDVuT0xqTXRkSXdld242Nk1lNy8xM2t1VzZkZEdmYWxCb09TZnVPZDRENzVObnFseS9oYWVlbHRCZngzNnk4MTNvRC8zN3E4TmZ4THlWcEU5ZStzUFYzdjVuOXBLdzRHZUt6VDBwWWs2Nlh5UWVBNWdaT2liTFZjL2QzR2huNkQvSFByaUFIY1grc3U5NTJzL0p3RTVBVFFxalV4aXlhR3VONXp5UDhhOENaMEF4b0d5L29FN20rVW1pSmhJcnJGNFQwVllQWDRFL1FlcS93ajY2RW00YlBWdU93RGkvMzVLWDIzTzB2UjdneTBUZGZsejBIV2pFeVB2OXlyM2YvK1p3em42aTNiL2RkRDNNWTJBVTF5RWRLTGYvOTJzZm52Z2FMbjNhS2Nvd1orVlA1b0ZXVTkzeS8rYlJ2Uk0vbEhuQk1SbmZNeUg3YStFWTBOQkJhditYZ08xS0tvM2hJOXFQajd1V2ZpN3JqN1pqUmNkR1VWTXI2SzgraG4wNDZXRlM5VS96ckVySS9jL0NhOEVuQS9ZbnZWb0k2QTA4d0VCaDdnZWpuN051bTNxaTRuL2dERng1Mlk2M2tUL3F2R2wwTThIVndzaUFyYUdQckY1YndFTzBDRXZ1ekRRM1lWUG1YZ0g5RFJGM0h1NFUrVmVWZi9jUlgvUitqOEkvZVg0K2xnS0VXaEQzbEFTU3YvZFJaTi9SeE85NEVrTS9UVGtyeXNmSGdFUkI1ZlAwc29CTGhQVWZHWUYvV2MxendQb1Z3N1pYNFFqSVczSU84cU9rdHBCcDhDUGtYWDdmY3BLd0laVWtKSzM3dGF0aG9PdUFzSXMwa1ZwQVBDek1lUVlMRVFBbmdyL0s2QnZCQ1FjRzdBai8yUUVOUE01cjY4N1Q3M1RtNGJoK05DM0lJQ0tBR3JmakJuTGl1TzdsK1RTc0lxK042VjRFOHBuaCt3dndyRUJQN0YxQXNDZWJPaHI4YVdxbmpvSGRQV25JaUN3b1BwOTFTOFJwM2U0ZXNUQVl5aENkclh5S2VHd3owSmZDVGdJeDRiMEUrVW55bzkyaDcyQUR1QmxDaDRhMEVQUkFDY09RSjc3eDZrWXBnM1p1UUt1UzhaNit2MDI2QnNCQ2ZrSDhrK1VYOERlL09jWXpsTVhRWm41dVBKUDBtcWNUT3ZocStvY3Eyc1g5TWkxM1BlNzZIOGI5SldBRnlIL1FQbUY4Z3ZZbXZ4VDgrc1QrbXlnTnh3SXNXTnNjZ2dGRGExL0F1VkU0S3JmeGYycjBYOEg5MEZBSnVTZndDL2dMNkJWOTkzNmtXc3RCQ1ovSkdNN0xNRlN5OXNkY2F0WjhCNXZqdXBtMTVYTVBFSG5XZjN6ZGRCWEFvNkU4Z3ZsTi9BRElDQlg2eDlsYUd3N28wWWlSOVN1QzQzMDRLVlFubjR2ci9NYnFzOHZoYjRTa0JQd0cvaGQvV2VzTnAvb2I0MERZc0kza3l4QUIwUVBBbjN4a2lFMHhEV2EzdXgza29SWEdIb1QvWTlEWHdrb08vQTM4QytBUUYzK0diUUJHK2dsUEtkTEhoaHdneGlzN0RuRGtjYUQyZ1p5Zmt0TSt4eDZDOFM4NXZtNG1Yd1I5SldBL0JmU1A4QXZFQmo2ek80Ulo5MkJDTSszUExYMjVNd0c4NlBjS3h3QkZQLzQ3MjUrZmd6bGw2SVBZQysvZ1g5QVA0QmphSisycHZva2k1eW1NZUhtWUwvREppbHFGd2dTYlpXRVhRaFdLcFpMK2Q4MW42K0cvbnp0K0FmME4xQkFMMUNwQlErU2RwNmhWaExTQnZmOTgyV3k2d1FqeTlBa2l5NHlzZmo2YjBBZndJNy9BWDREZndBQXg1amZ3cHEraVFDTFpuMXV4VUJNY293RjE3M3NTeFJ1K2MvNjY5dlFCNUR3YjlCZm9CMjBOZDluNkN0bkJ3WUhybUo3VFBSTTRGeVppcGorVlBiYTlZczR1TXZZZjk5ckwvOHVCY0NmZWl0R3djMy94NGIrNndIeHIwT3dkbitPcVArYkJiVVhyRjNpTTlqTzRNQUM5cS9qOElaNlp3MWJYMFVaL3B0SjNQZmYrNC8vdzU1b0ord0pXOEpHMkhxRDJ1YUdMU0VscEEzYmhwVFpYMmwvdVQza1hOajlYckFiYXFmMjJ6TVd2RkZuNE8yOS92cUQvLzZTd1UzOW4yZ3BVOXdWaFlnM0YzZDkrbFZ5L245allzNUhkaWNxcFFBQUFDVjBSVmgwWkdGMFpUcGpjbVZoZEdVQU1qQXhPUzB4TVMweU0xUXhNem93T0RveU9Tc3dNVG93TU1kd2FxTUFBQUFsZEVWWWRHUmhkR1U2Ylc5a2FXWjVBREl3TVRrdE1URXRNak5VTVRNNk1EZzZNVGtyTURFNk1EQTRvdFg4QUFBQUFFbEZUa1N1UW1DQ1wiIiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IEN1YmVtYXAgfSBmcm9tIFwiLi4vY3ViZW1hcC9jdWJlbWFwXCJcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29tcG9uZW50cyB1c2VkIGZvciBpbWFnZS1iYXNlZCBsaWdodGluZyAoSUJMKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEltYWdlQmFzZWRMaWdodGluZyB7XG4gIHByaXZhdGUgX2RpZmZ1c2U6IEN1YmVtYXBcbiAgcHJpdmF0ZSBfYnJkZjogUElYSS5UZXh0dXJlXG4gIHByaXZhdGUgX3NwZWN1bGFyOiBDdWJlbWFwXG5cbiAgLyoqIEN1YmUgdGV4dHVyZSB1c2VkIGZvciB0aGUgZGlmZnVzZSBjb21wb25lbnQuICovXG4gIGdldCBkaWZmdXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9kaWZmdXNlXG4gIH1cblxuICAvKiogQlJERiBpbnRlZ3JhdGlvbiBtYXAgbG9va3VwIHRleHR1cmUuICovXG4gIGdldCBicmRmKCkge1xuICAgIHJldHVybiB0aGlzLl9icmRmXG4gIH1cblxuICAvKiogQ3ViZSBtaXBtYXAgdGV4dHVyZSB1c2VkIGZvciB0aGUgc3BlY3VsYXIgY29tcG9uZW50LiAqL1xuICBnZXQgc3BlY3VsYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWN1bGFyXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbWFnZS1iYXNlZCBsaWdodGluZyBvYmplY3QuXG4gICAqIEBwYXJhbSBkaWZmdXNlIEN1YmUgdGV4dHVyZSB1c2VkIGZvciB0aGUgZGlmZnVzZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBzcGVjdWxhciBDdWJlIG1pcG1hcCB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBzcGVjdWxhciBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBicmRmIEJSREYgaW50ZWdyYXRpb24gbWFwIGxvb2t1cCB0ZXh0dXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGlmZnVzZTogQ3ViZW1hcCwgc3BlY3VsYXI6IEN1YmVtYXAsIGJyZGY/OiBQSVhJLlRleHR1cmUpIHtcbiAgICB0aGlzLl9kaWZmdXNlID0gZGlmZnVzZVxuICAgIHRoaXMuX2JyZGYgPSBicmRmIHx8IFBJWEkuVGV4dHVyZS5mcm9tKHJlcXVpcmUoXCIuL2Fzc2V0cy9icmRmLnBuZ1wiKS5kZWZhdWx0KVxuICAgIHRoaXMuX3NwZWN1bGFyID0gc3BlY3VsYXJcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgb2JqZWN0IGlzIHZhbGlkIHRvIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICovXG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlmZnVzZS52YWxpZCAmJiB0aGlzLl9zcGVjdWxhci52YWxpZCAmJiB0aGlzLl9icmRmLnZhbGlkXG4gIH1cbn0iLCJleHBvcnQgZW51bSBMaWdodFR5cGUge1xuICAvKipcbiAgICogQSBsaWdodCB0aGF0IGlzIGxvY2F0ZWQgYXQgYSBwb2ludCBhbmQgZW1pdHMgbGlnaHQgaW4gYSBjb25lIHNoYXBlLlxuICAgKi9cbiAgc3BvdCA9IFwic3BvdFwiLFxuXG4gIC8qKlxuICAgKiBBIGxpZ2h0IHRoYXQgaXMgbG9jYXRlZCBpbmZpbml0ZWx5IGZhciBhd2F5LCBhbmQgZW1pdHMgbGlnaHQgaW4gb25lIFxuICAgKiBkaXJlY3Rpb24gb25seS5cbiAgICovXG4gIGRpcmVjdGlvbmFsID0gXCJkaXJlY3Rpb25hbFwiLFxuXG4gIC8qKiBcbiAgICogQSBsaWdodCB0aGF0IGlzIGxvY2F0ZWQgYXQgYSBwb2ludCBhbmQgZW1pdHMgbGlnaHQgaW4gYWxsIGRpcmVjdGlvbnMgXG4gICAqIGVxdWFsbHkuXG4gICAqL1xuICBwb2ludCA9IFwicG9pbnRcIixcblxuICAvKipcbiAgICogQSBsaWdodCB0aGF0IGlzIHByZXNlbnQgYWxsIGFyb3VuZCB0aGUgc2NlbmUgYW5kIGRvZXNu4oCZdCBjb21lIGZyb20gXG4gICAqIGFueSBzcGVjaWZpYyBzb3VyY2Ugb2JqZWN0LlxuICAgKi9cbiAgYW1iaWVudCA9IFwiYW1iaWVudFwiXG59IiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiLi4vY29sb3JcIlxuaW1wb3J0IHsgQ29udGFpbmVyM0QgfSBmcm9tIFwiLi4vY29udGFpbmVyXCJcbmltcG9ydCB7IExpZ2h0VHlwZSB9IGZyb20gXCIuL2xpZ2h0LXR5cGVcIlxuXG5leHBvcnQgY2xhc3MgTGlnaHQgZXh0ZW5kcyBDb250YWluZXIzRCB7XG4gIC8qKiBUaGUgdHlwZSBvZiB0aGUgbGlnaHQuICovXG4gIHR5cGUgPSBMaWdodFR5cGUucG9pbnRcblxuICAvKiogVGhlIGNvbG9yIG9mIHRoZSBsaWdodC4gKi9cbiAgY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSlcblxuICAvKiogVGhlIHJhbmdlIG9mIHRoZSBsaWdodC4gKi9cbiAgcmFuZ2UgPSAxMFxuXG4gIC8qKiBUaGUgaW50ZW5zaXR5IG9mIHRoZSBsaWdodC4gKi9cbiAgaW50ZW5zaXR5ID0gMTBcblxuICAvKiogVGhlIGlubmVyIGNvbmUgYW5nbGUgc3BlY2lmaWVkIGluIGRlZ3JlZXMuICovXG4gIGlubmVyQ29uZUFuZ2xlID0gMFxuXG4gIC8qKiBUaGUgb3V0ZXIgY29uZSBhbmdsZSBzcGVjaWZpZWQgaW4gZGVncmVlcy4gKi9cbiAgb3V0ZXJDb25lQW5nbGUgPSA0NVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBJbWFnZUJhc2VkTGlnaHRpbmcgfSBmcm9tIFwiLi9pbWFnZS1iYXNlZC1saWdodGluZ1wiXG5pbXBvcnQgeyBMaWdodCB9IGZyb20gXCIuL2xpZ2h0XCJcblxuLyoqXG4gKiBBIGxpZ2h0aW5nIGVudmlyb25tZW50IHJlcHJlc2VudHMgdGhlIGRpZmZlcmVudCBsaWdodGluZyBjb25kaXRpb25zIGZvciBhIFxuICogc3BlY2lmaWMgb2JqZWN0IG9yIGFuIGVudGlyZSBzY2VuZS5cbiAqL1xuZXhwb3J0IGNsYXNzIExpZ2h0aW5nRW52aXJvbm1lbnQgaW1wbGVtZW50cyBQSVhJLklSZW5kZXJlclBsdWdpbiB7XG4gIHByaXZhdGUgX2ltYWdlQmFzZWRMaWdodGluZz86IEltYWdlQmFzZWRMaWdodGluZ1xuXG4gIC8qKiBUaGUgbGlnaHRzIGFmZmVjdGluZyB0aGlzIGxpZ2h0aW5nIGVudmlyb25tZW50LiAqL1xuICBsaWdodHM6IExpZ2h0W10gPSBbXVxuXG4gIC8qKiBUaGUgbWFpbiBsaWdodGluZyBlbnZpcm9ubWVudCB3aGljaCBpcyB1c2VkIGJ5IGRlZmF1bHQuICovXG4gIHN0YXRpYyBtYWluOiBMaWdodGluZ0Vudmlyb25tZW50XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbGlnaHRpbmcgZW52aXJvbm1lbnQgdXNpbmcgdGhlIHNwZWNpZmllZCByZW5kZXJlci5cbiAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIsIGltYWdlQmFzZWRMaWdodGluZz86IEltYWdlQmFzZWRMaWdodGluZykge1xuICAgIHRoaXMucmVuZGVyZXIub24oXCJwcmVyZW5kZXJcIiwgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgbGlnaHQgb2YgdGhpcy5saWdodHMpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0cmFuc2Zvcm0gaGFzIGJlZW4gdXBkYXRlZCBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgbGlnaHRcbiAgICAgICAgLy8gaXMgbm90IHBhcnQgb2YgdGhlIHN0YWdlIGhpZXJhcmNoeS5cbiAgICAgICAgaWYgKCFsaWdodC5wYXJlbnQpIHtcbiAgICAgICAgICBsaWdodC50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKCFMaWdodGluZ0Vudmlyb25tZW50Lm1haW4pIHtcbiAgICAgIExpZ2h0aW5nRW52aXJvbm1lbnQubWFpbiA9IHRoaXNcbiAgICB9XG4gICAgdGhpcy5faW1hZ2VCYXNlZExpZ2h0aW5nID0gaW1hZ2VCYXNlZExpZ2h0aW5nXG4gIH1cblxuICBnZXQgaW1hZ2VCYXNlZExpZ2h0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pbWFnZUJhc2VkTGlnaHRpbmdcbiAgfVxuXG4gIC8qKiBWYWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgb2JqZWN0IGlzIHZhbGlkIHRvIGJlIHVzZWQgZm9yIHJlbmRlcmluZy4gKi9cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiAhdGhpcy5faW1hZ2VCYXNlZExpZ2h0aW5nIHx8IHRoaXMuX2ltYWdlQmFzZWRMaWdodGluZy52YWxpZFxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuXG5QSVhJLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKFwibGlnaHRpbmdcIiwgPGFueT5MaWdodGluZ0Vudmlyb25tZW50KSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBDdWJlbWFwIH0gZnJvbSBcIi4uL2N1YmVtYXAvY3ViZW1hcFwiXG5pbXBvcnQgeyBDdWJlbWFwRmFjZXMgfSBmcm9tIFwiLi4vY3ViZW1hcC9jdWJlbWFwLWZhY2VzXCJcblxuZXhwb3J0IGNvbnN0IEN1YmVtYXBMb2FkZXIgPSB7XG4gIHVzZTogZnVuY3Rpb24gKHJlc291cmNlOiBhbnksIG5leHQ6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAocmVzb3VyY2UuZXh0ZW5zaW9uICE9PSBcImN1YmVtYXBcIikge1xuICAgICAgcmV0dXJuIG5leHQoKVxuICAgIH1cbiAgICBsZXQgbG9hZGVyID0gPFBJWEkuTG9hZGVyPjx1bmtub3duPnRoaXNcblxuICAgIGNvbnN0IG1pcG1hcHMgPSAoPHN0cmluZ1tdPnJlc291cmNlLmRhdGEpLm1hcChtaXBtYXAgPT4ge1xuICAgICAgcmV0dXJuIEN1YmVtYXAuZmFjZXMubWFwKGZhY2UgPT4ge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2UudXJsLnN1YnN0cmluZygwLCByZXNvdXJjZS51cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyBtaXBtYXAucmVwbGFjZShcInt7ZmFjZX19XCIsIGZhY2UpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICAvLyBUaGUgbGlzdCBvZiB1cmxzIChmYWNlcyBhbmQgbWlwbWFwcykgd2hpY2ggbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSB0aGUgXG4gICAgLy8gY3ViZW1hcCBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICBsZXQgdXJscyA9IG1pcG1hcHMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpLCBbXSlcblxuICAgIGxvYWRlci5hZGQodXJscy5maWx0ZXIodXJsID0+ICFsb2FkZXIucmVzb3VyY2VzW3VybF0pLm1hcCgodXJsKSA9PiB7XG4gICAgICByZXR1cm4geyBwYXJlbnRSZXNvdXJjZTogcmVzb3VyY2UsIHVybDogdXJsIH1cbiAgICB9KSlcbiAgICBsZXQgY29tcGxldGVkID0gMFxuXG4gICAgLy8gTGlzdGVuIGZvciByZXNvdXJjZXMgYmVpbmcgbG9hZGVkLlxuICAgIGxldCBiaW5kaW5nID0gbG9hZGVyLm9uTG9hZC5hZGQoKGxvYWRlcjogYW55LCByZXM6IGFueSkgPT4ge1xuICAgICAgaWYgKHVybHMuaW5jbHVkZXMocmVzLnVybCkpIHtcbiAgICAgICAgaWYgKCsrY29tcGxldGVkID09PSB1cmxzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEFsbCByZXNvdXJjZXMgdXNlZCBieSBjdWJlbWFwIGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgICAgICBjb25zdCB0ZXh0dXJlcyA9IG1pcG1hcHMubWFwKGZhY2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIDxDdWJlbWFwRmFjZXM+e1xuICAgICAgICAgICAgICBwb3N4OiBQSVhJLlRleHR1cmUuZnJvbShmYWNlWzBdKSxcbiAgICAgICAgICAgICAgbmVneDogUElYSS5UZXh0dXJlLmZyb20oZmFjZVsxXSksXG4gICAgICAgICAgICAgIHBvc3k6IFBJWEkuVGV4dHVyZS5mcm9tKGZhY2VbMl0pLFxuICAgICAgICAgICAgICBuZWd5OiBQSVhJLlRleHR1cmUuZnJvbShmYWNlWzNdKSxcbiAgICAgICAgICAgICAgcG9zejogUElYSS5UZXh0dXJlLmZyb20oZmFjZVs0XSksXG4gICAgICAgICAgICAgIG5lZ3o6IFBJWEkuVGV4dHVyZS5mcm9tKGZhY2VbNV0pLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmVzb3VyY2UuY3ViZW1hcCA9IEN1YmVtYXAuZnJvbUZhY2VzKHRleHR1cmVzKVxuICAgICAgICAgIGJpbmRpbmcuZGV0YWNoKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgbmV4dCgpXG4gIH0sXG4gIGFkZDogKCkgPT4ge1xuICAgIFBJWEkuTG9hZGVyUmVzb3VyY2Uuc2V0RXh0ZW5zaW9uWGhyVHlwZShcbiAgICAgIFwiY3ViZW1hcFwiLCBQSVhJLkxvYWRlclJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT04pXG4gIH1cbn1cblxuUElYSS5Mb2FkZXIucmVnaXN0ZXJQbHVnaW4oQ3ViZW1hcExvYWRlcikiLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgZ2xURkFzc2V0IH0gZnJvbSBcIi4uL2dsdGYvZ2x0Zi1hc3NldFwiXG5cbmV4cG9ydCBjb25zdCBnbFRGQmluYXJ5TG9hZGVyID0ge1xuICB1c2U6IGZ1bmN0aW9uIChyZXNvdXJjZTogUElYSS5JTG9hZGVyUmVzb3VyY2UsIG5leHQ6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAocmVzb3VyY2UuZXh0ZW5zaW9uICE9PSBcImdsYlwiKSB7XG4gICAgICByZXR1cm4gbmV4dCgpXG4gICAgfVxuICAgIGlmIChnbFRGQXNzZXQuaXNWYWxpZChyZXNvdXJjZS5kYXRhKSkge1xuICAgICAgZ2xURkFzc2V0LmZyb21CdWZmZXIocmVzb3VyY2UuZGF0YSwgKGdsdGYpID0+IHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXNvdXJjZSwgeyBnbHRmIH0pXG4gICAgICB9KVxuICAgIH1cbiAgICBuZXh0KClcbiAgfSxcbiAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgUElYSS5Mb2FkZXJSZXNvdXJjZS5zZXRFeHRlbnNpb25YaHJUeXBlKFxuICAgICAgXCJnbGJcIiwgUElYSS5Mb2FkZXJSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CVUZGRVIpXG4gIH1cbn1cblxuUElYSS5Mb2FkZXIucmVnaXN0ZXJQbHVnaW4oZ2xURkJpbmFyeUxvYWRlcikiLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgZ2xURkFzc2V0LCBnbFRGQXNzZXRSZXNvdXJjZUxvYWRlciB9IGZyb20gXCIuLi9nbHRmL2dsdGYtYXNzZXRcIlxuXG5leHBvcnQgY29uc3QgZ2xURkxvYWRlciA9IHtcbiAgdXNlOiBmdW5jdGlvbiAocmVzb3VyY2U6IFBJWEkuSUxvYWRlclJlc291cmNlLCBuZXh0OiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHJlc291cmNlLmV4dGVuc2lvbiAhPT0gXCJnbHRmXCIpIHtcbiAgICAgIHJldHVybiBuZXh0KClcbiAgICB9XG4gICAgbGV0IGxvYWRlciA9IDxQSVhJLkxvYWRlcj48dW5rbm93bj50aGlzXG4gICAgT2JqZWN0LmFzc2lnbihyZXNvdXJjZSwge1xuICAgICAgZ2x0ZjogZ2xURkFzc2V0LmxvYWQocmVzb3VyY2UuZGF0YSwgbmV3IGdsVEZFeHRlcm5hbFJlc291cmNlTG9hZGVyKGxvYWRlciwgcmVzb3VyY2UpKVxuICAgIH0pXG4gICAgbmV4dCgpXG4gIH0sXG4gIGFkZDogZnVuY3Rpb24gKCkge1xuICAgIFBJWEkuTG9hZGVyUmVzb3VyY2Uuc2V0RXh0ZW5zaW9uWGhyVHlwZShcbiAgICAgIFwiYmluXCIsIFBJWEkuTG9hZGVyUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSKVxuICAgIFBJWEkuTG9hZGVyUmVzb3VyY2Uuc2V0RXh0ZW5zaW9uWGhyVHlwZShcbiAgICAgIFwiZ2x0ZlwiLCBQSVhJLkxvYWRlclJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT04pXG4gIH1cbn1cblxuUElYSS5Mb2FkZXIucmVnaXN0ZXJQbHVnaW4oZ2xURkxvYWRlcilcblxuY2xhc3MgZ2xURkV4dGVybmFsUmVzb3VyY2VMb2FkZXIgaW1wbGVtZW50cyBnbFRGQXNzZXRSZXNvdXJjZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xvYWRlcjogUElYSS5Mb2FkZXIsIHByaXZhdGUgX3Jlc291cmNlOiBQSVhJLklMb2FkZXJSZXNvdXJjZSkge1xuICB9XG5cbiAgbG9hZCh1cmk6IHN0cmluZywgb25Db21wbGV0ZTogKHJlc291cmNlOiBQSVhJLklMb2FkZXJSZXNvdXJjZSkgPT4gdm9pZCkge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuX3Jlc291cmNlLnVybC5zdWJzdHJpbmcoXG4gICAgICAwLCB0aGlzLl9yZXNvdXJjZS51cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyB1cmlcblxuICAgIGlmICghdGhpcy5fbG9hZGVyLnJlc291cmNlc1t1cmxdKSB7XG4gICAgICAvLyBUaGUgcmVzb3VyY2UgZG9lcyBub3QgZXhpc3RzIGFuZCBuZWVkcyB0byBiZSBsb2FkZWQuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLl9sb2FkZXIuYWRkKHsgcGFyZW50UmVzb3VyY2U6IHRoaXMuX3Jlc291cmNlLCB1cmwsIG9uQ29tcGxldGUgfSlcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2xvYWRlci5yZXNvdXJjZXNbdXJsXS5kYXRhKSB7XG4gICAgICAvLyBUaGUgcmVzb3VyY2UgYWxyZWFkeSBleGlzdHMsIGp1c3QgdXNlIHRoYXQgb25lLlxuICAgICAgb25Db21wbGV0ZSh0aGlzLl9sb2FkZXIucmVzb3VyY2VzW3VybF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXNvdXJjZSBpcyBpbiBxdWV1ZSB0byBiZSBsb2FkZWQsIHdhaXQgZm9yIGl0LlxuICAgICAgbGV0IGJpbmRpbmcgPSB0aGlzLl9sb2FkZXIub25Qcm9ncmVzcy5hZGQoKGw6IGFueSwgcmVzb3VyY2U6IFBJWEkuSUxvYWRlclJlc291cmNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNvdXJjZS51cmwgPT09IHVybCkge1xuICAgICAgICAgIG9uQ29tcGxldGUocmVzb3VyY2UpOyBiaW5kaW5nLmRldGFjaCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmNvbnN0IEVYVEVOU0lPTlMgPSBbXCJnbHNsXCIsIFwidmVydFwiLCBcImZyYWdcIl1cblxuZXhwb3J0IGNvbnN0IFNoYWRlclNvdXJjZUxvYWRlciA9IHtcbiAgdXNlOiAocmVzb3VyY2U6IGFueSwgbmV4dDogKCkgPT4gdm9pZCkgPT4ge1xuICAgIGlmICghRVhURU5TSU9OUy5pbmNsdWRlcyhyZXNvdXJjZS5leHRlbnNpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dCgpXG4gICAgfVxuICAgIG5leHQoKVxuICB9LFxuICBhZGQ6ICgpID0+IHtcbiAgICBmb3IgKGxldCBleHQgb2YgRVhURU5TSU9OUykge1xuICAgICAgUElYSS5Mb2FkZXJSZXNvdXJjZS5zZXRFeHRlbnNpb25YaHJUeXBlKFxuICAgICAgICBleHQsIFBJWEkuTG9hZGVyUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVClcbiAgICB9XG4gIH1cbn1cblxuUElYSS5Mb2FkZXIucmVnaXN0ZXJQbHVnaW4oU2hhZGVyU291cmNlTG9hZGVyKSIsImV4cG9ydCBlbnVtIE1hdGVyaWFsUmVuZGVyU29ydFR5cGUge1xuICBvcGFxdWUgPSBcIm9wYXF1ZVwiLFxuICB0cmFuc3BhcmVudCA9IFwidHJhbnNwYXJlbnRcIlxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCJcbmltcG9ydCB7IE1hdGVyaWFsUmVuZGVyU29ydFR5cGUgfSBmcm9tIFwiLi9tYXRlcmlhbC1yZW5kZXItc29ydC10eXBlXCJcbmltcG9ydCB7IE1lc2hTaGFkZXIgfSBmcm9tIFwiLi4vbWVzaC9tZXNoLXNoYWRlclwiXG5cbi8qKlxuICogTWF0ZXJpYWxzIGFyZSB1c2VkIHRvIHJlbmRlciBhIG1lc2ggd2l0aCBhIHNwZWNpZmljIHZpc3VhbCBhcHBlYXJhbmNlLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWF0ZXJpYWwge1xuICBwcm90ZWN0ZWQgX3JlbmRlclNvcnRUeXBlID0gTWF0ZXJpYWxSZW5kZXJTb3J0VHlwZS5vcGFxdWVcbiAgcHJvdGVjdGVkIF9zaGFkZXI/OiBNZXNoU2hhZGVyXG5cbiAgLyoqIFN0YXRlIHVzZWQgdG8gcmVuZGVyIGEgbWVzaC4gKi9cbiAgc3RhdGUgPSBPYmplY3QuYXNzaWduKG5ldyBQSVhJLlN0YXRlKCksIHtcbiAgICBjdWxsaW5nOiB0cnVlLCBjbG9ja3dpc2VGcm9udEZhY2U6IGZhbHNlLCBkZXB0aFRlc3Q6IHRydWVcbiAgfSlcblxuICAvKiogRHJhdyBtb2RlIHVzZWQgdG8gcmVuZGVyIGEgbWVzaC4gKi9cbiAgZHJhd01vZGUgPSBQSVhJLkRSQVdfTU9ERVMuVFJJQU5HTEVTXG5cbiAgLyoqXG4gICAqIFNvcnQgdHlwZSB1c2VkIHRvIHJlbmRlciBhIG1lc2guIFRoaXMgd2lsbCBkZXRlcm1pbmUgaW4gd2hpY2ggb3JkZXIgdGhlIFxuICAgKiBtYXRlcmlhbCBpcyBiZWluZyByZW5kZXJlZCBjb21wYXJlZCB0byBvdGhlciBtYXRlcmlhbHMuIFNldHRpbmcgdGhpcyB0byBcbiAgICogXCJ0cmFuc3BhcmVudFwiIHdpbGwgYWxzbyBkaXNhYmxlIHdyaXRpbmcgdG8gZGVwdGggYnVmZmVyIChvbmx5IGF2YWlsYWJsZSBcbiAgICogaW4gUGl4aUpTIDYuMCspLlxuICAgKi9cbiAgZ2V0IHJlbmRlclNvcnRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJTb3J0VHlwZVxuICB9XG5cbiAgc2V0IHJlbmRlclNvcnRUeXBlKHZhbHVlOiBNYXRlcmlhbFJlbmRlclNvcnRUeXBlKSB7XG4gICAgdGhpcy5fcmVuZGVyU29ydFR5cGUgPSB2YWx1ZVxuICAgIC8vIERlcHRoIG1hc2sgZmVhdHVyZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBQaXhpSlMgNi4wKyBhbmQgd29uJ3QgaGF2ZVxuICAgIC8vIGFueSBlZmZlY3RzIGluIHByZXZpb3VzIHZlcnNpb25zLlxuICAgIGlmICh2YWx1ZSA9PT0gTWF0ZXJpYWxSZW5kZXJTb3J0VHlwZS5vcGFxdWUpIHtcbiAgICAgIHRoaXMuc3RhdGUuZGVwdGhNYXNrID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmRlcHRoTWFzayA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqIFZhbHVlIGluZGljYXRpbmcgaWYgdGhlIG1hdGVyaWFsIGlzIGRvdWJsZSBzaWRlZC4gKi9cbiAgZ2V0IGRvdWJsZVNpZGVkKCkge1xuICAgIHJldHVybiAhdGhpcy5zdGF0ZS5jdWxsaW5nXG4gIH1cblxuICBzZXQgZG91YmxlU2lkZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnN0YXRlLmN1bGxpbmcgPSAhdmFsdWVcbiAgfVxuXG4gIC8qKiBCbGVuZCBtb2RlIHVzZWQgdG8gcmVuZGVyIGEgbWVzaC4gKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGVcbiAgfVxuXG4gIHNldCBibGVuZE1vZGUodmFsdWU6IFBJWEkuQkxFTkRfTU9ERVMpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNoYWRlciB1c2VkIHRvIHJlbmRlciB0aGUgc3BlY2lmaWVkIG1lc2guXG4gICAqIEBwYXJhbSBtZXNoIFRoZSBtZXNoIHRvIGNyZWF0ZSB0aGUgc2hhZGVyIGZvci5cbiAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UuXG4gICAqL1xuICBhYnN0cmFjdCBjcmVhdGVTaGFkZXIobWVzaDogTWVzaDNELCByZW5kZXJlcjogUElYSS5SZW5kZXJlcik6IE1lc2hTaGFkZXIgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdW5pZm9ybXMgZm9yIHRoZSBzcGVjaWZpZWQgc2hhZGVyLlxuICAgKiBAcGFyYW0gbWVzaCBUaGUgbWVzaCB1c2VkIGZvciB1cGRhdGluZyB0aGUgdW5pZm9ybXMuXG4gICAqIEBwYXJhbSBzaGFkZXIgVGhlIHNoYWRlciB0byB1cGRhdGUuXG4gICAqL1xuICBhYnN0cmFjdCB1cGRhdGVVbmlmb3Jtcz8obWVzaDogTWVzaDNELCBzaGFkZXI6IE1lc2hTaGFkZXIpOiB2b2lkXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBtYXRlcmlhbCBhbmQgaXQncyB1c2VkIHJlc291cmNlcy5cbiAgICovXG4gIGRlc3Ryb3koKSB7IH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgaWYgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBpbnN0YW5jaW5nLlxuICAgKi9cbiAgZ2V0IGlzSW5zdGFuY2luZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlZCB2ZXJzaW9uIG9mIHRoaXMgbWF0ZXJpYWwuXG4gICAqL1xuICBjcmVhdGVJbnN0YW5jZSgpOiB1bmtub3duIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc3BlY2lmaWVkIG1lc2guXG4gICAqIEBwYXJhbSBtZXNoIFRoZSBtZXNoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UuXG4gICAqL1xuICByZW5kZXIobWVzaDogTWVzaDNELCByZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIGlmICghdGhpcy5fc2hhZGVyKSB7XG4gICAgICB0aGlzLl9zaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcihtZXNoLCByZW5kZXJlcilcbiAgICAgIGlmICghdGhpcy5fc2hhZGVyKSB7XG4gICAgICAgIC8vIFRoZSBzaGFkZXIgY291bGRuJ3QgYmUgY3JlYXRlZCBmb3Igc29tZSByZWFzb24uIEp1c3QgaWdub3JlIGl0IGFuZCBcbiAgICAgICAgLy8gdHJ5IGFnYWluIGF0IG5leHQgcmVuZGVyLiBUaGUgcmVxdWlyZWQgYXNzZXRzIG1heSBub3QgaGF2ZSBiZWVuIGxvYWRlZCBcbiAgICAgICAgLy8geWV0LCBzbyBtYXliZSB3ZSBhcmUgd2FpdGluZyBmb3IgdGhvc2UuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy51cGRhdGVVbmlmb3Jtcykge1xuICAgICAgdGhpcy51cGRhdGVVbmlmb3JtcyhtZXNoLCB0aGlzLl9zaGFkZXIpXG4gICAgfVxuICAgIHRoaXMuX3NoYWRlci5yZW5kZXIobWVzaCwgcmVuZGVyZXIsIHRoaXMuc3RhdGUsIHRoaXMuZHJhd01vZGUpXG4gIH1cbn0iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuLi8uLi9jb2xvclwiXG5pbXBvcnQgeyBTdGFuZGFyZE1hdGVyaWFsIH0gZnJvbSBcIi4vc3RhbmRhcmQtbWF0ZXJpYWxcIlxuXG5leHBvcnQgY2xhc3MgSW5zdGFuY2VkU3RhbmRhcmRNYXRlcmlhbCB7XG4gIGJhc2VDb2xvcjogQ29sb3JcblxuICBjb25zdHJ1Y3RvcihtYXRlcmlhbDogU3RhbmRhcmRNYXRlcmlhbCkge1xuICAgIHRoaXMuYmFzZUNvbG9yID0gbmV3IENvbG9yKC4uLm1hdGVyaWFsLmJhc2VDb2xvci5yZ2JhKVxuICB9XG59IiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIFZFUlNJT05cXG5cXG4vL1xcbi8vIFRoaXMgZnJhZ21lbnQgc2hhZGVyIGRlZmluZXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gZm9yIFBoeXNpY2FsbHkgQmFzZWQgU2hhZGluZyBvZlxcbi8vIGEgbWljcm9mYWNldCBzdXJmYWNlIG1hdGVyaWFsIGRlZmluZWQgYnkgYSBnbFRGIG1vZGVsLlxcbi8vXFxuLy8gUmVmZXJlbmNlczpcXG4vLyBbMV0gUmVhbCBTaGFkaW5nIGluIFVucmVhbCBFbmdpbmUgNFxcbi8vICAgICBodHRwOi8vYmxvZy5zZWxmc2hhZG93LmNvbS9wdWJsaWNhdGlvbnMvczIwMTMtc2hhZGluZy1jb3Vyc2Uva2FyaXMvczIwMTNfcGJzX2VwaWNfbm90ZXNfdjIucGRmXFxuLy8gWzJdIFBoeXNpY2FsbHkgQmFzZWQgU2hhZGluZyBhdCBEaXNuZXlcXG4vLyAgICAgaHR0cDovL2Jsb2cuc2VsZnNoYWRvdy5jb20vcHVibGljYXRpb25zL3MyMDEyLXNoYWRpbmctY291cnNlL2J1cmxleS9zMjAxMl9wYnNfZGlzbmV5X2JyZGZfbm90ZXNfdjMucGRmXFxuLy8gWzNdIFJFQURNRS5tZCAtIEVudmlyb25tZW50IE1hcHNcXG4vLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGLVdlYkdMLVBCUi8jZW52aXJvbm1lbnQtbWFwc1xcbi8vIFs0XSBcXFwiQW4gSW5leHBlbnNpdmUgQlJERiBNb2RlbCBmb3IgUGh5c2ljYWxseSBiYXNlZCBSZW5kZXJpbmdcXFwiIGJ5IENocmlzdG9waGUgU2NobGlja1xcbi8vICAgICBodHRwczovL3d3dy5jcy52aXJnaW5pYS5lZHUvfmpkbC9iaWIvYXBwZWFyYW5jZS9hbmFseXRpYyUyMG1vZGVscy9zY2hsaWNrOTRiLnBkZlxcblxcbiNkZWZpbmUgRkVBVFVSRVNcXG5cXG4jaWYgZGVmaW5lZChXRUJHTDEpIC8vJiYgZGVmaW5lZChVU0VfVEVYX0xPRClcXG4jZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZChXRUJHTDEpXFxuI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZChXRUJHTDEpICYmIGRlZmluZWQoVVNFX0hEUilcXG4jZXh0ZW5zaW9uIEdMX09FU190ZXh0dXJlX2Zsb2F0IDogZW5hYmxlXFxuI2V4dGVuc2lvbiBHTF9PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgOiBlbmFibGVcXG4jZW5kaWZcXG5cXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmVjNCBfdGV4dHVyZShzYW1wbGVyMkQgc2FtcGxlciwgdmVjMiBjb29yZClcXG57XFxuI2lmZGVmIFdFQkdMMlxcbiAgICByZXR1cm4gdGV4dHVyZShzYW1wbGVyLCBjb29yZCk7XFxuI2Vsc2VcXG4gICAgcmV0dXJuIHRleHR1cmUyRChzYW1wbGVyLCBjb29yZCk7XFxuI2VuZGlmXFxufVxcblxcbnZlYzQgX3RleHR1cmUoc2FtcGxlckN1YmUgc2FtcGxlciwgdmVjMyBjb29yZClcXG57XFxuI2lmZGVmIFdFQkdMMlxcbiAgICByZXR1cm4gdGV4dHVyZShzYW1wbGVyLCBjb29yZCk7XFxuI2Vsc2VcXG4gICAgcmV0dXJuIHRleHR1cmVDdWJlKHNhbXBsZXIsIGNvb3JkKTtcXG4jZW5kaWZcXG59XFxudmVjNCBfdGV4dHVyZUxvZChzYW1wbGVyMkQgc2FtcGxlciwgdmVjMiBjb29yZCwgZmxvYXQgbG9kKVxcbntcXG4jaWZkZWYgV0VCR0wyXFxuICAgIHJldHVybiB0ZXh0dXJlTG9kKHNhbXBsZXIsIGNvb3JkLCBsb2QpO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKFdFQkdMMSkgJiYgZGVmaW5lZChHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kKSBcXG4gICAgcmV0dXJuIHRleHR1cmUyRExvZEVYVChzYW1wbGVyLCBjb29yZCwgbG9kKTtcXG4jZW5kaWZcXG4gICAgcmV0dXJuIHZlYzQoMC4wKTtcXG59XFxuXFxudmVjNCBfdGV4dHVyZUxvZChzYW1wbGVyQ3ViZSBzYW1wbGVyLCB2ZWMzIGNvb3JkLCBmbG9hdCBsb2QpXFxue1xcbiNpZmRlZiBXRUJHTDJcXG4gICAgcmV0dXJuIHRleHR1cmVMb2Qoc2FtcGxlciwgY29vcmQsIGxvZCk7XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoV0VCR0wxKSAmJiBkZWZpbmVkKEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QpIFxcbiAgICByZXR1cm4gdGV4dHVyZUN1YmVMb2RFWFQoc2FtcGxlciwgY29vcmQsIGxvZCk7XFxuI2VuZGlmXFxuICAgIHJldHVybiB2ZWM0KDAuMCk7XFxufVxcbnZlYzMgX2RGZHgodmVjMyBjb29yZClcXG57XFxuI2lmIGRlZmluZWQoV0VCR0wyKSB8fCBkZWZpbmVkKEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcylcXG4gICAgcmV0dXJuIGRGZHgoY29vcmQpO1xcbiNlbmRpZlxcbiAgICByZXR1cm4gdmVjMygwLjApO1xcbn1cXG5cXG52ZWMzIF9kRmR5KHZlYzMgY29vcmQpXFxue1xcbiNpZiBkZWZpbmVkKFdFQkdMMikgfHwgZGVmaW5lZChHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpXFxuICAgIHJldHVybiBkRmR5KGNvb3JkKTtcXG4jZW5kaWZcXG4gICAgcmV0dXJuIHZlYzMoMC4wKTtcXG59XFxuRlJBR19JTiB2ZWMyIHZfVVZDb29yZDE7XFxuRlJBR19JTiB2ZWMyIHZfVVZDb29yZDI7XFxuXFxuLy8gR2VuZXJhbCBNYXRlcmlhbFxcbiNpZmRlZiBIQVNfTk9STUFMX01BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfTm9ybWFsU2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IHVfTm9ybWFsU2NhbGU7XFxudW5pZm9ybSBpbnQgdV9Ob3JtYWxVVlNldDtcXG51bmlmb3JtIG1hdDMgdV9Ob3JtYWxVVlRyYW5zZm9ybTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX0VNSVNTSVZFX01BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfRW1pc3NpdmVTYW1wbGVyO1xcbnVuaWZvcm0gaW50IHVfRW1pc3NpdmVVVlNldDtcXG51bmlmb3JtIHZlYzMgdV9FbWlzc2l2ZUZhY3RvcjtcXG51bmlmb3JtIG1hdDMgdV9FbWlzc2l2ZVVWVHJhbnNmb3JtO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfT0NDTFVTSU9OX01BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfT2NjbHVzaW9uU2FtcGxlcjtcXG51bmlmb3JtIGludCB1X09jY2x1c2lvblVWU2V0O1xcbnVuaWZvcm0gZmxvYXQgdV9PY2NsdXNpb25TdHJlbmd0aDtcXG51bmlmb3JtIG1hdDMgdV9PY2NsdXNpb25VVlRyYW5zZm9ybTtcXG4jZW5kaWZcXG5cXG4vLyBNZXRhbGxpYyBSb3VnaG5lc3MgTWF0ZXJpYWxcXG4jaWZkZWYgSEFTX0JBU0VfQ09MT1JfTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9CYXNlQ29sb3JTYW1wbGVyO1xcbnVuaWZvcm0gaW50IHVfQmFzZUNvbG9yVVZTZXQ7XFxudW5pZm9ybSBtYXQzIHVfQmFzZUNvbG9yVVZUcmFuc2Zvcm07XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19NRVRBTExJQ19ST1VHSE5FU1NfTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9NZXRhbGxpY1JvdWdobmVzc1NhbXBsZXI7XFxudW5pZm9ybSBpbnQgdV9NZXRhbGxpY1JvdWdobmVzc1VWU2V0O1xcbnVuaWZvcm0gbWF0MyB1X01ldGFsbGljUm91Z2huZXNzVVZUcmFuc2Zvcm07XFxuI2VuZGlmXFxuXFxuLy8gU3BlY3VsYXIgR2xvc3NpbmVzcyBNYXRlcmlhbFxcbiNpZmRlZiBIQVNfRElGRlVTRV9NQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1X0RpZmZ1c2VTYW1wbGVyO1xcbnVuaWZvcm0gaW50IHVfRGlmZnVzZVVWU2V0O1xcbnVuaWZvcm0gbWF0MyB1X0RpZmZ1c2VVVlRyYW5zZm9ybTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1NQRUNVTEFSX0dMT1NTSU5FU1NfTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9TcGVjdWxhckdsb3NzaW5lc3NTYW1wbGVyO1xcbnVuaWZvcm0gaW50IHVfU3BlY3VsYXJHbG9zc2luZXNzVVZTZXQ7XFxudW5pZm9ybSBtYXQzIHVfU3BlY3VsYXJHbG9zc2luZXNzVVZUcmFuc2Zvcm07XFxuI2VuZGlmXFxuXFxuLy8gSUJMXFxuI2lmZGVmIFVTRV9JQkxcXG51bmlmb3JtIHNhbXBsZXJDdWJlIHVfRGlmZnVzZUVudlNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyQ3ViZSB1X1NwZWN1bGFyRW52U2FtcGxlcjtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2JyZGZMVVQ7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9TSEFET1dfTUFQUElOR1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfU2hhZG93U2FtcGxlcjtcXG4jZW5kaWZcXG5cXG52ZWMyIGdldE5vcm1hbFVWKClcXG57XFxuICAgIHZlYzMgdXYgPSB2ZWMzKHZfVVZDb29yZDEsIDEuMCk7XFxuI2lmZGVmIEhBU19OT1JNQUxfTUFQXFxuICAgIHV2Lnh5ID0gdV9Ob3JtYWxVVlNldCA8IDEgPyB2X1VWQ29vcmQxIDogdl9VVkNvb3JkMjtcXG4gICAgI2lmZGVmIEhBU19OT1JNQUxfVVZfVFJBTlNGT1JNXFxuICAgIHV2ICo9IHVfTm9ybWFsVVZUcmFuc2Zvcm07XFxuICAgICNlbmRpZlxcbiNlbmRpZlxcbiAgICByZXR1cm4gdXYueHk7XFxufVxcblxcbnZlYzIgZ2V0RW1pc3NpdmVVVigpXFxue1xcbiAgICB2ZWMzIHV2ID0gdmVjMyh2X1VWQ29vcmQxLCAxLjApO1xcbiNpZmRlZiBIQVNfRU1JU1NJVkVfTUFQXFxuICAgIHV2Lnh5ID0gdV9FbWlzc2l2ZVVWU2V0IDwgMSA/IHZfVVZDb29yZDEgOiB2X1VWQ29vcmQyO1xcbiAgICAjaWZkZWYgSEFTX0VNSVNTSVZFX1VWX1RSQU5TRk9STVxcbiAgICB1diAqPSB1X0VtaXNzaXZlVVZUcmFuc2Zvcm07XFxuICAgICNlbmRpZlxcbiNlbmRpZlxcblxcbiAgICByZXR1cm4gdXYueHk7XFxufVxcblxcbnZlYzIgZ2V0T2NjbHVzaW9uVVYoKVxcbntcXG4gICAgdmVjMyB1diA9IHZlYzModl9VVkNvb3JkMSwgMS4wKTtcXG4jaWZkZWYgSEFTX09DQ0xVU0lPTl9NQVBcXG4gICAgdXYueHkgPSB1X09jY2x1c2lvblVWU2V0IDwgMSA/IHZfVVZDb29yZDEgOiB2X1VWQ29vcmQyO1xcbiAgICAjaWZkZWYgSEFTX09DQ0xVU0lPTl9VVl9UUkFOU0ZPUk1cXG4gICAgdXYgKj0gdV9PY2NsdXNpb25VVlRyYW5zZm9ybTtcXG4gICAgI2VuZGlmXFxuI2VuZGlmXFxuICAgIHJldHVybiB1di54eTtcXG59XFxuXFxudmVjMiBnZXRCYXNlQ29sb3JVVigpXFxue1xcbiAgICB2ZWMzIHV2ID0gdmVjMyh2X1VWQ29vcmQxLCAxLjApO1xcbiNpZmRlZiBIQVNfQkFTRV9DT0xPUl9NQVBcXG4gICAgdXYueHkgPSB1X0Jhc2VDb2xvclVWU2V0IDwgMSA/IHZfVVZDb29yZDEgOiB2X1VWQ29vcmQyO1xcbiAgICAjaWZkZWYgSEFTX0JBU0VDT0xPUl9VVl9UUkFOU0ZPUk1cXG4gICAgdXYgKj0gdV9CYXNlQ29sb3JVVlRyYW5zZm9ybTtcXG4gICAgI2VuZGlmXFxuI2VuZGlmXFxuICAgIHJldHVybiB1di54eTtcXG59XFxuXFxudmVjMiBnZXRNZXRhbGxpY1JvdWdobmVzc1VWKClcXG57XFxuICAgIHZlYzMgdXYgPSB2ZWMzKHZfVVZDb29yZDEsIDEuMCk7XFxuI2lmZGVmIEhBU19NRVRBTExJQ19ST1VHSE5FU1NfTUFQXFxuICAgIHV2Lnh5ID0gdV9NZXRhbGxpY1JvdWdobmVzc1VWU2V0IDwgMSA/IHZfVVZDb29yZDEgOiB2X1VWQ29vcmQyO1xcbiAgICAjaWZkZWYgSEFTX01FVEFMTElDUk9VR0hORVNTX1VWX1RSQU5TRk9STVxcbiAgICB1diAqPSB1X01ldGFsbGljUm91Z2huZXNzVVZUcmFuc2Zvcm07XFxuICAgICNlbmRpZlxcbiNlbmRpZlxcbiAgICByZXR1cm4gdXYueHk7XFxufVxcblxcbnZlYzIgZ2V0U3BlY3VsYXJHbG9zc2luZXNzVVYoKVxcbntcXG4gICAgdmVjMyB1diA9IHZlYzModl9VVkNvb3JkMSwgMS4wKTtcXG4jaWZkZWYgSEFTX1NQRUNVTEFSX0dMT1NTSU5FU1NfTUFQXFxuICAgIHV2Lnh5ID0gdV9TcGVjdWxhckdsb3NzaW5lc3NVVlNldCA8IDEgPyB2X1VWQ29vcmQxIDogdl9VVkNvb3JkMjtcXG4gICAgI2lmZGVmIEhBU19TUEVDVUxBUkdMT1NTSU5FU1NfVVZfVFJBTlNGT1JNXFxuICAgIHV2ICo9IHVfU3BlY3VsYXJHbG9zc2luZXNzVVZUcmFuc2Zvcm07XFxuICAgICNlbmRpZlxcbiNlbmRpZlxcbiAgICByZXR1cm4gdXYueHk7XFxufVxcblxcbnZlYzIgZ2V0RGlmZnVzZVVWKClcXG57XFxuICAgIHZlYzMgdXYgPSB2ZWMzKHZfVVZDb29yZDEsIDEuMCk7XFxuI2lmZGVmIEhBU19ESUZGVVNFX01BUFxcbiAgICB1di54eSA9IHVfRGlmZnVzZVVWU2V0IDwgMSA/IHZfVVZDb29yZDEgOiB2X1VWQ29vcmQyO1xcbiAgICAjaWZkZWYgSEFTX0RJRkZVU0VfVVZfVFJBTlNGT1JNXFxuICAgIHV2ICo9IHVfRGlmZnVzZVVWVHJhbnNmb3JtO1xcbiAgICAjZW5kaWZcXG4jZW5kaWZcXG4gICAgcmV0dXJuIHV2Lnh5O1xcbn1cXG5cXG4vLyB0ZXh0dXJlcy5nbHNsIG5lZWRzIHRvIGJlIGluY2x1ZGVkXFxuXFxuY29uc3QgZmxvYXQgTV9QSSA9IDMuMTQxNTkyNjUzNTg5NzkzO1xcbmNvbnN0IGZsb2F0IGNfTWluUmVmbGVjdGFuY2UgPSAwLjA0O1xcblxcbkZSQUdfSU4gdmVjMyB2X1Bvc2l0aW9uO1xcblxcbiNpZmRlZiBIQVNfTk9STUFMU1xcbiNpZmRlZiBIQVNfVEFOR0VOVFNcXG5GUkFHX0lOIG1hdDMgdl9UQk47XFxuI2Vsc2VcXG5GUkFHX0lOIHZlYzMgdl9Ob3JtYWw7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19WRVJURVhfQ09MT1JfVkVDM1xcbkZSQUdfSU4gdmVjMyB2X0NvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBIQVNfVkVSVEVYX0NPTE9SX1ZFQzRcXG5GUkFHX0lOIHZlYzQgdl9Db2xvcjtcXG4jZW5kaWZcXG5cXG5zdHJ1Y3QgQW5ndWxhckluZm9cXG57XFxuICAgIGZsb2F0IE5kb3RMOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIG5vcm1hbCBhbmQgbGlnaHQgZGlyZWN0aW9uXFxuICAgIGZsb2F0IE5kb3RWOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIG5vcm1hbCBhbmQgdmlldyBkaXJlY3Rpb25cXG4gICAgZmxvYXQgTmRvdEg7ICAgICAgICAgICAgICAgICAgLy8gY29zIGFuZ2xlIGJldHdlZW4gbm9ybWFsIGFuZCBoYWxmIHZlY3RvclxcbiAgICBmbG9hdCBMZG90SDsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiBsaWdodCBkaXJlY3Rpb24gYW5kIGhhbGYgdmVjdG9yXFxuXFxuICAgIGZsb2F0IFZkb3RIOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIHZpZXcgZGlyZWN0aW9uIGFuZCBoYWxmIHZlY3RvclxcblxcbiAgICB2ZWMzIHBhZGRpbmc7XFxufTtcXG5cXG52ZWM0IGdldFZlcnRleENvbG9yKClcXG57XFxuICAgdmVjNCBjb2xvciA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4jaWZkZWYgSEFTX1ZFUlRFWF9DT0xPUl9WRUMzXFxuICAgIGNvbG9yLnJnYiA9IHZfQ29sb3I7XFxuI2VuZGlmXFxuI2lmZGVmIEhBU19WRVJURVhfQ09MT1JfVkVDNFxcbiAgICBjb2xvciA9IHZfQ29sb3I7XFxuI2VuZGlmXFxuXFxuICAgcmV0dXJuIGNvbG9yO1xcbn1cXG5cXG4vLyBGaW5kIHRoZSBub3JtYWwgZm9yIHRoaXMgZnJhZ21lbnQsIHB1bGxpbmcgZWl0aGVyIGZyb20gYSBwcmVkZWZpbmVkIG5vcm1hbCBtYXBcXG4vLyBvciBmcm9tIHRoZSBpbnRlcnBvbGF0ZWQgbWVzaCBub3JtYWwgYW5kIHRhbmdlbnQgYXR0cmlidXRlcy5cXG52ZWMzIGdldE5vcm1hbCgpXFxue1xcbiAgICB2ZWMyIFVWID0gZ2V0Tm9ybWFsVVYoKTtcXG5cXG4gICAgLy8gUmV0cmlldmUgdGhlIHRhbmdlbnQgc3BhY2UgbWF0cml4XFxuI2lmbmRlZiBIQVNfVEFOR0VOVFNcXG4gICAgdmVjMyBwb3NfZHggPSBfZEZkeCh2X1Bvc2l0aW9uKTtcXG4gICAgdmVjMyBwb3NfZHkgPSBfZEZkeSh2X1Bvc2l0aW9uKTtcXG4gICAgdmVjMyB0ZXhfZHggPSBfZEZkeCh2ZWMzKFVWLCAwLjApKTtcXG4gICAgdmVjMyB0ZXhfZHkgPSBfZEZkeSh2ZWMzKFVWLCAwLjApKTtcXG4gICAgdmVjMyB0ID0gKHRleF9keS50ICogcG9zX2R4IC0gdGV4X2R4LnQgKiBwb3NfZHkpIC8gKHRleF9keC5zICogdGV4X2R5LnQgLSB0ZXhfZHkucyAqIHRleF9keC50KTtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTFNcXG4gICAgdmVjMyBuZyA9IG5vcm1hbGl6ZSh2X05vcm1hbCk7XFxuI2Vsc2VcXG4gICAgdmVjMyBuZyA9IGNyb3NzKHBvc19keCwgcG9zX2R5KTtcXG4jZW5kaWZcXG5cXG4gICAgdCA9IG5vcm1hbGl6ZSh0IC0gbmcgKiBkb3QobmcsIHQpKTtcXG4gICAgdmVjMyBiID0gbm9ybWFsaXplKGNyb3NzKG5nLCB0KSk7XFxuICAgIG1hdDMgdGJuID0gbWF0Myh0LCBiLCBuZyk7XFxuI2Vsc2UgLy8gSEFTX1RBTkdFTlRTXFxuICAgIG1hdDMgdGJuID0gdl9UQk47XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19OT1JNQUxfTUFQXFxuICAgIHZlYzMgbiA9IF90ZXh0dXJlKHVfTm9ybWFsU2FtcGxlciwgVVYpLnJnYjtcXG4gICAgbiA9IG5vcm1hbGl6ZSh0Ym4gKiAoKDIuMCAqIG4gLSAxLjApICogdmVjMyh1X05vcm1hbFNjYWxlLCB1X05vcm1hbFNjYWxlLCAxLjApKSk7XFxuI2Vsc2VcXG4gICAgLy8gVGhlIHRibiBtYXRyaXggaXMgbGluZWFybHkgaW50ZXJwb2xhdGVkLCBzbyB3ZSBuZWVkIHRvIHJlLW5vcm1hbGl6ZVxcbiAgICB2ZWMzIG4gPSBub3JtYWxpemUodGJuWzJdLnh5eik7XFxuI2VuZGlmXFxuXFxuICAgIHJldHVybiBuO1xcbn1cXG5cXG5mbG9hdCBnZXRQZXJjZWl2ZWRCcmlnaHRuZXNzKHZlYzMgdmVjdG9yKVxcbntcXG4gICAgcmV0dXJuIHNxcnQoMC4yOTkgKiB2ZWN0b3IuciAqIHZlY3Rvci5yICsgMC41ODcgKiB2ZWN0b3IuZyAqIHZlY3Rvci5nICsgMC4xMTQgKiB2ZWN0b3IuYiAqIHZlY3Rvci5iKTtcXG59XFxuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19wYnJTcGVjdWxhckdsb3NzaW5lc3MvZXhhbXBsZXMvY29udmVydC1iZXR3ZWVuLXdvcmtmbG93cy9qcy90aHJlZS5wYnJVdGlsaXRpZXMuanMjTDM0XFxuZmxvYXQgc29sdmVNZXRhbGxpYyh2ZWMzIGRpZmZ1c2UsIHZlYzMgc3BlY3VsYXIsIGZsb2F0IG9uZU1pbnVzU3BlY3VsYXJTdHJlbmd0aCkge1xcbiAgICBmbG9hdCBzcGVjdWxhckJyaWdodG5lc3MgPSBnZXRQZXJjZWl2ZWRCcmlnaHRuZXNzKHNwZWN1bGFyKTtcXG5cXG4gICAgaWYgKHNwZWN1bGFyQnJpZ2h0bmVzcyA8IGNfTWluUmVmbGVjdGFuY2UpIHtcXG4gICAgICAgIHJldHVybiAwLjA7XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgZGlmZnVzZUJyaWdodG5lc3MgPSBnZXRQZXJjZWl2ZWRCcmlnaHRuZXNzKGRpZmZ1c2UpO1xcblxcbiAgICBmbG9hdCBhID0gY19NaW5SZWZsZWN0YW5jZTtcXG4gICAgZmxvYXQgYiA9IGRpZmZ1c2VCcmlnaHRuZXNzICogb25lTWludXNTcGVjdWxhclN0cmVuZ3RoIC8gKDEuMCAtIGNfTWluUmVmbGVjdGFuY2UpICsgc3BlY3VsYXJCcmlnaHRuZXNzIC0gMi4wICogY19NaW5SZWZsZWN0YW5jZTtcXG4gICAgZmxvYXQgYyA9IGNfTWluUmVmbGVjdGFuY2UgLSBzcGVjdWxhckJyaWdodG5lc3M7XFxuICAgIGZsb2F0IEQgPSBiICogYiAtIDQuMCAqIGEgKiBjO1xcblxcbiAgICByZXR1cm4gY2xhbXAoKC1iICsgc3FydChEKSkgLyAoMi4wICogYSksIDAuMCwgMS4wKTtcXG59XFxuXFxuQW5ndWxhckluZm8gZ2V0QW5ndWxhckluZm8odmVjMyBwb2ludFRvTGlnaHQsIHZlYzMgbm9ybWFsLCB2ZWMzIHZpZXcpXFxue1xcbiAgICAvLyBTdGFuZGFyZCBvbmUtbGV0dGVyIG5hbWVzXFxuICAgIHZlYzMgbiA9IG5vcm1hbGl6ZShub3JtYWwpOyAgICAgICAgICAgLy8gT3V0d2FyZCBkaXJlY3Rpb24gb2Ygc3VyZmFjZSBwb2ludFxcbiAgICB2ZWMzIHYgPSBub3JtYWxpemUodmlldyk7ICAgICAgICAgICAgIC8vIERpcmVjdGlvbiBmcm9tIHN1cmZhY2UgcG9pbnQgdG8gdmlld1xcbiAgICB2ZWMzIGwgPSBub3JtYWxpemUocG9pbnRUb0xpZ2h0KTsgICAgIC8vIERpcmVjdGlvbiBmcm9tIHN1cmZhY2UgcG9pbnQgdG8gbGlnaHRcXG4gICAgdmVjMyBoID0gbm9ybWFsaXplKGwgKyB2KTsgICAgICAgICAgICAvLyBEaXJlY3Rpb24gb2YgdGhlIHZlY3RvciBiZXR3ZWVuIGwgYW5kIHZcXG5cXG4gICAgZmxvYXQgTmRvdEwgPSBjbGFtcChkb3QobiwgbCksIDAuMCwgMS4wKTtcXG4gICAgZmxvYXQgTmRvdFYgPSBjbGFtcChkb3QobiwgdiksIDAuMCwgMS4wKTtcXG4gICAgZmxvYXQgTmRvdEggPSBjbGFtcChkb3QobiwgaCksIDAuMCwgMS4wKTtcXG4gICAgZmxvYXQgTGRvdEggPSBjbGFtcChkb3QobCwgaCksIDAuMCwgMS4wKTtcXG4gICAgZmxvYXQgVmRvdEggPSBjbGFtcChkb3QodiwgaCksIDAuMCwgMS4wKTtcXG5cXG4gICAgcmV0dXJuIEFuZ3VsYXJJbmZvKFxcbiAgICAgICAgTmRvdEwsXFxuICAgICAgICBOZG90VixcXG4gICAgICAgIE5kb3RILFxcbiAgICAgICAgTGRvdEgsXFxuICAgICAgICBWZG90SCxcXG4gICAgICAgIHZlYzMoMCwgMCwgMClcXG4gICAgKTtcXG59XFxuXFxuI2lmZGVmIFVTRV9TSEFET1dfTUFQUElOR1xcbkZSQUdfSU4gdmVjNCB2X1Bvc2l0aW9uTGlnaHRTcGFjZTtcXG4jZW5kaWZcXG5cXG5mbG9hdCBsaW5zdGVwKGZsb2F0IGxvdywgZmxvYXQgaGlnaCwgZmxvYXQgdilcXG57XFxuICAgIHJldHVybiBjbGFtcCgodi1sb3cpIC8gKGhpZ2gtbG93KSwgMC4wLCAxLjApO1xcbn1cXG5cXG4jaWZkZWYgVVNFX1NIQURPV19NQVBQSU5HXFxuZmxvYXQgZ2V0U2hhZG93Q29udHJpYnV0aW9uKClcXG57XFxuICAgIHZlYzMgY29vcmRzID0gdl9Qb3NpdGlvbkxpZ2h0U3BhY2UueHl6IC8gdl9Qb3NpdGlvbkxpZ2h0U3BhY2UudyAqIDAuNSArIDAuNTtcXG4gICAgaWYgKGNvb3Jkcy56IDwgMC4wMSB8fCBjb29yZHMueiA+IDAuOTkgfHwgY29vcmRzLnggPCAwLjAxIHx8IGNvb3Jkcy54ID4gMC45OSB8fCBjb29yZHMueSA8IDAuMDEgfHwgY29vcmRzLnkgPiAwLjk5KSB7XFxuICAgICAgICByZXR1cm4gMS4wO1xcbiAgICB9XFxuICAgIHZlYzIgbW9tZW50cyA9IHZlYzIoMS4wKSAtIF90ZXh0dXJlKHVfU2hhZG93U2FtcGxlciwgY29vcmRzLnh5KS54eTtcXG4gICAgZmxvYXQgcCA9IHN0ZXAoY29vcmRzLnosIG1vbWVudHMueCk7XFxuICAgIGZsb2F0IHZhcmlhbmNlID0gbWF4KG1vbWVudHMueSAtIG1vbWVudHMueCAqIG1vbWVudHMueCwgMC4wMDAwMik7XFxuICAgIGZsb2F0IGQgPSBjb29yZHMueiAtIG1vbWVudHMueDtcXG4gICAgZmxvYXQgcE1heCA9IGxpbnN0ZXAoMC4yLCAxLjAsIHZhcmlhbmNlIC8gKHZhcmlhbmNlICsgZCpkKSk7XFxuICAgIHJldHVybiBtaW4obWF4KHAsIHBNYXgpLCAxLjApO1xcbn1cXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IHVfRXhwb3N1cmU7XFxuXFxuY29uc3QgZmxvYXQgR0FNTUEgPSAyLjI7XFxuY29uc3QgZmxvYXQgSU5WX0dBTU1BID0gMS4wIC8gR0FNTUE7XFxuXFxuLy8gbGluZWFyIHRvIHNSR0IgYXBwcm94aW1hdGlvblxcbi8vIHNlZSBodHRwOi8vY2hpbGxpYW50LmJsb2dzcG90LmNvbS8yMDEyLzA4L3NyZ2ItYXBwcm94aW1hdGlvbnMtZm9yLWhsc2wuaHRtbFxcbnZlYzMgTElORUFSdG9TUkdCKHZlYzMgY29sb3IpXFxue1xcbiAgICByZXR1cm4gcG93KGNvbG9yLCB2ZWMzKElOVl9HQU1NQSkpO1xcbn1cXG5cXG4vLyBzUkdCIHRvIGxpbmVhciBhcHByb3hpbWF0aW9uXFxuLy8gc2VlIGh0dHA6Ly9jaGlsbGlhbnQuYmxvZ3Nwb3QuY29tLzIwMTIvMDgvc3JnYi1hcHByb3hpbWF0aW9ucy1mb3ItaGxzbC5odG1sXFxudmVjNCBTUkdCdG9MSU5FQVIodmVjNCBzcmdiSW4pXFxue1xcbiAgICByZXR1cm4gdmVjNChwb3coc3JnYkluLnh5eiwgdmVjMyhHQU1NQSkpLCBzcmdiSW4udyk7XFxufVxcblxcbi8vIFVuY2hhcnRlZCAyIHRvbmUgbWFwXFxuLy8gc2VlOiBodHRwOi8vZmlsbWljd29ybGRzLmNvbS9ibG9nL2ZpbG1pYy10b25lbWFwcGluZy1vcGVyYXRvcnMvXFxudmVjMyB0b25lTWFwVW5jaGFydGVkMkltcGwodmVjMyBjb2xvcilcXG57XFxuICAgIGNvbnN0IGZsb2F0IEEgPSAwLjE1O1xcbiAgICBjb25zdCBmbG9hdCBCID0gMC41MDtcXG4gICAgY29uc3QgZmxvYXQgQyA9IDAuMTA7XFxuICAgIGNvbnN0IGZsb2F0IEQgPSAwLjIwO1xcbiAgICBjb25zdCBmbG9hdCBFID0gMC4wMjtcXG4gICAgY29uc3QgZmxvYXQgRiA9IDAuMzA7XFxuICAgIHJldHVybiAoKGNvbG9yKihBKmNvbG9yK0MqQikrRCpFKS8oY29sb3IqKEEqY29sb3IrQikrRCpGKSktRS9GO1xcbn1cXG5cXG52ZWMzIHRvbmVNYXBVbmNoYXJ0ZWQodmVjMyBjb2xvcilcXG57XFxuICAgIGNvbnN0IGZsb2F0IFcgPSAxMS4yO1xcbiAgICBjb2xvciA9IHRvbmVNYXBVbmNoYXJ0ZWQySW1wbChjb2xvciAqIDIuMCk7XFxuICAgIHZlYzMgd2hpdGVTY2FsZSA9IDEuMCAvIHRvbmVNYXBVbmNoYXJ0ZWQySW1wbCh2ZWMzKFcpKTtcXG4gICAgcmV0dXJuIExJTkVBUnRvU1JHQihjb2xvciAqIHdoaXRlU2NhbGUpO1xcbn1cXG5cXG4vLyBIZWpsIFJpY2hhcmQgdG9uZSBtYXBcXG4vLyBzZWU6IGh0dHA6Ly9maWxtaWN3b3JsZHMuY29tL2Jsb2cvZmlsbWljLXRvbmVtYXBwaW5nLW9wZXJhdG9ycy9cXG52ZWMzIHRvbmVNYXBIZWpsUmljaGFyZCh2ZWMzIGNvbG9yKVxcbntcXG4gICAgY29sb3IgPSBtYXgodmVjMygwLjApLCBjb2xvciAtIHZlYzMoMC4wMDQpKTtcXG4gICAgcmV0dXJuIChjb2xvciooNi4yKmNvbG9yKy41KSkvKGNvbG9yKig2LjIqY29sb3IrMS43KSswLjA2KTtcXG59XFxuXFxuLy8gQUNFUyB0b25lIG1hcFxcbi8vIHNlZTogaHR0cHM6Ly9rbmFya293aWN6LndvcmRwcmVzcy5jb20vMjAxNi8wMS8wNi9hY2VzLWZpbG1pYy10b25lLW1hcHBpbmctY3VydmUvXFxudmVjMyB0b25lTWFwQUNFUyh2ZWMzIGNvbG9yKVxcbntcXG4gICAgY29uc3QgZmxvYXQgQSA9IDIuNTE7XFxuICAgIGNvbnN0IGZsb2F0IEIgPSAwLjAzO1xcbiAgICBjb25zdCBmbG9hdCBDID0gMi40MztcXG4gICAgY29uc3QgZmxvYXQgRCA9IDAuNTk7XFxuICAgIGNvbnN0IGZsb2F0IEUgPSAwLjE0O1xcbiAgICByZXR1cm4gTElORUFSdG9TUkdCKGNsYW1wKChjb2xvciAqIChBICogY29sb3IgKyBCKSkgLyAoY29sb3IgKiAoQyAqIGNvbG9yICsgRCkgKyBFKSwgMC4wLCAxLjApKTtcXG59XFxuXFxudmVjMyB0b25lTWFwKHZlYzMgY29sb3IpXFxue1xcbiAgICBjb2xvciAqPSB1X0V4cG9zdXJlO1xcblxcbiNpZmRlZiBUT05FTUFQX1VOQ0hBUlRFRFxcbiAgICByZXR1cm4gdG9uZU1hcFVuY2hhcnRlZChjb2xvcik7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFRPTkVNQVBfSEVKTFJJQ0hBUkRcXG4gICAgcmV0dXJuIHRvbmVNYXBIZWpsUmljaGFyZChjb2xvcik7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFRPTkVNQVBfQUNFU1xcbiAgICByZXR1cm4gdG9uZU1hcEFDRVMoY29sb3IpO1xcbiNlbmRpZlxcblxcbiAgICByZXR1cm4gTElORUFSdG9TUkdCKGNvbG9yKTtcXG59XFxuXFxuXFxuLy8gS0hSX2xpZ2h0c19wdW5jdHVhbCBleHRlbnNpb24uXFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9saWdodHNfcHVuY3R1YWxcXG5cXG5zdHJ1Y3QgTGlnaHRcXG57XFxuICAgIHZlYzMgZGlyZWN0aW9uO1xcbiAgICBmbG9hdCByYW5nZTtcXG5cXG4gICAgdmVjMyBjb2xvcjtcXG4gICAgZmxvYXQgaW50ZW5zaXR5O1xcblxcbiAgICB2ZWMzIHBvc2l0aW9uO1xcbiAgICBmbG9hdCBpbm5lckNvbmVDb3M7XFxuXFxuICAgIGZsb2F0IG91dGVyQ29uZUNvcztcXG4gICAgaW50IHR5cGU7XFxuXFxuICAgIHZlYzIgcGFkZGluZztcXG59O1xcblxcbmNvbnN0IGludCBMaWdodFR5cGVfRGlyZWN0aW9uYWwgPSAwO1xcbmNvbnN0IGludCBMaWdodFR5cGVfUG9pbnQgPSAxO1xcbmNvbnN0IGludCBMaWdodFR5cGVfU3BvdCA9IDI7XFxuY29uc3QgaW50IExpZ2h0VHlwZV9BbWJpZW50ID0gMztcXG5cXG4jaWZkZWYgVVNFX1BVTkNUVUFMXFxudW5pZm9ybSBMaWdodCB1X0xpZ2h0c1tMSUdIVF9DT1VOVF07XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQoTUFURVJJQUxfU1BFQ1VMQVJHTE9TU0lORVNTKSB8fCBkZWZpbmVkKE1BVEVSSUFMX01FVEFMTElDUk9VR0hORVNTKVxcbnVuaWZvcm0gZmxvYXQgdV9NZXRhbGxpY0ZhY3RvcjtcXG51bmlmb3JtIGZsb2F0IHVfUm91Z2huZXNzRmFjdG9yO1xcbnVuaWZvcm0gdmVjNCB1X0Jhc2VDb2xvckZhY3RvcjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5GUkFHX0lOIHZlYzQgdl9CYXNlQ29sb3JGYWN0b3I7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIE1BVEVSSUFMX1NQRUNVTEFSR0xPU1NJTkVTU1xcbnVuaWZvcm0gdmVjMyB1X1NwZWN1bGFyRmFjdG9yO1xcbnVuaWZvcm0gdmVjNCB1X0RpZmZ1c2VGYWN0b3I7XFxudW5pZm9ybSBmbG9hdCB1X0dsb3NzaW5lc3NGYWN0b3I7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEFMUEhBTU9ERV9NQVNLXFxudW5pZm9ybSBmbG9hdCB1X0FscGhhQ3V0b2ZmO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gdmVjMyB1X0NhbWVyYTtcXG5cXG51bmlmb3JtIGludCB1X01pcENvdW50O1xcblxcbnN0cnVjdCBNYXRlcmlhbEluZm9cXG57XFxuICAgIGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3M7ICAgIC8vIHJvdWdobmVzcyB2YWx1ZSwgYXMgYXV0aG9yZWQgYnkgdGhlIG1vZGVsIGNyZWF0b3IgKGlucHV0IHRvIHNoYWRlcilcXG4gICAgdmVjMyByZWZsZWN0YW5jZTA7ICAgICAgICAgICAgLy8gZnVsbCByZWZsZWN0YW5jZSBjb2xvciAobm9ybWFsIGluY2lkZW5jZSBhbmdsZSlcXG5cXG4gICAgZmxvYXQgYWxwaGFSb3VnaG5lc3M7ICAgICAgICAgLy8gcm91Z2huZXNzIG1hcHBlZCB0byBhIG1vcmUgbGluZWFyIGNoYW5nZSBpbiB0aGUgcm91Z2huZXNzIChwcm9wb3NlZCBieSBbMl0pXFxuICAgIHZlYzMgZGlmZnVzZUNvbG9yOyAgICAgICAgICAgIC8vIGNvbG9yIGNvbnRyaWJ1dGlvbiBmcm9tIGRpZmZ1c2UgbGlnaHRpbmdcXG5cXG4gICAgdmVjMyByZWZsZWN0YW5jZTkwOyAgICAgICAgICAgLy8gcmVmbGVjdGFuY2UgY29sb3IgYXQgZ3JhemluZyBhbmdsZVxcbiAgICB2ZWMzIHNwZWN1bGFyQ29sb3I7ICAgICAgICAgICAvLyBjb2xvciBjb250cmlidXRpb24gZnJvbSBzcGVjdWxhciBsaWdodGluZ1xcbn07XFxuXFxuLy8gQ2FsY3VsYXRpb24gb2YgdGhlIGxpZ2h0aW5nIGNvbnRyaWJ1dGlvbiBmcm9tIGFuIG9wdGlvbmFsIEltYWdlIEJhc2VkIExpZ2h0IHNvdXJjZS5cXG4vLyBQcmVjb21wdXRlZCBFbnZpcm9ubWVudCBNYXBzIGFyZSByZXF1aXJlZCB1bmlmb3JtIGlucHV0cyBhbmQgYXJlIGNvbXB1dGVkIGFzIG91dGxpbmVkIGluIFsxXS5cXG4vLyBTZWUgb3VyIFJFQURNRS5tZCBvbiBFbnZpcm9ubWVudCBNYXBzIFszXSBmb3IgYWRkaXRpb25hbCBkaXNjdXNzaW9uLlxcbiNpZmRlZiBVU0VfSUJMXFxudmVjMyBnZXRJQkxDb250cmlidXRpb24oTWF0ZXJpYWxJbmZvIG1hdGVyaWFsSW5mbywgdmVjMyBuLCB2ZWMzIHYpXFxue1xcbiAgICBmbG9hdCBOZG90ViA9IGNsYW1wKGRvdChuLCB2KSwgMC4wLCAxLjApO1xcblxcbiAgICBmbG9hdCBsb2QgPSBjbGFtcChtYXRlcmlhbEluZm8ucGVyY2VwdHVhbFJvdWdobmVzcyAqIGZsb2F0KHVfTWlwQ291bnQpLCAwLjAsIGZsb2F0KHVfTWlwQ291bnQpKTtcXG4gICAgdmVjMyByZWZsZWN0aW9uID0gbm9ybWFsaXplKHJlZmxlY3QoLXYsIG4pKTtcXG5cXG4gICAgdmVjMiBicmRmU2FtcGxlUG9pbnQgPSBjbGFtcCh2ZWMyKE5kb3RWLCBtYXRlcmlhbEluZm8ucGVyY2VwdHVhbFJvdWdobmVzcyksIHZlYzIoMC4wLCAwLjApLCB2ZWMyKDEuMCwgMS4wKSk7XFxuICAgIC8vIHJldHJpZXZlIGEgc2NhbGUgYW5kIGJpYXMgdG8gRjAuIFNlZSBbMV0sIEZpZ3VyZSAzXFxuICAgIHZlYzIgYnJkZiA9IF90ZXh0dXJlKHVfYnJkZkxVVCwgYnJkZlNhbXBsZVBvaW50KS5yZztcXG5cXG4gICAgdmVjNCBkaWZmdXNlU2FtcGxlID0gX3RleHR1cmUodV9EaWZmdXNlRW52U2FtcGxlciwgbik7XFxuXFxuI2lmZGVmIFVTRV9URVhfTE9EXFxuICAgIHZlYzQgc3BlY3VsYXJTYW1wbGUgPSBfdGV4dHVyZUxvZCh1X1NwZWN1bGFyRW52U2FtcGxlciwgcmVmbGVjdGlvbiwgbG9kKTtcXG4jZWxzZVxcbiAgICB2ZWM0IHNwZWN1bGFyU2FtcGxlID0gX3RleHR1cmUodV9TcGVjdWxhckVudlNhbXBsZXIsIHJlZmxlY3Rpb24pO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfSERSXFxuICAgIC8vIEFscmVhZHkgbGluZWFyLlxcbiAgICB2ZWMzIGRpZmZ1c2VMaWdodCA9IGRpZmZ1c2VTYW1wbGUucmdiO1xcbiAgICB2ZWMzIHNwZWN1bGFyTGlnaHQgPSBzcGVjdWxhclNhbXBsZS5yZ2I7XFxuI2Vsc2VcXG4gICAgdmVjMyBkaWZmdXNlTGlnaHQgPSBTUkdCdG9MSU5FQVIoZGlmZnVzZVNhbXBsZSkucmdiO1xcbiAgICB2ZWMzIHNwZWN1bGFyTGlnaHQgPSBTUkdCdG9MSU5FQVIoc3BlY3VsYXJTYW1wbGUpLnJnYjtcXG4jZW5kaWZcXG5cXG4gICAgdmVjMyBkaWZmdXNlID0gZGlmZnVzZUxpZ2h0ICogbWF0ZXJpYWxJbmZvLmRpZmZ1c2VDb2xvcjtcXG4gICAgdmVjMyBzcGVjdWxhciA9IHNwZWN1bGFyTGlnaHQgKiAobWF0ZXJpYWxJbmZvLnNwZWN1bGFyQ29sb3IgKiBicmRmLnggKyBicmRmLnkpO1xcblxcbiAgICByZXR1cm4gZGlmZnVzZSArIHNwZWN1bGFyO1xcbn1cXG4jZW5kaWZcXG5cXG4vLyBMYW1iZXJ0IGxpZ2h0aW5nXFxuLy8gc2VlIGh0dHBzOi8vc2VibGFnYXJkZS53b3JkcHJlc3MuY29tLzIwMTIvMDEvMDgvcGktb3Itbm90LXRvLXBpLWluLWdhbWUtbGlnaHRpbmctZXF1YXRpb24vXFxudmVjMyBkaWZmdXNlKE1hdGVyaWFsSW5mbyBtYXRlcmlhbEluZm8pXFxue1xcbiAgICByZXR1cm4gbWF0ZXJpYWxJbmZvLmRpZmZ1c2VDb2xvciAvIE1fUEk7XFxufVxcblxcbi8vIFRoZSBmb2xsb3dpbmcgZXF1YXRpb24gbW9kZWxzIHRoZSBGcmVzbmVsIHJlZmxlY3RhbmNlIHRlcm0gb2YgdGhlIHNwZWMgZXF1YXRpb24gKGFrYSBGKCkpXFxuLy8gSW1wbGVtZW50YXRpb24gb2YgZnJlc25lbCBmcm9tIFs0XSwgRXF1YXRpb24gMTVcXG52ZWMzIHNwZWN1bGFyUmVmbGVjdGlvbihNYXRlcmlhbEluZm8gbWF0ZXJpYWxJbmZvLCBBbmd1bGFySW5mbyBhbmd1bGFySW5mbylcXG57XFxuICAgIHJldHVybiBtYXRlcmlhbEluZm8ucmVmbGVjdGFuY2UwICsgKG1hdGVyaWFsSW5mby5yZWZsZWN0YW5jZTkwIC0gbWF0ZXJpYWxJbmZvLnJlZmxlY3RhbmNlMCkgKiBwb3coY2xhbXAoMS4wIC0gYW5ndWxhckluZm8uVmRvdEgsIDAuMCwgMS4wKSwgNS4wKTtcXG59XFxuXFxuLy8gU21pdGggSm9pbnQgR0dYXFxuLy8gTm90ZTogVmlzID0gRyAvICg0ICogTmRvdEwgKiBOZG90VilcXG4vLyBzZWUgRXJpYyBIZWl0ei4gMjAxNC4gVW5kZXJzdGFuZGluZyB0aGUgTWFza2luZy1TaGFkb3dpbmcgRnVuY3Rpb24gaW4gTWljcm9mYWNldC1CYXNlZCBCUkRGcy4gSm91cm5hbCBvZiBDb21wdXRlciBHcmFwaGljcyBUZWNobmlxdWVzLCAzXFxuLy8gc2VlIFJlYWwtVGltZSBSZW5kZXJpbmcuIFBhZ2UgMzMxIHRvIDMzNi5cXG4vLyBzZWUgaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2ZpbGFtZW50L0ZpbGFtZW50Lm1kLmh0bWwjbWF0ZXJpYWxzeXN0ZW0vc3BlY3VsYXJicmRmL2dlb21ldHJpY3NoYWRvd2luZyhzcGVjdWxhcmcpXFxuZmxvYXQgdmlzaWJpbGl0eU9jY2x1c2lvbihNYXRlcmlhbEluZm8gbWF0ZXJpYWxJbmZvLCBBbmd1bGFySW5mbyBhbmd1bGFySW5mbylcXG57XFxuICAgIGZsb2F0IE5kb3RMID0gYW5ndWxhckluZm8uTmRvdEw7XFxuICAgIGZsb2F0IE5kb3RWID0gYW5ndWxhckluZm8uTmRvdFY7XFxuICAgIGZsb2F0IGFscGhhUm91Z2huZXNzU3EgPSBtYXRlcmlhbEluZm8uYWxwaGFSb3VnaG5lc3MgKiBtYXRlcmlhbEluZm8uYWxwaGFSb3VnaG5lc3M7XFxuXFxuICAgIGZsb2F0IEdHWFYgPSBOZG90TCAqIHNxcnQoTmRvdFYgKiBOZG90ViAqICgxLjAgLSBhbHBoYVJvdWdobmVzc1NxKSArIGFscGhhUm91Z2huZXNzU3EpO1xcbiAgICBmbG9hdCBHR1hMID0gTmRvdFYgKiBzcXJ0KE5kb3RMICogTmRvdEwgKiAoMS4wIC0gYWxwaGFSb3VnaG5lc3NTcSkgKyBhbHBoYVJvdWdobmVzc1NxKTtcXG5cXG4gICAgZmxvYXQgR0dYID0gR0dYViArIEdHWEw7XFxuICAgIGlmIChHR1ggPiAwLjApXFxuICAgIHtcXG4gICAgICAgIHJldHVybiAwLjUgLyBHR1g7XFxuICAgIH1cXG4gICAgcmV0dXJuIDAuMDtcXG59XFxuXFxuLy8gVGhlIGZvbGxvd2luZyBlcXVhdGlvbihzKSBtb2RlbCB0aGUgZGlzdHJpYnV0aW9uIG9mIG1pY3JvZmFjZXQgbm9ybWFscyBhY3Jvc3MgdGhlIGFyZWEgYmVpbmcgZHJhd24gKGFrYSBEKCkpXFxuLy8gSW1wbGVtZW50YXRpb24gZnJvbSBcXFwiQXZlcmFnZSBJcnJlZ3VsYXJpdHkgUmVwcmVzZW50YXRpb24gb2YgYSBSb3VnaGVuZWQgU3VyZmFjZSBmb3IgUmF5IFJlZmxlY3Rpb25cXFwiIGJ5IFQuIFMuIFRyb3dicmlkZ2UsIGFuZCBLLiBQLiBSZWl0elxcbi8vIEZvbGxvd3MgdGhlIGRpc3RyaWJ1dGlvbiBmdW5jdGlvbiByZWNvbW1lbmRlZCBpbiB0aGUgU0lHR1JBUEggMjAxMyBjb3Vyc2Ugbm90ZXMgZnJvbSBFUElDIEdhbWVzIFsxXSwgRXF1YXRpb24gMy5cXG5mbG9hdCBtaWNyb2ZhY2V0RGlzdHJpYnV0aW9uKE1hdGVyaWFsSW5mbyBtYXRlcmlhbEluZm8sIEFuZ3VsYXJJbmZvIGFuZ3VsYXJJbmZvKVxcbntcXG4gICAgZmxvYXQgYWxwaGFSb3VnaG5lc3NTcSA9IG1hdGVyaWFsSW5mby5hbHBoYVJvdWdobmVzcyAqIG1hdGVyaWFsSW5mby5hbHBoYVJvdWdobmVzcztcXG4gICAgZmxvYXQgZiA9IChhbmd1bGFySW5mby5OZG90SCAqIGFscGhhUm91Z2huZXNzU3EgLSBhbmd1bGFySW5mby5OZG90SCkgKiBhbmd1bGFySW5mby5OZG90SCArIDEuMDtcXG4gICAgcmV0dXJuIGFscGhhUm91Z2huZXNzU3EgLyAoTV9QSSAqIGYgKiBmKTtcXG59XFxuXFxudmVjMyBnZXRQb2ludFNoYWRlKHZlYzMgcG9pbnRUb0xpZ2h0LCBNYXRlcmlhbEluZm8gbWF0ZXJpYWxJbmZvLCB2ZWMzIG5vcm1hbCwgdmVjMyB2aWV3KVxcbntcXG4gICAgQW5ndWxhckluZm8gYW5ndWxhckluZm8gPSBnZXRBbmd1bGFySW5mbyhwb2ludFRvTGlnaHQsIG5vcm1hbCwgdmlldyk7XFxuXFxuICAgIGlmIChhbmd1bGFySW5mby5OZG90TCA+IDAuMCB8fCBhbmd1bGFySW5mby5OZG90ViA+IDAuMClcXG4gICAge1xcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGFkaW5nIHRlcm1zIGZvciB0aGUgbWljcm9mYWNldCBzcGVjdWxhciBzaGFkaW5nIG1vZGVsXFxuICAgICAgICB2ZWMzIEYgPSBzcGVjdWxhclJlZmxlY3Rpb24obWF0ZXJpYWxJbmZvLCBhbmd1bGFySW5mbyk7XFxuICAgICAgICBmbG9hdCBWaXMgPSB2aXNpYmlsaXR5T2NjbHVzaW9uKG1hdGVyaWFsSW5mbywgYW5ndWxhckluZm8pO1xcbiAgICAgICAgZmxvYXQgRCA9IG1pY3JvZmFjZXREaXN0cmlidXRpb24obWF0ZXJpYWxJbmZvLCBhbmd1bGFySW5mbyk7XFxuXFxuICAgICAgICAvLyBDYWxjdWxhdGlvbiBvZiBhbmFseXRpY2FsIGxpZ2h0aW5nIGNvbnRyaWJ1dGlvblxcbiAgICAgICAgdmVjMyBkaWZmdXNlQ29udHJpYiA9ICgxLjAgLSBGKSAqIGRpZmZ1c2UobWF0ZXJpYWxJbmZvKTtcXG4gICAgICAgIHZlYzMgc3BlY0NvbnRyaWIgPSBGICogVmlzICogRDtcXG5cXG4gICAgICAgIC8vIE9idGFpbiBmaW5hbCBpbnRlbnNpdHkgYXMgcmVmbGVjdGFuY2UgKEJSREYpIHNjYWxlZCBieSB0aGUgZW5lcmd5IG9mIHRoZSBsaWdodCAoY29zaW5lIGxhdylcXG4gICAgICAgIHJldHVybiBhbmd1bGFySW5mby5OZG90TCAqIChkaWZmdXNlQ29udHJpYiArIHNwZWNDb250cmliKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG59XFxuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX2xpZ2h0c19wdW5jdHVhbC9SRUFETUUubWQjcmFuZ2UtcHJvcGVydHlcXG5mbG9hdCBnZXRSYW5nZUF0dGVudWF0aW9uKGZsb2F0IHJhbmdlLCBmbG9hdCBkaXN0YW5jZSlcXG57XFxuICAgIGlmIChyYW5nZSA8PSAwLjApXFxuICAgIHtcXG4gICAgICAgIC8vIG5lZ2F0aXZlIHJhbmdlIG1lYW5zIHVubGltaXRlZFxcbiAgICAgICAgcmV0dXJuIDEuMDtcXG4gICAgfVxcbiAgICByZXR1cm4gbWF4KG1pbigxLjAgLSBwb3coZGlzdGFuY2UgLyByYW5nZSwgNC4wKSwgMS4wKSwgMC4wKSAvIHBvdyhkaXN0YW5jZSwgMi4wKTtcXG59XFxuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX2xpZ2h0c19wdW5jdHVhbC9SRUFETUUubWQjaW5uZXItYW5kLW91dGVyLWNvbmUtYW5nbGVzXFxuZmxvYXQgZ2V0U3BvdEF0dGVudWF0aW9uKHZlYzMgcG9pbnRUb0xpZ2h0LCB2ZWMzIHNwb3REaXJlY3Rpb24sIGZsb2F0IG91dGVyQ29uZUNvcywgZmxvYXQgaW5uZXJDb25lQ29zKVxcbntcXG4gICAgZmxvYXQgYWN0dWFsQ29zID0gZG90KG5vcm1hbGl6ZShzcG90RGlyZWN0aW9uKSwgbm9ybWFsaXplKC1wb2ludFRvTGlnaHQpKTtcXG4gICAgaWYgKGFjdHVhbENvcyA+IG91dGVyQ29uZUNvcylcXG4gICAge1xcbiAgICAgICAgaWYgKGFjdHVhbENvcyA8IGlubmVyQ29uZUNvcylcXG4gICAgICAgIHtcXG4gICAgICAgICAgICByZXR1cm4gc21vb3Roc3RlcChvdXRlckNvbmVDb3MsIGlubmVyQ29uZUNvcywgYWN0dWFsQ29zKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAxLjA7XFxuICAgIH1cXG4gICAgcmV0dXJuIDAuMDtcXG59XFxuXFxudmVjMyBhcHBseURpcmVjdGlvbmFsTGlnaHQoTGlnaHQgbGlnaHQsIE1hdGVyaWFsSW5mbyBtYXRlcmlhbEluZm8sIHZlYzMgbm9ybWFsLCB2ZWMzIHZpZXcsIGZsb2F0IHNoYWRvdylcXG57XFxuICAgIHZlYzMgcG9pbnRUb0xpZ2h0ID0gLWxpZ2h0LmRpcmVjdGlvbjtcXG4gICAgdmVjMyBzaGFkZSA9IGdldFBvaW50U2hhZGUocG9pbnRUb0xpZ2h0LCBtYXRlcmlhbEluZm8sIG5vcm1hbCwgdmlldykgKiBzaGFkb3c7XFxuICAgIHJldHVybiBsaWdodC5pbnRlbnNpdHkgKiBsaWdodC5jb2xvciAqIHNoYWRlO1xcbn1cXG5cXG52ZWMzIGFwcGx5UG9pbnRMaWdodChMaWdodCBsaWdodCwgTWF0ZXJpYWxJbmZvIG1hdGVyaWFsSW5mbywgdmVjMyBub3JtYWwsIHZlYzMgdmlldylcXG57XFxuICAgIHZlYzMgcG9pbnRUb0xpZ2h0ID0gbGlnaHQucG9zaXRpb24gLSB2X1Bvc2l0aW9uO1xcbiAgICBmbG9hdCBkaXN0YW5jZSA9IGxlbmd0aChwb2ludFRvTGlnaHQpO1xcbiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGdldFJhbmdlQXR0ZW51YXRpb24obGlnaHQucmFuZ2UsIGRpc3RhbmNlKTtcXG4gICAgdmVjMyBzaGFkZSA9IGdldFBvaW50U2hhZGUocG9pbnRUb0xpZ2h0LCBtYXRlcmlhbEluZm8sIG5vcm1hbCwgdmlldyk7XFxuICAgIHJldHVybiBhdHRlbnVhdGlvbiAqIGxpZ2h0LmludGVuc2l0eSAqIGxpZ2h0LmNvbG9yICogc2hhZGU7XFxufVxcblxcbnZlYzMgYXBwbHlTcG90TGlnaHQoTGlnaHQgbGlnaHQsIE1hdGVyaWFsSW5mbyBtYXRlcmlhbEluZm8sIHZlYzMgbm9ybWFsLCB2ZWMzIHZpZXcsIGZsb2F0IHNoYWRvdylcXG57XFxuICAgIHZlYzMgcG9pbnRUb0xpZ2h0ID0gbGlnaHQucG9zaXRpb24gLSB2X1Bvc2l0aW9uO1xcbiAgICBmbG9hdCBkaXN0YW5jZSA9IGxlbmd0aChwb2ludFRvTGlnaHQpO1xcbiAgICBmbG9hdCByYW5nZUF0dGVudWF0aW9uID0gZ2V0UmFuZ2VBdHRlbnVhdGlvbihsaWdodC5yYW5nZSwgZGlzdGFuY2UpO1xcbiAgICBmbG9hdCBzcG90QXR0ZW51YXRpb24gPSBnZXRTcG90QXR0ZW51YXRpb24ocG9pbnRUb0xpZ2h0LCBsaWdodC5kaXJlY3Rpb24sIGxpZ2h0Lm91dGVyQ29uZUNvcywgbGlnaHQuaW5uZXJDb25lQ29zKTtcXG4gICAgdmVjMyBzaGFkZSA9IGdldFBvaW50U2hhZGUocG9pbnRUb0xpZ2h0LCBtYXRlcmlhbEluZm8sIG5vcm1hbCwgdmlldykgKiBzaGFkb3c7XFxuICAgIHJldHVybiByYW5nZUF0dGVudWF0aW9uICogc3BvdEF0dGVudWF0aW9uICogbGlnaHQuaW50ZW5zaXR5ICogbGlnaHQuY29sb3IgKiBzaGFkZTtcXG59XFxuXFxudmVjMyBhcHBseUFtYmllbnRMaWdodChMaWdodCBsaWdodCwgTWF0ZXJpYWxJbmZvIG1hdGVyaWFsSW5mbylcXG57XFxuICAgIHJldHVybiBsaWdodC5pbnRlbnNpdHkgKiBsaWdodC5jb2xvciAqIGRpZmZ1c2UobWF0ZXJpYWxJbmZvKTtcXG59XFxuXFxuI2lmZGVmIFdFQkdMMlxcbiAgICBvdXQgdmVjNCBGUkFHX0NPTE9SO1xcbiNlbmRpZlxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICAvLyBNZXRhbGxpYyBhbmQgUm91Z2huZXNzIG1hdGVyaWFsIHByb3BlcnRpZXMgYXJlIHBhY2tlZCB0b2dldGhlclxcbiAgICAvLyBJbiBnbFRGLCB0aGVzZSBmYWN0b3JzIGNhbiBiZSBzcGVjaWZpZWQgYnkgZml4ZWQgc2NhbGFyIHZhbHVlc1xcbiAgICAvLyBvciBmcm9tIGEgbWV0YWxsaWMtcm91Z2huZXNzIG1hcFxcbiAgICBmbG9hdCBwZXJjZXB0dWFsUm91Z2huZXNzID0gMC4wO1xcbiAgICBmbG9hdCBtZXRhbGxpYyA9IDAuMDtcXG4gICAgdmVjNCBiYXNlQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgIHZlYzMgZGlmZnVzZUNvbG9yID0gdmVjMygwLjApO1xcbiAgICB2ZWMzIHNwZWN1bGFyQ29sb3I9IHZlYzMoMC4wKTtcXG4gICAgdmVjMyBmMCA9IHZlYzMoMC4wNCk7XFxuXFxuI2lmZGVmIE1BVEVSSUFMX1NQRUNVTEFSR0xPU1NJTkVTU1xcblxcbiNpZmRlZiBIQVNfU1BFQ1VMQVJfR0xPU1NJTkVTU19NQVBcXG4gICAgdmVjNCBzZ1NhbXBsZSA9IFNSR0J0b0xJTkVBUihfdGV4dHVyZSh1X1NwZWN1bGFyR2xvc3NpbmVzc1NhbXBsZXIsIGdldFNwZWN1bGFyR2xvc3NpbmVzc1VWKCkpKTtcXG4gICAgcGVyY2VwdHVhbFJvdWdobmVzcyA9ICgxLjAgLSBzZ1NhbXBsZS5hICogdV9HbG9zc2luZXNzRmFjdG9yKTsgLy8gZ2xvc3NpbmVzcyB0byByb3VnaG5lc3NcXG4gICAgZjAgPSBzZ1NhbXBsZS5yZ2IgKiB1X1NwZWN1bGFyRmFjdG9yOyAvLyBzcGVjdWxhclxcbiNlbHNlXFxuICAgIGYwID0gdV9TcGVjdWxhckZhY3RvcjtcXG4gICAgcGVyY2VwdHVhbFJvdWdobmVzcyA9IDEuMCAtIHVfR2xvc3NpbmVzc0ZhY3RvcjtcXG4jZW5kaWYgLy8gISBIQVNfU1BFQ1VMQVJfR0xPU1NJTkVTU19NQVBcXG5cXG4jaWZkZWYgSEFTX0RJRkZVU0VfTUFQXFxuICAgIGJhc2VDb2xvciA9IFNSR0J0b0xJTkVBUihfdGV4dHVyZSh1X0RpZmZ1c2VTYW1wbGVyLCBnZXREaWZmdXNlVVYoKSkpICogdV9EaWZmdXNlRmFjdG9yO1xcbiNlbHNlXFxuICAgIGJhc2VDb2xvciA9IHVfRGlmZnVzZUZhY3RvcjtcXG4jZW5kaWYgLy8gIUhBU19ESUZGVVNFX01BUFxcblxcbiAgICBiYXNlQ29sb3IgKj0gZ2V0VmVydGV4Q29sb3IoKTtcXG5cXG4gICAgLy8gZjAgPSBzcGVjdWxhclxcbiAgICBzcGVjdWxhckNvbG9yID0gZjA7XFxuICAgIGZsb2F0IG9uZU1pbnVzU3BlY3VsYXJTdHJlbmd0aCA9IDEuMCAtIG1heChtYXgoZjAuciwgZjAuZyksIGYwLmIpO1xcbiAgICBkaWZmdXNlQ29sb3IgPSBiYXNlQ29sb3IucmdiICogb25lTWludXNTcGVjdWxhclN0cmVuZ3RoO1xcblxcbiNpZmRlZiBERUJVR19NRVRBTExJQ1xcbiAgICAvLyBkbyBjb252ZXJzaW9uIGJldHdlZW4gbWV0YWxsaWMgTS1SIGFuZCBTLUcgbWV0YWxsaWNcXG4gICAgbWV0YWxsaWMgPSBzb2x2ZU1ldGFsbGljKGJhc2VDb2xvci5yZ2IsIHNwZWN1bGFyQ29sb3IsIG9uZU1pbnVzU3BlY3VsYXJTdHJlbmd0aCk7XFxuI2VuZGlmIC8vICEgREVCVUdfTUVUQUxMSUNcXG5cXG4jZW5kaWYgLy8gISBNQVRFUklBTF9TUEVDVUxBUkdMT1NTSU5FU1NcXG5cXG4jaWZkZWYgTUFURVJJQUxfTUVUQUxMSUNST1VHSE5FU1NcXG5cXG4jaWZkZWYgSEFTX01FVEFMTElDX1JPVUdITkVTU19NQVBcXG4gICAgLy8gUm91Z2huZXNzIGlzIHN0b3JlZCBpbiB0aGUgJ2cnIGNoYW5uZWwsIG1ldGFsbGljIGlzIHN0b3JlZCBpbiB0aGUgJ2InIGNoYW5uZWwuXFxuICAgIC8vIFRoaXMgbGF5b3V0IGludGVudGlvbmFsbHkgcmVzZXJ2ZXMgdGhlICdyJyBjaGFubmVsIGZvciAob3B0aW9uYWwpIG9jY2x1c2lvbiBtYXAgZGF0YVxcbiAgICB2ZWM0IG1yU2FtcGxlID0gX3RleHR1cmUodV9NZXRhbGxpY1JvdWdobmVzc1NhbXBsZXIsIGdldE1ldGFsbGljUm91Z2huZXNzVVYoKSk7XFxuICAgIHBlcmNlcHR1YWxSb3VnaG5lc3MgPSBtclNhbXBsZS5nICogdV9Sb3VnaG5lc3NGYWN0b3I7XFxuICAgIG1ldGFsbGljID0gbXJTYW1wbGUuYiAqIHVfTWV0YWxsaWNGYWN0b3I7XFxuI2Vsc2VcXG4gICAgbWV0YWxsaWMgPSB1X01ldGFsbGljRmFjdG9yO1xcbiAgICBwZXJjZXB0dWFsUm91Z2huZXNzID0gdV9Sb3VnaG5lc3NGYWN0b3I7XFxuI2VuZGlmXFxuXFxuICAgIHZlYzQgYmFzZUNvbG9yRmFjdG9yID0gdV9CYXNlQ29sb3JGYWN0b3I7XFxuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuICAgIGJhc2VDb2xvckZhY3RvciA9IHZfQmFzZUNvbG9yRmFjdG9yO1xcbiNlbmRpZlxcblxcbiAgICAvLyBUaGUgYWxiZWRvIG1heSBiZSBkZWZpbmVkIGZyb20gYSBiYXNlIHRleHR1cmUgb3IgYSBmbGF0IGNvbG9yXFxuI2lmZGVmIEhBU19CQVNFX0NPTE9SX01BUFxcbiAgICBiYXNlQ29sb3IgPSBTUkdCdG9MSU5FQVIoX3RleHR1cmUodV9CYXNlQ29sb3JTYW1wbGVyLCBnZXRCYXNlQ29sb3JVVigpKSkgKiBiYXNlQ29sb3JGYWN0b3I7XFxuI2Vsc2VcXG4gICAgYmFzZUNvbG9yID0gYmFzZUNvbG9yRmFjdG9yO1xcbiNlbmRpZlxcblxcbiAgICBiYXNlQ29sb3IgKj0gZ2V0VmVydGV4Q29sb3IoKTtcXG5cXG4gICAgZGlmZnVzZUNvbG9yID0gYmFzZUNvbG9yLnJnYiAqICh2ZWMzKDEuMCkgLSBmMCkgKiAoMS4wIC0gbWV0YWxsaWMpO1xcblxcbiAgICBzcGVjdWxhckNvbG9yID0gbWl4KGYwLCBiYXNlQ29sb3IucmdiLCBtZXRhbGxpYyk7XFxuXFxuI2VuZGlmIC8vICEgTUFURVJJQUxfTUVUQUxMSUNST1VHSE5FU1NcXG5cXG4jaWZkZWYgQUxQSEFNT0RFX01BU0tcXG4gICAgaWYoYmFzZUNvbG9yLmEgPCB1X0FscGhhQ3V0b2ZmKVxcbiAgICB7XFxuICAgICAgICBkaXNjYXJkO1xcbiAgICB9XFxuICAgIGJhc2VDb2xvci5hID0gMS4wO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBBTFBIQU1PREVfT1BBUVVFXFxuICAgIGJhc2VDb2xvci5hID0gMS4wO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBNQVRFUklBTF9VTkxJVFxcbiAgICBGUkFHX0NPTE9SID0gdmVjNChMSU5FQVJ0b1NSR0IoYmFzZUNvbG9yLnJnYikgKiBiYXNlQ29sb3IuYSwgYmFzZUNvbG9yLmEpO1xcbiAgICByZXR1cm47XFxuI2VuZGlmXFxuXFxuICAgIHBlcmNlcHR1YWxSb3VnaG5lc3MgPSBjbGFtcChwZXJjZXB0dWFsUm91Z2huZXNzLCAwLjAsIDEuMCk7XFxuICAgIG1ldGFsbGljID0gY2xhbXAobWV0YWxsaWMsIDAuMCwgMS4wKTtcXG5cXG4gICAgLy8gUm91Z2huZXNzIGlzIGF1dGhvcmVkIGFzIHBlcmNlcHR1YWwgcm91Z2huZXNzOyBhcyBpcyBjb252ZW50aW9uLFxcbiAgICAvLyBjb252ZXJ0IHRvIG1hdGVyaWFsIHJvdWdobmVzcyBieSBzcXVhcmluZyB0aGUgcGVyY2VwdHVhbCByb3VnaG5lc3MgWzJdLlxcbiAgICBmbG9hdCBhbHBoYVJvdWdobmVzcyA9IHBlcmNlcHR1YWxSb3VnaG5lc3MgKiBwZXJjZXB0dWFsUm91Z2huZXNzO1xcblxcbiAgICAvLyBDb21wdXRlIHJlZmxlY3RhbmNlLlxcbiAgICBmbG9hdCByZWZsZWN0YW5jZSA9IG1heChtYXgoc3BlY3VsYXJDb2xvci5yLCBzcGVjdWxhckNvbG9yLmcpLCBzcGVjdWxhckNvbG9yLmIpO1xcblxcbiAgICB2ZWMzIHNwZWN1bGFyRW52aXJvbm1lbnRSMCA9IHNwZWN1bGFyQ29sb3IucmdiO1xcbiAgICAvLyBBbnl0aGluZyBsZXNzIHRoYW4gMiUgaXMgcGh5c2ljYWxseSBpbXBvc3NpYmxlIGFuZCBpcyBpbnN0ZWFkIGNvbnNpZGVyZWQgdG8gYmUgc2hhZG93aW5nLiBDb21wYXJlIHRvIFxcXCJSZWFsLVRpbWUtUmVuZGVyaW5nXFxcIiA0dGggZWRpdG9uIG9uIHBhZ2UgMzI1LlxcbiAgICB2ZWMzIHNwZWN1bGFyRW52aXJvbm1lbnRSOTAgPSB2ZWMzKGNsYW1wKHJlZmxlY3RhbmNlICogNTAuMCwgMC4wLCAxLjApKTtcXG5cXG4gICAgTWF0ZXJpYWxJbmZvIG1hdGVyaWFsSW5mbyA9IE1hdGVyaWFsSW5mbyhcXG4gICAgICAgIHBlcmNlcHR1YWxSb3VnaG5lc3MsXFxuICAgICAgICBzcGVjdWxhckVudmlyb25tZW50UjAsXFxuICAgICAgICBhbHBoYVJvdWdobmVzcyxcXG4gICAgICAgIGRpZmZ1c2VDb2xvcixcXG4gICAgICAgIHNwZWN1bGFyRW52aXJvbm1lbnRSOTAsXFxuICAgICAgICBzcGVjdWxhckNvbG9yXFxuICAgICk7XFxuXFxuICAgIC8vIExJR0hUSU5HXFxuXFxuICAgIHZlYzMgY29sb3IgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcbiAgICB2ZWMzIG5vcm1hbCA9IGdldE5vcm1hbCgpO1xcbiAgICB2ZWMzIHZpZXcgPSBub3JtYWxpemUodV9DYW1lcmEgLSB2X1Bvc2l0aW9uKTtcXG5cXG4gICAgZmxvYXQgc2hhZG93ID0gMS4wO1xcbiAgICAjaWZkZWYgVVNFX1NIQURPV19NQVBQSU5HXFxuICAgICAgICBzaGFkb3cgPSBnZXRTaGFkb3dDb250cmlidXRpb24oKTtcXG4gICAgI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9QVU5DVFVBTFxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IExJR0hUX0NPVU5UOyArK2kpXFxuICAgIHtcXG4gICAgICAgIExpZ2h0IGxpZ2h0ID0gdV9MaWdodHNbaV07XFxuICAgICAgICBpZiAobGlnaHQudHlwZSA9PSBMaWdodFR5cGVfRGlyZWN0aW9uYWwpXFxuICAgICAgICB7XFxuICAgICAgICAgICAgY29sb3IgKz0gYXBwbHlEaXJlY3Rpb25hbExpZ2h0KGxpZ2h0LCBtYXRlcmlhbEluZm8sIG5vcm1hbCwgdmlldywgc2hhZG93KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGxpZ2h0LnR5cGUgPT0gTGlnaHRUeXBlX1BvaW50KVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIGNvbG9yICs9IGFwcGx5UG9pbnRMaWdodChsaWdodCwgbWF0ZXJpYWxJbmZvLCBub3JtYWwsIHZpZXcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAobGlnaHQudHlwZSA9PSBMaWdodFR5cGVfU3BvdClcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBjb2xvciArPSBhcHBseVNwb3RMaWdodChsaWdodCwgbWF0ZXJpYWxJbmZvLCBub3JtYWwsIHZpZXcsIHNoYWRvdyk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChsaWdodC50eXBlID09IExpZ2h0VHlwZV9BbWJpZW50KSBcXG4gICAgICAgIHtcXG4gXFx0XFx0XFx0Y29sb3IgKz0gYXBwbHlBbWJpZW50TGlnaHQobGlnaHQsIG1hdGVyaWFsSW5mbyk7XFxuIFxcdFxcdH1cXG4gICAgfVxcbiNlbmRpZlxcblxcbiAgICAvLyBDYWxjdWxhdGUgbGlnaHRpbmcgY29udHJpYnV0aW9uIGZyb20gaW1hZ2UgYmFzZWQgbGlnaHRpbmcgc291cmNlIChJQkwpXFxuI2lmZGVmIFVTRV9JQkxcXG4gICAgY29sb3IgKz0gZ2V0SUJMQ29udHJpYnV0aW9uKG1hdGVyaWFsSW5mbywgbm9ybWFsLCB2aWV3KTtcXG4jZW5kaWZcXG5cXG4gICAgZmxvYXQgYW8gPSAxLjA7XFxuICAgIC8vIEFwcGx5IG9wdGlvbmFsIFBCUiB0ZXJtcyBmb3IgYWRkaXRpb25hbCAob3B0aW9uYWwpIHNoYWRpbmdcXG4jaWZkZWYgSEFTX09DQ0xVU0lPTl9NQVBcXG4gICAgYW8gPSBfdGV4dHVyZSh1X09jY2x1c2lvblNhbXBsZXIsICBnZXRPY2NsdXNpb25VVigpKS5yO1xcbiAgICBjb2xvciA9IG1peChjb2xvciwgY29sb3IgKiBhbywgdV9PY2NsdXNpb25TdHJlbmd0aCk7XFxuI2VuZGlmXFxuXFxuICAgIHZlYzMgZW1pc3NpdmUgPSB2ZWMzKDApO1xcbiNpZmRlZiBIQVNfRU1JU1NJVkVfTUFQXFxuICAgIGVtaXNzaXZlID0gU1JHQnRvTElORUFSKF90ZXh0dXJlKHVfRW1pc3NpdmVTYW1wbGVyLCBnZXRFbWlzc2l2ZVVWKCkpKS5yZ2IgKiB1X0VtaXNzaXZlRmFjdG9yO1xcbiAgICBjb2xvciArPSBlbWlzc2l2ZTtcXG4jZW5kaWZcXG5cXG4jaWZuZGVmIERFQlVHX09VVFBVVCAvLyBubyBkZWJ1Z1xcblxcbiAgIC8vIHJlZ3VsYXIgc2hhZGluZ1xcbiAgICBGUkFHX0NPTE9SID0gdmVjNCh0b25lTWFwKGNvbG9yKSAqIGJhc2VDb2xvci5hLCBiYXNlQ29sb3IuYSk7XFxuXFxuI2Vsc2UgLy8gZGVidWcgb3V0cHV0XFxuXFxuICAgICNpZmRlZiBERUJVR19NRVRBTExJQ1xcbiAgICAgICAgRlJBR19DT0xPUi5yZ2IgPSB2ZWMzKG1ldGFsbGljKTtcXG4gICAgI2VuZGlmXFxuXFxuICAgICNpZmRlZiBERUJVR19ST1VHSE5FU1NcXG4gICAgICAgIEZSQUdfQ09MT1IucmdiID0gdmVjMyhwZXJjZXB0dWFsUm91Z2huZXNzKTtcXG4gICAgI2VuZGlmXFxuXFxuICAgICNpZmRlZiBERUJVR19OT1JNQUxcXG4gICAgICAgICNpZmRlZiBIQVNfTk9STUFMX01BUFxcbiAgICAgICAgICAgIEZSQUdfQ09MT1IucmdiID0gX3RleHR1cmUodV9Ob3JtYWxTYW1wbGVyLCBnZXROb3JtYWxVVigpKS5yZ2I7XFxuICAgICAgICAjZWxzZVxcbiAgICAgICAgICAgIEZSQUdfQ09MT1IucmdiID0gdmVjMygwLjUsIDAuNSwgMS4wKTtcXG4gICAgICAgICNlbmRpZlxcbiAgICAjZW5kaWZcXG5cXG4gICAgI2lmZGVmIERFQlVHX0JBU0VDT0xPUlxcbiAgICAgICAgRlJBR19DT0xPUi5yZ2IgPSBMSU5FQVJ0b1NSR0IoYmFzZUNvbG9yLnJnYik7XFxuICAgICNlbmRpZlxcblxcbiAgICAjaWZkZWYgREVCVUdfT0NDTFVTSU9OXFxuICAgICAgICBGUkFHX0NPTE9SLnJnYiA9IHZlYzMoYW8pO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgI2lmZGVmIERFQlVHX0VNSVNTSVZFXFxuICAgICAgICBGUkFHX0NPTE9SLnJnYiA9IExJTkVBUnRvU1JHQihlbWlzc2l2ZSk7XFxuICAgICNlbmRpZlxcblxcbiAgICAjaWZkZWYgREVCVUdfRjBcXG4gICAgICAgIEZSQUdfQ09MT1IucmdiID0gdmVjMyhmMCk7XFxuICAgICNlbmRpZlxcblxcbiAgICAjaWZkZWYgREVCVUdfQUxQSEFcXG4gICAgICAgIEZSQUdfQ09MT1IucmdiID0gdmVjMyhiYXNlQ29sb3IuYSk7XFxuICAgICNlbmRpZlxcblxcbiAgICBGUkFHX0NPTE9SLmEgPSAxLjA7XFxuXFxuI2VuZGlmIC8vICFERUJVR19PVVRQVVRcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gVkVSU0lPTlxcblxcbiNkZWZpbmUgRkVBVFVSRVNcXG5cXG52ZWM0IF90ZXh0dXJlKHNhbXBsZXIyRCBzYW1wbGVyLCB2ZWMyIGNvb3JkKVxcbntcXG4jaWZkZWYgV0VCR0wyXFxuICAgIHJldHVybiB0ZXh0dXJlKHNhbXBsZXIsIGNvb3JkKTtcXG4jZWxzZVxcbiAgICByZXR1cm4gdGV4dHVyZTJEKHNhbXBsZXIsIGNvb3JkKTtcXG4jZW5kaWZcXG59XFxuXFxudmVjNCBfdGV4dHVyZShzYW1wbGVyQ3ViZSBzYW1wbGVyLCB2ZWMzIGNvb3JkKVxcbntcXG4jaWZkZWYgV0VCR0wyXFxuICAgIHJldHVybiB0ZXh0dXJlKHNhbXBsZXIsIGNvb3JkKTtcXG4jZWxzZVxcbiAgICByZXR1cm4gdGV4dHVyZUN1YmUoc2FtcGxlciwgY29vcmQpO1xcbiNlbmRpZlxcbn1cXG4jaWZkZWYgSEFTX1RBUkdFVF9QT1NJVElPTjBcXG5WRVJUX0lOIHZlYzMgYV9UYXJnZXRfUG9zaXRpb24wO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1BPU0lUSU9OMVxcblZFUlRfSU4gdmVjMyBhX1RhcmdldF9Qb3NpdGlvbjE7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19UQVJHRVRfUE9TSVRJT04yXFxuVkVSVF9JTiB2ZWMzIGFfVGFyZ2V0X1Bvc2l0aW9uMjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1RBUkdFVF9QT1NJVElPTjNcXG5WRVJUX0lOIHZlYzMgYV9UYXJnZXRfUG9zaXRpb24zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1BPU0lUSU9ONFxcblZFUlRfSU4gdmVjMyBhX1RhcmdldF9Qb3NpdGlvbjQ7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19UQVJHRVRfUE9TSVRJT041XFxuVkVSVF9JTiB2ZWMzIGFfVGFyZ2V0X1Bvc2l0aW9uNTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1RBUkdFVF9QT1NJVElPTjZcXG5WRVJUX0lOIHZlYzMgYV9UYXJnZXRfUG9zaXRpb242O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1BPU0lUSU9ON1xcblZFUlRfSU4gdmVjMyBhX1RhcmdldF9Qb3NpdGlvbjc7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19UQVJHRVRfTk9STUFMMFxcblZFUlRfSU4gdmVjMyBhX1RhcmdldF9Ob3JtYWwwO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX05PUk1BTDFcXG5WRVJUX0lOIHZlYzMgYV9UYXJnZXRfTm9ybWFsMTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1RBUkdFVF9OT1JNQUwyXFxuVkVSVF9JTiB2ZWMzIGFfVGFyZ2V0X05vcm1hbDI7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19UQVJHRVRfTk9STUFMM1xcblZFUlRfSU4gdmVjMyBhX1RhcmdldF9Ob3JtYWwzO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1RBTkdFTlQwXFxuVkVSVF9JTiB2ZWMzIGFfVGFyZ2V0X1RhbmdlbnQwO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1RBTkdFTlQxXFxuVkVSVF9JTiB2ZWMzIGFfVGFyZ2V0X1RhbmdlbnQxO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1RBTkdFTlQyXFxuVkVSVF9JTiB2ZWMzIGFfVGFyZ2V0X1RhbmdlbnQyO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1RBTkdFTlQzXFxuVkVSVF9JTiB2ZWMzIGFfVGFyZ2V0X1RhbmdlbnQzO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfTU9SUEhJTkdcXG51bmlmb3JtIGZsb2F0IHVfbW9ycGhXZWlnaHRzW1dFSUdIVF9DT1VOVF07XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19KT0lOVF9TRVQxXFxuVkVSVF9JTiB2ZWM0IGFfSm9pbnQxO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfSk9JTlRfU0VUMlxcblZFUlRfSU4gdmVjNCBhX0pvaW50MjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1dFSUdIVF9TRVQxXFxuVkVSVF9JTiB2ZWM0IGFfV2VpZ2h0MTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1dFSUdIVF9TRVQyXFxuVkVSVF9JTiB2ZWM0IGFfV2VpZ2h0MjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxuI2lmZGVmIFVTRV9TS0lOTklOR19URVhUVVJFXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9qb2ludE1hdHJpeFNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9qb2ludE5vcm1hbE1hdHJpeFNhbXBsZXI7XFxuI2Vsc2VcXG51bmlmb3JtIG1hdDQgdV9qb2ludE1hdHJpeFtKT0lOVF9DT1VOVF07XFxudW5pZm9ybSBtYXQ0IHVfam9pbnROb3JtYWxNYXRyaXhbSk9JTlRfQ09VTlRdO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcbi8vIHRoZXNlIG9mZnNldHMgYXNzdW1lIHRoZSB0ZXh0dXJlIGlzIDQgcGl4ZWxzIGFjcm9zc1xcbiNkZWZpbmUgUk9XMF9VICgoMC41ICsgMC4wKSAvIDQuMClcXG4jZGVmaW5lIFJPVzFfVSAoKDAuNSArIDEuMCkgLyA0LjApXFxuI2RlZmluZSBST1cyX1UgKCgwLjUgKyAyLjApIC8gNC4wKVxcbiNkZWZpbmUgUk9XM19VICgoMC41ICsgMy4wKSAvIDQuMClcXG5cXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxubWF0NCBnZXRKb2ludE1hdHJpeChmbG9hdCBib25lTmR4KSB7XFxuICAgICNpZmRlZiBVU0VfU0tJTk5JTkdfVEVYVFVSRVxcbiAgICBmbG9hdCB2ID0gKGJvbmVOZHggKyAwLjUpIC8gZmxvYXQoSk9JTlRfQ09VTlQpO1xcbiAgICByZXR1cm4gbWF0NChcXG4gICAgICAgIF90ZXh0dXJlKHVfam9pbnRNYXRyaXhTYW1wbGVyLCB2ZWMyKFJPVzBfVSwgdikpICogMi4wIC0gMS4wLFxcbiAgICAgICAgX3RleHR1cmUodV9qb2ludE1hdHJpeFNhbXBsZXIsIHZlYzIoUk9XMV9VLCB2KSkgKiAyLjAgLSAxLjAsXFxuICAgICAgICBfdGV4dHVyZSh1X2pvaW50TWF0cml4U2FtcGxlciwgdmVjMihST1cyX1UsIHYpKSAqIDIuMCAtIDEuMCxcXG4gICAgICAgIF90ZXh0dXJlKHVfam9pbnRNYXRyaXhTYW1wbGVyLCB2ZWMyKFJPVzNfVSwgdikpICogMi4wIC0gMS4wXFxuICAgICk7XFxuICAgICNlbHNlXFxuICAgIHJldHVybiB1X2pvaW50TWF0cml4W2ludChib25lTmR4KV07XFxuICAgICNlbmRpZlxcbn1cXG5cXG5tYXQ0IGdldEpvaW50Tm9ybWFsTWF0cml4KGZsb2F0IGJvbmVOZHgpIHtcXG4gICAgI2lmZGVmIFVTRV9TS0lOTklOR19URVhUVVJFXFxuICAgIGZsb2F0IHYgPSAoYm9uZU5keCArIDAuNSkgLyBmbG9hdChKT0lOVF9DT1VOVCk7XFxuICAgIHJldHVybiBtYXQ0KFxcbiAgICAgICAgX3RleHR1cmUodV9qb2ludE5vcm1hbE1hdHJpeFNhbXBsZXIsIHZlYzIoUk9XMF9VLCB2KSkgKiAyLjAgLSAxLjAsXFxuICAgICAgICBfdGV4dHVyZSh1X2pvaW50Tm9ybWFsTWF0cml4U2FtcGxlciwgdmVjMihST1cxX1UsIHYpKSAqIDIuMCAtIDEuMCxcXG4gICAgICAgIF90ZXh0dXJlKHVfam9pbnROb3JtYWxNYXRyaXhTYW1wbGVyLCB2ZWMyKFJPVzJfVSwgdikpICogMi4wIC0gMS4wLFxcbiAgICAgICAgX3RleHR1cmUodV9qb2ludE5vcm1hbE1hdHJpeFNhbXBsZXIsIHZlYzIoUk9XM19VLCB2KSkgKiAyLjAgLSAxLjBcXG4gICAgKTtcXG4gICAgI2Vsc2VcXG4gICAgcmV0dXJuIHVfam9pbnROb3JtYWxNYXRyaXhbaW50KGJvbmVOZHgpXTtcXG4gICAgI2VuZGlmXFxufVxcblxcbm1hdDQgZ2V0U2tpbm5pbmdNYXRyaXgoKVxcbntcXG4gICAgbWF0NCBza2luID0gbWF0NCgwKTtcXG5cXG4gICAgI2lmIGRlZmluZWQoSEFTX1dFSUdIVF9TRVQxKSAmJiBkZWZpbmVkKEhBU19KT0lOVF9TRVQxKVxcbiAgICBza2luICs9XFxuICAgICAgICBhX1dlaWdodDEueCAqIGdldEpvaW50TWF0cml4KGFfSm9pbnQxLngpICtcXG4gICAgICAgIGFfV2VpZ2h0MS55ICogZ2V0Sm9pbnRNYXRyaXgoYV9Kb2ludDEueSkgK1xcbiAgICAgICAgYV9XZWlnaHQxLnogKiBnZXRKb2ludE1hdHJpeChhX0pvaW50MS56KSArXFxuICAgICAgICBhX1dlaWdodDEudyAqIGdldEpvaW50TWF0cml4KGFfSm9pbnQxLncpO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgcmV0dXJuIHNraW47XFxufVxcblxcbm1hdDQgZ2V0U2tpbm5pbmdOb3JtYWxNYXRyaXgoKVxcbntcXG4gICAgbWF0NCBza2luID0gbWF0NCgwKTtcXG5cXG4gICAgI2lmIGRlZmluZWQoSEFTX1dFSUdIVF9TRVQxKSAmJiBkZWZpbmVkKEhBU19KT0lOVF9TRVQxKVxcbiAgICBza2luICs9XFxuICAgICAgICBhX1dlaWdodDEueCAqIGdldEpvaW50Tm9ybWFsTWF0cml4KGFfSm9pbnQxLngpICtcXG4gICAgICAgIGFfV2VpZ2h0MS55ICogZ2V0Sm9pbnROb3JtYWxNYXRyaXgoYV9Kb2ludDEueSkgK1xcbiAgICAgICAgYV9XZWlnaHQxLnogKiBnZXRKb2ludE5vcm1hbE1hdHJpeChhX0pvaW50MS56KSArXFxuICAgICAgICBhX1dlaWdodDEudyAqIGdldEpvaW50Tm9ybWFsTWF0cml4KGFfSm9pbnQxLncpO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgcmV0dXJuIHNraW47XFxufVxcbiNlbmRpZiAvLyAhVVNFX1NLSU5OSU5HXFxuXFxuI2lmZGVmIFVTRV9NT1JQSElOR1xcbnZlYzQgZ2V0VGFyZ2V0UG9zaXRpb24oKVxcbntcXG4gICAgdmVjNCBwb3MgPSB2ZWM0KDApO1xcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1BPU0lUSU9OMFxcbiAgICBwb3MueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzBdICogYV9UYXJnZXRfUG9zaXRpb24wO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1BPU0lUSU9OMVxcbiAgICBwb3MueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzFdICogYV9UYXJnZXRfUG9zaXRpb24xO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1BPU0lUSU9OMlxcbiAgICBwb3MueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzJdICogYV9UYXJnZXRfUG9zaXRpb24yO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1BPU0lUSU9OM1xcbiAgICBwb3MueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzNdICogYV9UYXJnZXRfUG9zaXRpb24zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1BPU0lUSU9ONFxcbiAgICBwb3MueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzRdICogYV9UYXJnZXRfUG9zaXRpb240O1xcbiNlbmRpZlxcblxcbiAgICByZXR1cm4gcG9zO1xcbn1cXG5cXG52ZWM0IGdldFRhcmdldE5vcm1hbCgpXFxue1xcbiAgICB2ZWM0IG5vcm1hbCA9IHZlYzQoMCk7XFxuXFxuI2lmZGVmIEhBU19UQVJHRVRfTk9STUFMMFxcbiAgICBub3JtYWwueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzBdICogYV9UYXJnZXRfTm9ybWFsMDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1RBUkdFVF9OT1JNQUwxXFxuICAgIG5vcm1hbC54eXogKz0gdV9tb3JwaFdlaWdodHNbMV0gKiBhX1RhcmdldF9Ob3JtYWwxO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX05PUk1BTDJcXG4gICAgbm9ybWFsLnh5eiArPSB1X21vcnBoV2VpZ2h0c1syXSAqIGFfVGFyZ2V0X05vcm1hbDI7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19UQVJHRVRfTk9STUFMM1xcbiAgICBub3JtYWwueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzNdICogYV9UYXJnZXRfTm9ybWFsMztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1RBUkdFVF9OT1JNQUw0XFxuICAgIG5vcm1hbC54eXogKz0gdV9tb3JwaFdlaWdodHNbNF0gKiBhX1RhcmdldF9Ob3JtYWw0O1xcbiNlbmRpZlxcblxcbiAgICByZXR1cm4gbm9ybWFsO1xcbn1cXG5cXG52ZWM0IGdldFRhcmdldFRhbmdlbnQoKVxcbntcXG4gICAgdmVjNCB0YW5nZW50ID0gdmVjNCgwKTtcXG5cXG4jaWZkZWYgSEFTX1RBUkdFVF9UQU5HRU5UMFxcbiAgICB0YW5nZW50Lnh5eiArPSB1X21vcnBoV2VpZ2h0c1swXSAqIGFfVGFyZ2V0X1RhbmdlbnQwO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1RBTkdFTlQxXFxuICAgIHRhbmdlbnQueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzFdICogYV9UYXJnZXRfVGFuZ2VudDE7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19UQVJHRVRfVEFOR0VOVDJcXG4gICAgdGFuZ2VudC54eXogKz0gdV9tb3JwaFdlaWdodHNbMl0gKiBhX1RhcmdldF9UYW5nZW50MjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1RBUkdFVF9UQU5HRU5UM1xcbiAgICB0YW5nZW50Lnh5eiArPSB1X21vcnBoV2VpZ2h0c1szXSAqIGFfVGFyZ2V0X1RhbmdlbnQzO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFSR0VUX1RBTkdFTlQ0XFxuICAgIHRhbmdlbnQueHl6ICs9IHVfbW9ycGhXZWlnaHRzWzRdICogYV9UYXJnZXRfVGFuZ2VudDQ7XFxuI2VuZGlmXFxuXFxuICAgIHJldHVybiB0YW5nZW50O1xcbn1cXG5cXG4jZW5kaWYgLy8gIVVTRV9NT1JQSElOR1xcblxcblxcblZFUlRfSU4gdmVjNCBhX1Bvc2l0aW9uO1xcblZFUlRfT1VUIHZlYzMgdl9Qb3NpdGlvbjtcXG5cXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5WRVJUX0lOIHZlYzQgYV9Nb2RlbE1hdHJpeDA7XFxuVkVSVF9JTiB2ZWM0IGFfTW9kZWxNYXRyaXgxO1xcblZFUlRfSU4gdmVjNCBhX01vZGVsTWF0cml4MjtcXG5WRVJUX0lOIHZlYzQgYV9Nb2RlbE1hdHJpeDM7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuVkVSVF9JTiB2ZWM0IGFfQmFzZUNvbG9yRmFjdG9yO1xcblZFUlRfT1VUIHZlYzQgdl9CYXNlQ29sb3JGYWN0b3I7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuVkVSVF9JTiB2ZWM0IGFfTm9ybWFsTWF0cml4MDtcXG5WRVJUX0lOIHZlYzQgYV9Ob3JtYWxNYXRyaXgxO1xcblZFUlRfSU4gdmVjNCBhX05vcm1hbE1hdHJpeDI7XFxuVkVSVF9JTiB2ZWM0IGFfTm9ybWFsTWF0cml4MztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX05PUk1BTFNcXG5WRVJUX0lOIHZlYzQgYV9Ob3JtYWw7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19UQU5HRU5UU1xcblZFUlRfSU4gdmVjNCBhX1RhbmdlbnQ7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19OT1JNQUxTXFxuI2lmZGVmIEhBU19UQU5HRU5UU1xcblZFUlRfT1VUIG1hdDMgdl9UQk47XFxuI2Vsc2VcXG5WRVJUX09VVCB2ZWMzIHZfTm9ybWFsO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVVZfU0VUMVxcblZFUlRfSU4gdmVjMiBhX1VWMTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1VWX1NFVDJcXG5WRVJUX0lOIHZlYzIgYV9VVjI7XFxuI2VuZGlmXFxuXFxuVkVSVF9PVVQgdmVjMiB2X1VWQ29vcmQxO1xcblZFUlRfT1VUIHZlYzIgdl9VVkNvb3JkMjtcXG5cXG4jaWZkZWYgSEFTX1ZFUlRFWF9DT0xPUl9WRUMzXFxuVkVSVF9JTiB2ZWMzIGFfQ29sb3I7XFxuVkVSVF9PVVQgdmVjMyB2X0NvbG9yO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVkVSVEVYX0NPTE9SX1ZFQzRcXG5WRVJUX0lOIHZlYzQgYV9Db2xvcjtcXG5WRVJUX09VVCB2ZWM0IHZfQ29sb3I7XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBtYXQ0IHVfVmlld1Byb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVfTW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVfTm9ybWFsTWF0cml4O1xcblxcbiNpZmRlZiBVU0VfU0hBRE9XX01BUFBJTkdcXG51bmlmb3JtIG1hdDQgdV9MaWdodFZpZXdQcm9qZWN0aW9uTWF0cml4O1xcblZFUlRfT1VUIHZlYzQgdl9Qb3NpdGlvbkxpZ2h0U3BhY2U7XFxuI2VuZGlmXFxuXFxudmVjNCBnZXRQb3NpdGlvbigpXFxue1xcbiAgICB2ZWM0IHBvcyA9IGFfUG9zaXRpb247XFxuXFxuI2lmZGVmIFVTRV9NT1JQSElOR1xcbiAgICBwb3MgKz0gZ2V0VGFyZ2V0UG9zaXRpb24oKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxuICAgIHBvcyA9IGdldFNraW5uaW5nTWF0cml4KCkgKiBwb3M7XFxuI2VuZGlmXFxuXFxuICAgIHJldHVybiBwb3M7XFxufVxcblxcbiNpZmRlZiBIQVNfTk9STUFMU1xcbnZlYzQgZ2V0Tm9ybWFsKClcXG57XFxuICAgIHZlYzQgbm9ybWFsID0gYV9Ob3JtYWw7XFxuXFxuI2lmZGVmIFVTRV9NT1JQSElOR1xcbiAgICBub3JtYWwgKz0gZ2V0VGFyZ2V0Tm9ybWFsKCk7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9TS0lOTklOR1xcbiAgICBub3JtYWwgPSBnZXRTa2lubmluZ05vcm1hbE1hdHJpeCgpICogbm9ybWFsO1xcbiNlbmRpZlxcblxcbiAgICByZXR1cm4gbm9ybWFsaXplKG5vcm1hbCk7XFxufVxcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfVEFOR0VOVFNcXG52ZWM0IGdldFRhbmdlbnQoKVxcbntcXG4gICAgdmVjNCB0YW5nZW50ID0gYV9UYW5nZW50O1xcblxcbiNpZmRlZiBVU0VfTU9SUEhJTkdcXG4gICAgdGFuZ2VudCArPSBnZXRUYXJnZXRUYW5nZW50KCk7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9TS0lOTklOR1xcbiAgICB0YW5nZW50ID0gZ2V0U2tpbm5pbmdNYXRyaXgoKSAqIHRhbmdlbnQ7XFxuI2VuZGlmXFxuXFxuICAgIHJldHVybiBub3JtYWxpemUodGFuZ2VudCk7XFxufVxcbiNlbmRpZlxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICBtYXQ0IG1vZGVsTWF0cml4ID0gdV9Nb2RlbE1hdHJpeDtcXG4gICAgI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgICBtb2RlbE1hdHJpeCA9IG1hdDQoYV9Nb2RlbE1hdHJpeDAsIGFfTW9kZWxNYXRyaXgxLCBhX01vZGVsTWF0cml4MiwgYV9Nb2RlbE1hdHJpeDMpO1xcbiAgICAjZW5kaWZcXG4gICAgdmVjNCBwb3MgPSBtb2RlbE1hdHJpeCAqIGdldFBvc2l0aW9uKCk7XFxuICAgIHZfUG9zaXRpb24gPSB2ZWMzKHBvcy54eXopIC8gcG9zLnc7XFxuXFxuICAgIG1hdDQgbm9ybWFsTWF0cml4ID0gdV9Ob3JtYWxNYXRyaXg7XFxuICAgICNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgICAgbm9ybWFsTWF0cml4ID0gbWF0NChhX05vcm1hbE1hdHJpeDAsIGFfTm9ybWFsTWF0cml4MSwgYV9Ob3JtYWxNYXRyaXgyLCBhX05vcm1hbE1hdHJpeDMpO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgI2lmZGVmIEhBU19OT1JNQUxTXFxuICAgICNpZmRlZiBIQVNfVEFOR0VOVFNcXG4gICAgdmVjNCB0YW5nZW50ID0gZ2V0VGFuZ2VudCgpO1xcbiAgICB2ZWMzIG5vcm1hbFcgPSBub3JtYWxpemUodmVjMyhub3JtYWxNYXRyaXggKiB2ZWM0KGdldE5vcm1hbCgpLnh5eiwgMC4wKSkpO1xcbiAgICB2ZWMzIHRhbmdlbnRXID0gbm9ybWFsaXplKHZlYzMobW9kZWxNYXRyaXggKiB2ZWM0KHRhbmdlbnQueHl6LCAwLjApKSk7XFxuICAgIHZlYzMgYml0YW5nZW50VyA9IGNyb3NzKG5vcm1hbFcsIHRhbmdlbnRXKSAqIHRhbmdlbnQudztcXG4gICAgdl9UQk4gPSBtYXQzKHRhbmdlbnRXLCBiaXRhbmdlbnRXLCBub3JtYWxXKTtcXG4gICAgI2Vsc2UgLy8gIUhBU19UQU5HRU5UU1xcbiAgICB2X05vcm1hbCA9IG5vcm1hbGl6ZSh2ZWMzKG5vcm1hbE1hdHJpeCAqIHZlYzQoZ2V0Tm9ybWFsKCkueHl6LCAwLjApKSk7XFxuICAgICNlbmRpZlxcbiAgICAjZW5kaWYgLy8gIUhBU19OT1JNQUxTXFxuXFxuICAgIHZfVVZDb29yZDEgPSB2ZWMyKDAuMCwgMC4wKTtcXG4gICAgdl9VVkNvb3JkMiA9IHZlYzIoMC4wLCAwLjApO1xcblxcbiAgICAjaWZkZWYgSEFTX1VWX1NFVDFcXG4gICAgdl9VVkNvb3JkMSA9IGFfVVYxO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgI2lmZGVmIEhBU19VVl9TRVQyXFxuICAgIHZfVVZDb29yZDIgPSBhX1VWMjtcXG4gICAgI2VuZGlmXFxuXFxuICAgICNpZiBkZWZpbmVkKEhBU19WRVJURVhfQ09MT1JfVkVDMykgfHwgZGVmaW5lZChIQVNfVkVSVEVYX0NPTE9SX1ZFQzQpXFxuICAgIHZfQ29sb3IgPSBhX0NvbG9yO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgI2lmZGVmIFVTRV9TSEFET1dfTUFQUElOR1xcbiAgICB2X1Bvc2l0aW9uTGlnaHRTcGFjZSA9IHVfTGlnaHRWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHBvcztcXG4gICAgI2VuZGlmXFxuXFxuICAgICNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICB2X0Jhc2VDb2xvckZhY3RvciA9IGFfQmFzZUNvbG9yRmFjdG9yO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSB1X1ZpZXdQcm9qZWN0aW9uTWF0cml4ICogcG9zO1xcbn1cXG5cIiIsImV4cG9ydCBlbnVtIFN0YW5kYXJkTWF0ZXJpYWxBbHBoYU1vZGUge1xuICAvKipcbiAgICogVGhlIHJlbmRlcmVkIG91dHB1dCBpcyBmdWxseSBvcGFxdWUgYW5kIGFueSBhbHBoYSB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKi9cbiAgb3BhcXVlID0gXCJvcGFxdWVcIixcbiAgLyoqXG4gICAqIFRoZSByZW5kZXJlZCBvdXRwdXQgaXMgZWl0aGVyIGZ1bGx5IG9wYXF1ZSBvciBmdWxseSB0cmFuc3BhcmVudCBkZXBlbmRpbmcgXG4gICAqIG9uIHRoZSBhbHBoYSB2YWx1ZSBhbmQgdGhlIHNwZWNpZmllZCBhbHBoYSBjdXRvZmYgdmFsdWUuIFRoaXMgbW9kZSBpcyB1c2VkIFxuICAgKiB0byBzaW11bGF0ZSBnZW9tZXRyeSBzdWNoIGFzIHRyZWUgbGVhdmVzIG9yIHdpcmUgZmVuY2VzLlxuICAgKi9cbiAgbWFzayA9IFwibWFza1wiLFxuICAvKipcbiAgICogVGhlIHJlbmRlcmVkIG91dHB1dCBpcyBjb21iaW5lZCB3aXRoIHRoZSBiYWNrZ3JvdW5kIHVzaW5nIHRoZSBub3JtYWwgXG4gICAqIHBhaW50aW5nIG9wZXJhdGlvbiAoaS5lLiB0aGUgUG9ydGVyIGFuZCBEdWZmIG92ZXIgb3BlcmF0b3IpLiBUaGlzIG1vZGUgaXMgXG4gICAqIHVzZWQgdG8gc2ltdWxhdGUgZ2VvbWV0cnkgc3VjaCBhcyBndWF6ZSBjbG90aCBvciBhbmltYWwgZnVyLlxuICAgKi9cbiAgYmxlbmQgPSBcImJsZW5kXCJcbn0iLCJleHBvcnQgZW51bSBTdGFuZGFyZE1hdGVyaWFsRGVidWdNb2RlIHtcbiAgYWxwaGEgPSBcImFscGhhXCIsXG4gIGVtaXNzaXZlID0gXCJlbWlzc2l2ZVwiLFxuICBmMCA9IFwiZjBcIixcbiAgbWV0YWxsaWMgPSBcIm1ldGFsbGljXCIsXG4gIG5vcm1hbCA9IFwibm9ybWFsXCIsXG4gIG9jY2x1c2lvbiA9IFwib2NjbHVzaW9uXCIsXG4gIHJvdWdobmVzcyA9IFwicm91Z2huZXNzXCJcbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgTWVzaEdlb21ldHJ5M0QgfSBmcm9tIFwiLi4vLi4vbWVzaC9nZW9tZXRyeS9tZXNoLWdlb21ldHJ5XCJcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWxBbHBoYU1vZGUgfSBmcm9tIFwiLi9zdGFuZGFyZC1tYXRlcmlhbC1hbHBoYS1tb2RlXCJcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWxEZWJ1Z01vZGUgfSBmcm9tIFwiLi9zdGFuZGFyZC1tYXRlcmlhbC1kZWJ1Zy1tb2RlXCJcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWwgfSBmcm9tIFwiLi9zdGFuZGFyZC1tYXRlcmlhbFwiXG5pbXBvcnQgeyBMaWdodGluZ0Vudmlyb25tZW50IH0gZnJvbSBcIi4uLy4uL2xpZ2h0aW5nL2xpZ2h0aW5nLWVudmlyb25tZW50XCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuLi8uLi9tZXNoL21lc2hcIlxuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tIFwiLi4vLi4vcGxhdGZvcm1cIlxuaW1wb3J0IHsgU3RhbmRhcmRNYXRlcmlhbE1hdHJpeFRleHR1cmUgfSBmcm9tIFwiLi9zdGFuZGFyZC1tYXRlcmlhbC1tYXRyaXgtdGV4dHVyZVwiXG5pbXBvcnQgeyBDb25zb2xlIH0gZnJvbSBcIi4uLy4uL2NvbnNvbGVcIlxuXG5leHBvcnQgbmFtZXNwYWNlIFN0YW5kYXJkTWF0ZXJpYWxGZWF0dXJlU2V0IHtcbiAgZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyLCBtZXNoOiBNZXNoM0QsIGdlb21ldHJ5OiBNZXNoR2VvbWV0cnkzRCwgbWF0ZXJpYWw6IFN0YW5kYXJkTWF0ZXJpYWwsIGxpZ2h0aW5nRW52aXJvbm1lbnQ6IExpZ2h0aW5nRW52aXJvbm1lbnQpIHtcbiAgICBsZXQgZmVhdHVyZXM6IHN0cmluZ1tdID0gW11cblxuICAgIGlmIChtZXNoLmluc3RhbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBmZWF0dXJlcy5wdXNoKFwiVVNFX0lOU1RBTkNJTkcgMVwiKVxuICAgIH1cbiAgICBpZiAocmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2goXCJXRUJHTDEgMVwiKVxuICAgIH1cbiAgICBpZiAocmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDIpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2goXCJXRUJHTDIgMVwiKVxuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnkubm9ybWFscykge1xuICAgICAgZmVhdHVyZXMucHVzaChcIkhBU19OT1JNQUxTIDFcIilcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LnV2cykge1xuICAgICAgZmVhdHVyZXMucHVzaChcIkhBU19VVl9TRVQxIDFcIilcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LnRhbmdlbnRzKSB7XG4gICAgICBmZWF0dXJlcy5wdXNoKFwiSEFTX1RBTkdFTlRTIDFcIilcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LnRhcmdldHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnkudGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZ2VvbWV0cnkudGFyZ2V0c1tpXS5wb3NpdGlvbnMpIHtcbiAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiSEFTX1RBUkdFVF9QT1NJVElPTlwiICsgaSlcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VvbWV0cnkudGFyZ2V0c1tpXS5ub3JtYWxzKSB7XG4gICAgICAgICAgZmVhdHVyZXMucHVzaChcIkhBU19UQVJHRVRfTk9STUFMXCIgKyBpKVxuICAgICAgICB9XG4gICAgICAgIGlmIChnZW9tZXRyeS50YXJnZXRzW2ldLnRhbmdlbnRzKSB7XG4gICAgICAgICAgZmVhdHVyZXMucHVzaChcIkhBU19UQVJHRVRfVEFOR0VOVFwiICsgaSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lc2gubW9ycGhXZWlnaHRzKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goYFdFSUdIVF9DT1VOVCAke21lc2gubW9ycGhXZWlnaHRzLmxlbmd0aH1gKVxuICAgICAgICBmZWF0dXJlcy5wdXNoKFwiVVNFX01PUlBISU5HIDFcIilcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LmpvaW50cykge1xuICAgICAgZmVhdHVyZXMucHVzaChcIkhBU19KT0lOVF9TRVQxIDFcIilcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LndlaWdodHMpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2goXCJIQVNfV0VJR0hUX1NFVDEgMVwiKVxuICAgIH1cbiAgICBpZiAobWVzaC5za2luKSB7XG4gICAgICBpZiAoaXNKb2ludE1hdHJpeFRleHR1cmVSZXF1aXJlZChtZXNoLnNraW4uam9pbnRzLmxlbmd0aCwgcmVuZGVyZXIpKSB7XG4gICAgICAgIGlmIChTdGFuZGFyZE1hdGVyaWFsTWF0cml4VGV4dHVyZS5pc1N1cHBvcnRlZChyZW5kZXJlcikpIHtcbiAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiVVNFX1NLSU5OSU5HIDFcIilcbiAgICAgICAgICBmZWF0dXJlcy5wdXNoKFwiVVNFX1NLSU5OSU5HX1RFWFRVUkUgMVwiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIENvbnNvbGUuZXJyb3IoYFBJWEkzRDogTWVzaCBjb250YWlucyAke21lc2guc2tpbi5qb2ludHMubGVuZ3RofSBqb2ludHMsIHdoaWNoIGlzIG1vcmUgdGhhbiBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UuIFNraW5uaW5nIHdpbGwgYmUgZGlzYWJsZWQgYW5kIHJlc3VsdCBtYXkgbm90IGJlIGFzIGV4cGVjdGVkLmApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCJVU0VfU0tJTk5JTkcgMVwiKVxuICAgICAgfVxuICAgICAgZmVhdHVyZXMucHVzaChgSk9JTlRfQ09VTlQgJHttZXNoLnNraW4uam9pbnRzLmxlbmd0aH1gKVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWwudW5saXQpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2goXCJNQVRFUklBTF9VTkxJVCAxXCIpXG4gICAgfVxuICAgIGZlYXR1cmVzLnB1c2goXCJNQVRFUklBTF9NRVRBTExJQ1JPVUdITkVTUyAxXCIpXG4gICAgaWYgKGxpZ2h0aW5nRW52aXJvbm1lbnQubGlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZlYXR1cmVzLnB1c2goYExJR0hUX0NPVU5UICR7bGlnaHRpbmdFbnZpcm9ubWVudC5saWdodHMubGVuZ3RofWApXG4gICAgICBmZWF0dXJlcy5wdXNoKFwiVVNFX1BVTkNUVUFMIDFcIilcbiAgICB9XG4gICAgaWYgKGxpZ2h0aW5nRW52aXJvbm1lbnQuaW1hZ2VCYXNlZExpZ2h0aW5nKSB7XG4gICAgICBpZiAoIWxpZ2h0aW5nRW52aXJvbm1lbnQuaW1hZ2VCYXNlZExpZ2h0aW5nLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIGlmIChQbGF0Zm9ybS5pc1NoYWRlclRleHR1cmVMb2RTdXBwb3J0ZWQocmVuZGVyZXIpKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCJVU0VfVEVYX0xPRCAxXCIpXG4gICAgICB9XG4gICAgICBmZWF0dXJlcy5wdXNoKFwiVVNFX0lCTCAxXCIpXG4gICAgfVxuICAgIGlmIChtYXRlcmlhbC5zaGFkb3dDYXN0aW5nTGlnaHQpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2goXCJVU0VfU0hBRE9XX01BUFBJTkcgMVwiKVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWwuYmFzZUNvbG9yVGV4dHVyZSkge1xuICAgICAgaWYgKCFtYXRlcmlhbC5iYXNlQ29sb3JUZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIGlmICgoPGFueT5tYXRlcmlhbC5iYXNlQ29sb3JUZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKFwiSEFTX0JBU0VDT0xPUl9VVl9UUkFOU0ZPUk0gMVwiKTtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmVzLnB1c2goXCJIQVNfQkFTRV9DT0xPUl9NQVAgMVwiKVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlKSB7XG4gICAgICBpZiAoIW1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZS52YWxpZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgICBpZiAoKDxhbnk+bWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKFwiSEFTX0VNSVNTSVZFX1VWX1RSQU5TRk9STSAxXCIpO1xuICAgICAgfVxuICAgICAgZmVhdHVyZXMucHVzaChcIkhBU19FTUlTU0lWRV9NQVAgMVwiKVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWwubm9ybWFsVGV4dHVyZSkge1xuICAgICAgaWYgKCFtYXRlcmlhbC5ub3JtYWxUZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIGlmICgoPGFueT5tYXRlcmlhbC5ub3JtYWxUZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKFwiSEFTX05PUk1BTF9VVl9UUkFOU0ZPUk0gMVwiKTtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmVzLnB1c2goXCJIQVNfTk9STUFMX01BUCAxXCIpXG4gICAgfVxuICAgIGlmIChtYXRlcmlhbC5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpIHtcbiAgICAgIGlmICghbWF0ZXJpYWwubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIGlmICgoPGFueT5tYXRlcmlhbC5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpLnV2VHJhbnNmb3JtKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCJIQVNfTUVUQUxMSUNST1VHSE5FU1NfVVZfVFJBTlNGT1JNIDFcIik7XG4gICAgICB9XG4gICAgICBmZWF0dXJlcy5wdXNoKFwiSEFTX01FVEFMTElDX1JPVUdITkVTU19NQVAgMVwiKVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZSkge1xuICAgICAgaWYgKCFtYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIGlmICgoPGFueT5tYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKFwiSEFTX09DQ0xVU0lPTl9VVl9UUkFOU0ZPUk0gMVwiKTtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmVzLnB1c2goXCJIQVNfT0NDTFVTSU9OX01BUCAxXCIpXG4gICAgfVxuICAgIHN3aXRjaCAobWF0ZXJpYWwuYWxwaGFNb2RlKSB7XG4gICAgICBjYXNlIFN0YW5kYXJkTWF0ZXJpYWxBbHBoYU1vZGUub3BhcXVlOiB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCJBTFBIQU1PREVfT1BBUVVFIDFcIilcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgU3RhbmRhcmRNYXRlcmlhbEFscGhhTW9kZS5tYXNrOiB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCJBTFBIQU1PREVfTUFTSyAxXCIpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbC5kZWJ1Z01vZGUpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2goXCJERUJVR19PVVRQVVQgMVwiKVxuICAgIH1cbiAgICBzd2l0Y2ggKG1hdGVyaWFsLmRlYnVnTW9kZSkge1xuICAgICAgY2FzZSBTdGFuZGFyZE1hdGVyaWFsRGVidWdNb2RlLmFscGhhOiB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCJERUJVR19BTFBIQSAxXCIpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlIFN0YW5kYXJkTWF0ZXJpYWxEZWJ1Z01vZGUuZW1pc3NpdmU6IHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChcIkRFQlVHX0VNSVNTSVZFIDFcIilcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgU3RhbmRhcmRNYXRlcmlhbERlYnVnTW9kZS5mMDoge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKFwiREVCVUdfRjAgMVwiKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBTdGFuZGFyZE1hdGVyaWFsRGVidWdNb2RlLm1ldGFsbGljOiB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCJERUJVR19NRVRBTExJQyAxXCIpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlIFN0YW5kYXJkTWF0ZXJpYWxEZWJ1Z01vZGUubm9ybWFsOiB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goXCJERUJVR19OT1JNQUwgMVwiKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBTdGFuZGFyZE1hdGVyaWFsRGVidWdNb2RlLm9jY2x1c2lvbjoge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKFwiREVCVUdfT0NDTFVTSU9OIDFcIilcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgU3RhbmRhcmRNYXRlcmlhbERlYnVnTW9kZS5yb3VnaG5lc3M6IHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChcIkRFQlVHX1JPVUdITkVTUyAxXCIpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlc1xuICB9XG5cbiAgZnVuY3Rpb24gaXNKb2ludE1hdHJpeFRleHR1cmVSZXF1aXJlZChqb2ludHNDb3VudDogbnVtYmVyLCByZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIGxldCB1bmlmb3Jtc1JlcXVpcmVkRm9yTW9zdEZlYXR1cmVzID0gMjVcbiAgICBsZXQgYXZhaWxhYmxlSm9pbnRVbmlmb3JtcyA9XG4gICAgICBQbGF0Zm9ybS5nZXRNYXhWZXJ0ZXhVbmlmb3JtVmVjdG9ycyhyZW5kZXJlcikgLSB1bmlmb3Jtc1JlcXVpcmVkRm9yTW9zdEZlYXR1cmVzXG4gICAgbGV0IHVuaWZvcm1zUmVxdWlyZWRQZXJKb2ludCA9IDhcbiAgICByZXR1cm4gam9pbnRzQ291bnQgPiBNYXRoLmZsb29yKGF2YWlsYWJsZUpvaW50VW5pZm9ybXMgLyB1bmlmb3Jtc1JlcXVpcmVkUGVySm9pbnQpXG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gaGFzU2tpbm5pbmdUZXh0dXJlRmVhdHVyZShmZWF0dXJlczogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gZmVhdHVyZXMuaW5jbHVkZXMoXCJVU0VfU0tJTk5JTkdfVEVYVFVSRSAxXCIpXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgQnVmZmVyUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcGl4aS9idWZmZXItcmVzb3VyY2VcIlxuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tIFwiLi4vLi4vcGxhdGZvcm1cIlxuXG5leHBvcnQgY2xhc3MgU3RhbmRhcmRNYXRlcmlhbE1hdHJpeFRleHR1cmUgZXh0ZW5kcyBQSVhJLlRleHR1cmUge1xuICBwcml2YXRlIF9idWZmZXI6IEZsb2F0MzJBcnJheVxuXG4gIHN0YXRpYyBpc1N1cHBvcnRlZChyZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIHJldHVybiBQbGF0Zm9ybS5pc0Zsb2F0VGV4dHVyZVN1cHBvcnRlZChyZW5kZXJlcilcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG1hdHJpeENvdW50OiBudW1iZXIpIHtcbiAgICBsZXQgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShtYXRyaXhDb3VudCAqIDE2KVxuICAgIGxldCByZXNvdXJjZSA9IG5ldyBCdWZmZXJSZXNvdXJjZShidWZmZXIsIHsgd2lkdGg6IDQsIGhlaWdodDogbWF0cml4Q291bnQgfSlcbiAgICBzdXBlcihuZXcgUElYSS5CYXNlVGV4dHVyZShyZXNvdXJjZSwge1xuICAgICAgbWlwbWFwOiBQSVhJLk1JUE1BUF9NT0RFUy5PRkYsXG4gICAgICB3cmFwTW9kZTogUElYSS5XUkFQX01PREVTLkNMQU1QLFxuICAgICAgc2NhbGVNb2RlOiBQSVhJLlNDQUxFX01PREVTLk5FQVJFU1QsXG4gICAgICBmb3JtYXQ6IFBJWEkuRk9STUFUUy5SR0JBLFxuICAgICAgdHlwZTogUElYSS5UWVBFUy5GTE9BVCxcbiAgICAgIGFscGhhTW9kZTogUElYSS5BTFBIQV9NT0RFUy5OT19QUkVNVUxUSVBMSUVEX0FMUEhBXG4gICAgfSkpXG4gICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyXG4gIH1cblxuICB1cGRhdGVCdWZmZXIoYnVmZmVyOiBGbG9hdDMyQXJyYXkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm9ybWFsaXplIHRoZSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxIGJlY2F1c2UgdGV4dHVyZXMgY2FuJ3QgaGF2ZSBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgIHRoaXMuX2J1ZmZlcltpXSA9IChidWZmZXJbaV0gKyAxKSAvIDJcbiAgICB9XG4gICAgdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZS51cGRhdGUoKVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuLi8uLi9tZXNoL21lc2hcIlxuaW1wb3J0IHsgU3RhbmRhcmRNYXRlcmlhbE1hdHJpeFRleHR1cmUgfSBmcm9tIFwiLi9zdGFuZGFyZC1tYXRlcmlhbC1tYXRyaXgtdGV4dHVyZVwiXG5cbmV4cG9ydCBjbGFzcyBTdGFuZGFyZE1hdGVyaWFsU2tpblVuaWZvcm1zIHtcbiAgcHJpdmF0ZSBfam9pbnRNYXRyaXhUZXh0dXJlPzogU3RhbmRhcmRNYXRlcmlhbE1hdHJpeFRleHR1cmVcbiAgcHJpdmF0ZSBfam9pbnROb3JtYWxUZXh0dXJlPzogU3RhbmRhcmRNYXRlcmlhbE1hdHJpeFRleHR1cmVcblxuICBlbmFibGVKb2ludE1hdHJpeFRleHR1cmVzKGpvaW50c0NvdW50OiBudW1iZXIpIHtcbiAgICBpZiAoIXRoaXMuX2pvaW50TWF0cml4VGV4dHVyZSkge1xuICAgICAgdGhpcy5fam9pbnRNYXRyaXhUZXh0dXJlID0gbmV3IFN0YW5kYXJkTWF0ZXJpYWxNYXRyaXhUZXh0dXJlKGpvaW50c0NvdW50KVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2pvaW50Tm9ybWFsVGV4dHVyZSkge1xuICAgICAgdGhpcy5fam9pbnROb3JtYWxUZXh0dXJlID0gbmV3IFN0YW5kYXJkTWF0ZXJpYWxNYXRyaXhUZXh0dXJlKGpvaW50c0NvdW50KVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fam9pbnROb3JtYWxUZXh0dXJlPy5kZXN0cm95KHRydWUpXG4gICAgdGhpcy5fam9pbnRNYXRyaXhUZXh0dXJlPy5kZXN0cm95KHRydWUpXG4gIH1cblxuICB1cGRhdGUobWVzaDogTWVzaDNELCBzaGFkZXI6IFBJWEkuU2hhZGVyKSB7XG4gICAgaWYgKCFtZXNoLnNraW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsZXQgeyBqb2ludFZlcnRleE1hdHJpY2VzLCBqb2ludE5vcm1hbE1hdHJpY2VzIH0gPSBtZXNoLnNraW4uY2FsY3VsYXRlSm9pbnRNYXRyaWNlcygpXG4gICAgaWYgKHRoaXMuX2pvaW50TWF0cml4VGV4dHVyZSkge1xuICAgICAgdGhpcy5fam9pbnRNYXRyaXhUZXh0dXJlLnVwZGF0ZUJ1ZmZlcihqb2ludFZlcnRleE1hdHJpY2VzKVxuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfam9pbnRNYXRyaXhTYW1wbGVyID0gdGhpcy5fam9pbnRNYXRyaXhUZXh0dXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51X2pvaW50TWF0cml4ID0gam9pbnRWZXJ0ZXhNYXRyaWNlc1xuICAgIH1cbiAgICBpZiAodGhpcy5fam9pbnROb3JtYWxUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9qb2ludE5vcm1hbFRleHR1cmUudXBkYXRlQnVmZmVyKGpvaW50Tm9ybWFsTWF0cmljZXMpXG4gICAgICBzaGFkZXIudW5pZm9ybXMudV9qb2ludE5vcm1hbE1hdHJpeFNhbXBsZXIgPSB0aGlzLl9qb2ludE5vcm1hbFRleHR1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfam9pbnROb3JtYWxNYXRyaXggPSBqb2ludE5vcm1hbE1hdHJpY2VzXG4gICAgfVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IExpZ2h0VHlwZSB9IGZyb20gXCIuLi8uLi9saWdodGluZy9saWdodC10eXBlXCJcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWxGZWF0dXJlU2V0IH0gZnJvbSBcIi4vc3RhbmRhcmQtbWF0ZXJpYWwtZmVhdHVyZS1zZXRcIlxuaW1wb3J0IHsgU3RhbmRhcmRTaGFkZXIgfSBmcm9tIFwiLi9zdGFuZGFyZC1zaGFkZXJcIlxuaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxcIlxuaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSBcIi4uLy4uL2NhbWVyYS9jYW1lcmFcIlxuaW1wb3J0IHsgZ2xURk1hdGVyaWFsIH0gZnJvbSBcIi4uLy4uL2dsdGYvZ2x0Zi1tYXRlcmlhbFwiXG5pbXBvcnQgeyBMaWdodGluZ0Vudmlyb25tZW50IH0gZnJvbSBcIi4uLy4uL2xpZ2h0aW5nL2xpZ2h0aW5nLWVudmlyb25tZW50XCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuLi8uLi9tZXNoL21lc2hcIlxuaW1wb3J0IHsgU3RhbmRhcmRNYXRlcmlhbEFscGhhTW9kZSB9IGZyb20gXCIuL3N0YW5kYXJkLW1hdGVyaWFsLWFscGhhLW1vZGVcIlxuaW1wb3J0IHsgU3RhbmRhcmRNYXRlcmlhbERlYnVnTW9kZSB9IGZyb20gXCIuL3N0YW5kYXJkLW1hdGVyaWFsLWRlYnVnLW1vZGVcIlxuaW1wb3J0IHsgU2hhZG93Q2FzdGluZ0xpZ2h0IH0gZnJvbSBcIi4uLy4uL3NoYWRvdy9zaGFkb3ctY2FzdGluZy1saWdodFwiXG5pbXBvcnQgeyBTdGFuZGFyZE1hdGVyaWFsU2tpblVuaWZvcm1zIH0gZnJvbSBcIi4vc3RhbmRhcmQtbWF0ZXJpYWwtc2tpbi11bmlmb3Jtc1wiXG5pbXBvcnQgeyBNYXRlcmlhbFJlbmRlclNvcnRUeXBlIH0gZnJvbSBcIi4uL21hdGVyaWFsLXJlbmRlci1zb3J0LXR5cGVcIlxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiLi4vLi4vY29sb3JcIlxuaW1wb3J0IHsgSW5zdGFuY2VkU3RhbmRhcmRNYXRlcmlhbCB9IGZyb20gXCIuL2luc3RhbmNlZC1zdGFuZGFyZC1tYXRlcmlhbFwiXG5cbmNvbnN0IHNoYWRlcnM6IHsgW2ZlYXR1cmVzOiBzdHJpbmddOiBTdGFuZGFyZFNoYWRlciB9ID0ge31cblxuLyoqXG4gKiBUaGUgc3RhbmRhcmQgbWF0ZXJpYWwgaXMgdXNpbmcgUGh5c2ljYWxseS1CYXNlZCBSZW5kZXJpbmcgKFBCUikgd2hpY2ggbWFrZXMgXG4gKiBpdCBzdWl0YWJsZSB0byByZXByZXNlbnQgYSB3aWRlIHJhbmdlIG9mIGRpZmZlcmVudCBzdXJmYWNlcy4gSXQncyB0aGUgZGVmYXVsdCBcbiAqIG1hdGVyaWFsIHdoZW4gbG9hZGluZyBtb2RlbHMgZnJvbSBmaWxlLlxuICovXG5leHBvcnQgY2xhc3MgU3RhbmRhcmRNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcbiAgcHJpdmF0ZSBfbGlnaHRpbmdFbnZpcm9ubWVudD86IExpZ2h0aW5nRW52aXJvbm1lbnRcbiAgcHJpdmF0ZSBfdW5saXQgPSBmYWxzZVxuICBwcml2YXRlIF9hbHBoYU1vZGUgPSBTdGFuZGFyZE1hdGVyaWFsQWxwaGFNb2RlLm9wYXF1ZVxuICBwcml2YXRlIF9kZWJ1Z01vZGU/OiBTdGFuZGFyZE1hdGVyaWFsRGVidWdNb2RlXG4gIHByaXZhdGUgX2Jhc2VDb2xvclRleHR1cmU/OiBQSVhJLlRleHR1cmVcbiAgcHJpdmF0ZSBfYmFzZUNvbG9yID0gbmV3IEZsb2F0MzJBcnJheSg0KVxuICBwcml2YXRlIF9ub3JtYWxUZXh0dXJlPzogUElYSS5UZXh0dXJlXG4gIHByaXZhdGUgX29jY2x1c2lvblRleHR1cmU/OiBQSVhJLlRleHR1cmVcbiAgcHJpdmF0ZSBfZW1pc3NpdmVUZXh0dXJlPzogUElYSS5UZXh0dXJlXG4gIHByaXZhdGUgX21ldGFsbGljUm91Z2huZXNzVGV4dHVyZT86IFBJWEkuVGV4dHVyZVxuICBwcml2YXRlIF9zaGFkb3dDYXN0aW5nTGlnaHQ/OiBTaGFkb3dDYXN0aW5nTGlnaHRcbiAgcHJpdmF0ZSBfbGlnaHRzQ291bnQ/OiBudW1iZXJcbiAgcHJpdmF0ZSBfaW5zdGFuY2luZ0VuYWJsZWQgPSBmYWxzZVxuXG4gIHByaXZhdGUgX3NraW5Vbmlmb3JtcyA9IG5ldyBTdGFuZGFyZE1hdGVyaWFsU2tpblVuaWZvcm1zKClcblxuICAvKiogVGhlIHJvdWdobmVzcyBvZiB0aGUgbWF0ZXJpYWwuICovXG4gIHJvdWdobmVzcyA9IDFcblxuICAvKiogVGhlIG1ldGFsbmVzcyBvZiB0aGUgbWF0ZXJpYWwuICovXG4gIG1ldGFsbGljID0gMVxuXG4gIC8qKiBUaGUgYmFzZSBjb2xvciBvZiB0aGUgbWF0ZXJpYWwuICovXG4gIGJhc2VDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKVxuXG4gIC8qKiBUaGUgY3V0b2ZmIHRocmVzaG9sZCB3aGVuIGFscGhhIG1vZGUgaXMgc2V0IHRvIFwibWFza1wiLiAqL1xuICBhbHBoYUN1dG9mZiA9IDAuNVxuXG4gIC8qKiBUaGUgZW1pc3NpdmUgY29sb3Igb2YgdGhlIG1hdGVyaWFsLiAqL1xuICBlbWlzc2l2ZSA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKVxuXG4gIC8qKiBUaGUgZXhwb3N1cmUgKGJyaWdodG5lc3MpIG9mIHRoZSBtYXRlcmlhbC4gKi9cbiAgZXhwb3N1cmUgPSAzXG5cbiAgLyoqIFRoZSBiYXNlIGNvbG9yIHRleHR1cmUuICovXG4gIGdldCBiYXNlQ29sb3JUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlQ29sb3JUZXh0dXJlXG4gIH1cblxuICBzZXQgYmFzZUNvbG9yVGV4dHVyZSh2YWx1ZTogUElYSS5UZXh0dXJlIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9iYXNlQ29sb3JUZXh0dXJlKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVTaGFkZXIoKVxuICAgICAgdGhpcy5fYmFzZUNvbG9yVGV4dHVyZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqIFRoZSBtZXRhbGxpYy1yb3VnaG5lc3MgdGV4dHVyZS4gKi9cbiAgZ2V0IG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlXG4gIH1cblxuICBzZXQgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKHZhbHVlOiBQSVhJLlRleHR1cmUgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX21ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlU2hhZGVyKClcbiAgICAgIHRoaXMuX21ldGFsbGljUm91Z2huZXNzVGV4dHVyZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqIFRoZSBub3JtYWwgbWFwIHRleHR1cmUuICovXG4gIGdldCBub3JtYWxUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl9ub3JtYWxUZXh0dXJlXG4gIH1cblxuICBzZXQgbm9ybWFsVGV4dHVyZSh2YWx1ZTogUElYSS5UZXh0dXJlIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9ub3JtYWxUZXh0dXJlKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVTaGFkZXIoKVxuICAgICAgdGhpcy5fbm9ybWFsVGV4dHVyZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqIFRoZSBvY2NsdXNpb24gbWFwIHRleHR1cmUuICovXG4gIGdldCBvY2NsdXNpb25UZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl9vY2NsdXNpb25UZXh0dXJlXG4gIH1cblxuICBzZXQgb2NjbHVzaW9uVGV4dHVyZSh2YWx1ZTogUElYSS5UZXh0dXJlIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vY2NsdXNpb25UZXh0dXJlKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVTaGFkZXIoKVxuICAgICAgdGhpcy5fb2NjbHVzaW9uVGV4dHVyZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqIFRoZSBlbWlzc2l2ZSBtYXAgdGV4dHVyZS4gKi9cbiAgZ2V0IGVtaXNzaXZlVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pc3NpdmVUZXh0dXJlXG4gIH1cblxuICBzZXQgZW1pc3NpdmVUZXh0dXJlKHZhbHVlOiBQSVhJLlRleHR1cmUgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2VtaXNzaXZlVGV4dHVyZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlU2hhZGVyKClcbiAgICAgIHRoaXMuX2VtaXNzaXZlVGV4dHVyZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqIFRoZSBhbHBoYSByZW5kZXJpbmcgbW9kZSBvZiB0aGUgbWF0ZXJpYWwuICovXG4gIGdldCBhbHBoYU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FscGhhTW9kZVxuICB9XG5cbiAgc2V0IGFscGhhTW9kZSh2YWx1ZTogU3RhbmRhcmRNYXRlcmlhbEFscGhhTW9kZSkge1xuICAgIGlmICh0aGlzLl9hbHBoYU1vZGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9hbHBoYU1vZGUgPSB2YWx1ZVxuICAgICAgdGhpcy5pbnZhbGlkYXRlU2hhZGVyKClcbiAgICB9XG4gIH1cblxuICAvKiogVGhlIHNoYWRvdyBjYXN0aW5nIGxpZ2h0IG9mIHRoZSBtYXRlcmlhbC4gKi9cbiAgZ2V0IHNoYWRvd0Nhc3RpbmdMaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hhZG93Q2FzdGluZ0xpZ2h0XG4gIH1cblxuICBzZXQgc2hhZG93Q2FzdGluZ0xpZ2h0KHZhbHVlOiBTaGFkb3dDYXN0aW5nTGlnaHQgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3NoYWRvd0Nhc3RpbmdMaWdodCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlU2hhZGVyKClcbiAgICAgIHRoaXMuX3NoYWRvd0Nhc3RpbmdMaWdodCA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqIFRoZSBkZWJ1ZyByZW5kZXJpbmcgbW9kZSBvZiB0aGUgbWF0ZXJpYWwuICovXG4gIGdldCBkZWJ1Z01vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlYnVnTW9kZVxuICB9XG5cbiAgc2V0IGRlYnVnTW9kZSh2YWx1ZTogU3RhbmRhcmRNYXRlcmlhbERlYnVnTW9kZSB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLl9kZWJ1Z01vZGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVTaGFkZXIoKVxuICAgICAgdGhpcy5fZGVidWdNb2RlID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhbWVyYSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgbWVzaC4gSWYgdGhpcyB2YWx1ZSBpcyBub3Qgc2V0LCB0aGUgbWFpbiBcbiAgICogY2FtZXJhIHdpbGwgYmUgdXNlZCBieSBkZWZhdWx0LlxuICAgKi9cbiAgY2FtZXJhPzogQ2FtZXJhXG5cbiAgLyoqXG4gICAqIExpZ2h0aW5nIGVudmlyb25tZW50IHVzZWQgd2hlbiByZW5kZXJpbmcgYSBtZXNoLiBJZiB0aGlzIHZhbHVlIGlzIG5vdCBzZXQsIFxuICAgKiB0aGUgbWFpbiBsaWdodGluZyBlbnZpcm9ubWVudCB3aWxsIGJlIHVzZWQgYnkgZGVmYXVsdC5cbiAgICovXG4gIGdldCBsaWdodGluZ0Vudmlyb25tZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9saWdodGluZ0Vudmlyb25tZW50XG4gIH1cblxuICBzZXQgbGlnaHRpbmdFbnZpcm9ubWVudCh2YWx1ZTogTGlnaHRpbmdFbnZpcm9ubWVudCB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fbGlnaHRpbmdFbnZpcm9ubWVudCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlU2hhZGVyKClcbiAgICAgIHRoaXMuX2xpZ2h0aW5nRW52aXJvbm1lbnQgPSB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBtYXRlcmlhbCBpcyB1bmxpdC4gSWYgdGhpcyB2YWx1ZSBpZiBzZXQgdG8gdHJ1ZSwgXG4gICAqIGFsbCBsaWdodGluZyBpcyBkaXNhYmxlZCBhbmQgb25seSB0aGUgYmFzZSBjb2xvciB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBnZXQgdW5saXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VubGl0XG4gIH1cblxuICBzZXQgdW5saXQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5fdW5saXQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl91bmxpdCA9IHZhbHVlXG4gICAgICB0aGlzLmludmFsaWRhdGVTaGFkZXIoKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fYmFzZUNvbG9yVGV4dHVyZT8uZGVzdHJveSgpXG4gICAgdGhpcy5fbm9ybWFsVGV4dHVyZT8uZGVzdHJveSgpXG4gICAgdGhpcy5fZW1pc3NpdmVUZXh0dXJlPy5kZXN0cm95KClcbiAgICB0aGlzLl9vY2NsdXNpb25UZXh0dXJlPy5kZXN0cm95KClcbiAgICB0aGlzLl9tZXRhbGxpY1JvdWdobmVzc1RleHR1cmU/LmRlc3Ryb3koKVxuICAgIHRoaXMuX3NraW5Vbmlmb3Jtcy5kZXN0cm95KClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZhbGlkYXRlcyB0aGUgc2hhZGVyIHNvIGl0IGNhbiBiZSByZWJ1aWx0IHdpdGggdGhlIGN1cnJlbnQgZmVhdHVyZXMuXG4gICAqL1xuICBpbnZhbGlkYXRlU2hhZGVyKCkge1xuICAgIHRoaXMuX3NoYWRlciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdGFuZGFyZCBtYXRlcmlhbCBmYWN0b3J5IHdoaWNoIGNhbiBiZSB1c2VkIHdoZW4gbG9hZGluZyBtb2RlbHMuXG4gICAqIEBwYXJhbSBwcm9wcyBQcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgbWF0ZXJpYWwgd2hlbiBjcmVhdGVkLlxuICAgKi9cbiAgc3RhdGljIGZhY3RvcnkocHJvcHMgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGU6IChzb3VyY2U6IHVua25vd24pID0+IHtcbiAgICAgICAgcmV0dXJuIDxTdGFuZGFyZE1hdGVyaWFsPk9iamVjdC5hc3NpZ24oU3RhbmRhcmRNYXRlcmlhbC5jcmVhdGUoc291cmNlKSwgcHJvcHMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3RhbmRhcmQgbWF0ZXJpYWwgZnJvbSB0aGUgc3BlY2lmaWVkIHNvdXJjZS5cbiAgICogQHBhcmFtIHNvdXJjZSBTb3VyY2UgZnJvbSB3aGljaCB0aGUgbWF0ZXJpYWwgaXMgY3JlYXRlZC5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoc291cmNlOiB1bmtub3duKSB7XG4gICAgbGV0IG1hdGVyaWFsID0gbmV3IFN0YW5kYXJkTWF0ZXJpYWwoKVxuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBnbFRGTWF0ZXJpYWwpIHtcbiAgICAgIG1hdGVyaWFsLmJhc2VDb2xvciA9IENvbG9yLmZyb20oc291cmNlLmJhc2VDb2xvcilcbiAgICAgIG1hdGVyaWFsLmJhc2VDb2xvclRleHR1cmUgPSBzb3VyY2UuYmFzZUNvbG9yVGV4dHVyZT8uY2xvbmUoKVxuICAgICAgbWF0ZXJpYWwubWV0YWxsaWMgPSBzb3VyY2UubWV0YWxsaWNcbiAgICAgIG1hdGVyaWFsLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3NcbiAgICAgIG1hdGVyaWFsLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSA9IHNvdXJjZS5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmU/LmNsb25lKClcbiAgICAgIHN3aXRjaCAoc291cmNlLmFscGhhTW9kZSkge1xuICAgICAgICBjYXNlIFwiQkxFTkRcIjoge1xuICAgICAgICAgIG1hdGVyaWFsLmFscGhhTW9kZSA9IFN0YW5kYXJkTWF0ZXJpYWxBbHBoYU1vZGUuYmxlbmRcbiAgICAgICAgICBtYXRlcmlhbC5yZW5kZXJTb3J0VHlwZSA9IE1hdGVyaWFsUmVuZGVyU29ydFR5cGUudHJhbnNwYXJlbnRcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJNQVNLXCI6IHtcbiAgICAgICAgICBtYXRlcmlhbC5hbHBoYU1vZGUgPSBTdGFuZGFyZE1hdGVyaWFsQWxwaGFNb2RlLm1hc2tcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPUEFRVUVcIjoge1xuICAgICAgICAgIG1hdGVyaWFsLmFscGhhTW9kZSA9IFN0YW5kYXJkTWF0ZXJpYWxBbHBoYU1vZGUub3BhcXVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWF0ZXJpYWwudW5saXQgPSBzb3VyY2UudW5saXRcbiAgICAgIG1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZSA9IHNvdXJjZS5lbWlzc2l2ZVRleHR1cmU/LmNsb25lKClcbiAgICAgIG1hdGVyaWFsLmVtaXNzaXZlID0gQ29sb3IuZnJvbShzb3VyY2UuZW1pc3NpdmUpXG4gICAgICBtYXRlcmlhbC5ub3JtYWxUZXh0dXJlID0gc291cmNlLm5vcm1hbFRleHR1cmU/LmNsb25lKClcbiAgICAgIG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUgPSBzb3VyY2Uub2NjbHVzaW9uVGV4dHVyZT8uY2xvbmUoKVxuICAgICAgbWF0ZXJpYWwuZG91YmxlU2lkZWQgPSBzb3VyY2UuZG91YmxlU2lkZWRcbiAgICAgIG1hdGVyaWFsLmFscGhhQ3V0b2ZmID0gc291cmNlLmFscGhhQ3V0b2ZmXG4gICAgICBpZiAoc291cmNlLmJhc2VDb2xvclRleHR1cmUgJiYgKDxhbnk+c291cmNlLmJhc2VDb2xvclRleHR1cmUpLnV2VHJhbnNmb3JtKSB7XG4gICAgICAgICg8YW55Pm1hdGVyaWFsLmJhc2VDb2xvclRleHR1cmUpLnV2VHJhbnNmb3JtID0gKDxhbnk+c291cmNlLmJhc2VDb2xvclRleHR1cmUpLnV2VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZS5ub3JtYWxUZXh0dXJlICYmICg8YW55PnNvdXJjZS5ub3JtYWxUZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICAoPGFueT5tYXRlcmlhbC5ub3JtYWxUZXh0dXJlKS51dlRyYW5zZm9ybSA9ICg8YW55PnNvdXJjZS5ub3JtYWxUZXh0dXJlKS51dlRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UuZW1pc3NpdmVUZXh0dXJlICYmICg8YW55PnNvdXJjZS5lbWlzc2l2ZVRleHR1cmUpLnV2VHJhbnNmb3JtKSB7XG4gICAgICAgICg8YW55Pm1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZSkudXZUcmFuc2Zvcm0gPSAoPGFueT5zb3VyY2UuZW1pc3NpdmVUZXh0dXJlKS51dlRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2Uub2NjbHVzaW9uVGV4dHVyZSAmJiAoPGFueT5zb3VyY2Uub2NjbHVzaW9uVGV4dHVyZSkudXZUcmFuc2Zvcm0pIHtcbiAgICAgICAgKDxhbnk+bWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZSkudXZUcmFuc2Zvcm0gPSAoPGFueT5zb3VyY2Uub2NjbHVzaW9uVGV4dHVyZSkudXZUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSAmJiAoPGFueT5zb3VyY2UubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICAoPGFueT5tYXRlcmlhbC5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpLnV2VHJhbnNmb3JtID0gKDxhbnk+c291cmNlLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkudXZUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRlcmlhbFxuICB9XG5cbiAgcmVuZGVyKG1lc2g6IE1lc2gzRCwgcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNpbmdFbmFibGVkICYmIG1lc2guaW5zdGFuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEludmFsaWRhdGUgc2hhZGVyIHdoZW4gaW5zdGFjaW5nIHdhcyBlbmFibGVkLlxuICAgICAgdGhpcy5pbnZhbGlkYXRlU2hhZGVyKClcbiAgICAgIHRoaXMuX2luc3RhbmNpbmdFbmFibGVkID0gbWVzaC5pbnN0YW5jZXMubGVuZ3RoID4gMFxuICAgIH1cbiAgICBsZXQgbGlnaHRpbmdFbnZpcm9ubWVudCA9IHRoaXMubGlnaHRpbmdFbnZpcm9ubWVudCB8fCBMaWdodGluZ0Vudmlyb25tZW50Lm1haW5cbiAgICBpZiAobGlnaHRpbmdFbnZpcm9ubWVudC5saWdodHMubGVuZ3RoICE9PSB0aGlzLl9saWdodHNDb3VudCkge1xuICAgICAgLy8gSW52YWxpZGF0ZSBzaGFkZXIgd2hlbiB0aGUgbnVtYmVyIG9mIHB1bmN0dWFsIGxpZ2h0cyBoYXMgY2hhbmdlZC5cbiAgICAgIHRoaXMuaW52YWxpZGF0ZVNoYWRlcigpXG4gICAgICB0aGlzLl9saWdodHNDb3VudCA9IGxpZ2h0aW5nRW52aXJvbm1lbnQubGlnaHRzLmxlbmd0aFxuICAgIH1cbiAgICBzdXBlci5yZW5kZXIobWVzaCwgcmVuZGVyZXIpXG4gIH1cblxuICBnZXQgaXNJbnN0YW5jaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjcmVhdGVJbnN0YW5jZSgpIHtcbiAgICByZXR1cm4gbmV3IEluc3RhbmNlZFN0YW5kYXJkTWF0ZXJpYWwodGhpcylcbiAgfVxuXG4gIGNyZWF0ZVNoYWRlcihtZXNoOiBNZXNoM0QsIHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgaWYgKHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICBsZXQgZXh0ZW5zaW9ucyA9IFtcIkVYVF9zaGFkZXJfdGV4dHVyZV9sb2RcIiwgXCJPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcIl1cbiAgICAgIGZvciAobGV0IGV4dCBvZiBleHRlbnNpb25zKSB7XG4gICAgICAgIGlmICghcmVuZGVyZXIuZ2wuZ2V0RXh0ZW5zaW9uKGV4dCkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFBJWEkzRDogRXh0ZW5zaW9uIFwiJHtleHR9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBjdXJyZW50IHBsYXRmb3JtLCB0aGUgbWF0ZXJpYWwgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LmApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxpZ2h0aW5nRW52aXJvbm1lbnQgPSB0aGlzLmxpZ2h0aW5nRW52aXJvbm1lbnQgfHwgTGlnaHRpbmdFbnZpcm9ubWVudC5tYWluXG4gICAgbGV0IGZlYXR1cmVzID0gU3RhbmRhcmRNYXRlcmlhbEZlYXR1cmVTZXQuYnVpbGQocmVuZGVyZXIsIG1lc2gsIG1lc2guZ2VvbWV0cnksIHRoaXMsIGxpZ2h0aW5nRW52aXJvbm1lbnQpXG4gICAgaWYgKCFmZWF0dXJlcykge1xuICAgICAgLy8gVGhlIHNoYWRlciBmZWF0dXJlcyBjb3VsZG4ndCBiZSBidWlsdCwgc29tZSByZXNvdXJjZXMgbWF5IHN0aWxsIGJlIFxuICAgICAgLy8gbG9hZGluZy4gRG9uJ3Qgd29ycnksIHdlIHdpbGwgcmV0cnkgY3JlYXRpbmcgc2hhZGVyIGF0IG5leHQgcmVuZGVyLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICBpZiAobWVzaC5za2luICYmIFN0YW5kYXJkTWF0ZXJpYWxGZWF0dXJlU2V0Lmhhc1NraW5uaW5nVGV4dHVyZUZlYXR1cmUoZmVhdHVyZXMpKSB7XG4gICAgICB0aGlzLl9za2luVW5pZm9ybXMuZW5hYmxlSm9pbnRNYXRyaXhUZXh0dXJlcyhtZXNoLnNraW4uam9pbnRzLmxlbmd0aClcbiAgICB9XG4gICAgbGV0IGNoZWNrc3VtID0gZmVhdHVyZXMuam9pbihcIixcIilcbiAgICBpZiAoIXNoYWRlcnNbY2hlY2tzdW1dKSB7XG4gICAgICBzaGFkZXJzW2NoZWNrc3VtXSA9IFN0YW5kYXJkU2hhZGVyLmJ1aWxkKHJlbmRlcmVyLCBmZWF0dXJlcylcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcnNbY2hlY2tzdW1dXG4gIH1cblxuICB1cGRhdGVVbmlmb3JtcyhtZXNoOiBNZXNoM0QsIHNoYWRlcjogUElYSS5TaGFkZXIpIHtcbiAgICB0aGlzLl9iYXNlQ29sb3Iuc2V0KHRoaXMuYmFzZUNvbG9yLnJnYilcbiAgICB0aGlzLl9iYXNlQ29sb3JbM10gPSB0aGlzLmJhc2VDb2xvci5hICogbWVzaC53b3JsZEFscGhhXG4gICAgbGV0IGNhbWVyYSA9IHRoaXMuY2FtZXJhIHx8IENhbWVyYS5tYWluXG4gICAgaWYgKG1lc2guc2tpbikge1xuICAgICAgdGhpcy5fc2tpblVuaWZvcm1zLnVwZGF0ZShtZXNoLCBzaGFkZXIpXG4gICAgfVxuICAgIHNoYWRlci51bmlmb3Jtcy51X0NhbWVyYSA9IGNhbWVyYS53b3JsZFRyYW5zZm9ybS5wb3NpdGlvblxuICAgIHNoYWRlci51bmlmb3Jtcy51X1ZpZXdQcm9qZWN0aW9uTWF0cml4ID0gY2FtZXJhLnZpZXdQcm9qZWN0aW9uXG4gICAgc2hhZGVyLnVuaWZvcm1zLnVfRXhwb3N1cmUgPSB0aGlzLmV4cG9zdXJlXG4gICAgc2hhZGVyLnVuaWZvcm1zLnVfTWV0YWxsaWNGYWN0b3IgPSB0aGlzLm1ldGFsbGljXG4gICAgc2hhZGVyLnVuaWZvcm1zLnVfUm91Z2huZXNzRmFjdG9yID0gdGhpcy5yb3VnaG5lc3NcbiAgICBzaGFkZXIudW5pZm9ybXMudV9CYXNlQ29sb3JGYWN0b3IgPSB0aGlzLl9iYXNlQ29sb3JcbiAgICBzaGFkZXIudW5pZm9ybXMudV9FbWlzc2l2ZUZhY3RvciA9IHRoaXMuZW1pc3NpdmUucmdiXG4gICAgc2hhZGVyLnVuaWZvcm1zLnVfTW9kZWxNYXRyaXggPSBtZXNoLndvcmxkVHJhbnNmb3JtLmFycmF5XG4gICAgc2hhZGVyLnVuaWZvcm1zLnVfTm9ybWFsTWF0cml4ID0gbWVzaC50cmFuc2Zvcm0ubm9ybWFsVHJhbnNmb3JtLmFycmF5XG4gICAgaWYgKHRoaXMuX3NoYWRvd0Nhc3RpbmdMaWdodCkge1xuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfU2hhZG93U2FtcGxlciA9IHRoaXMuX3NoYWRvd0Nhc3RpbmdMaWdodC5zaGFkb3dUZXh0dXJlXG4gICAgICBzaGFkZXIudW5pZm9ybXMudV9MaWdodFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5fc2hhZG93Q2FzdGluZ0xpZ2h0LmxpZ2h0Vmlld1Byb2plY3Rpb25cbiAgICB9XG4gICAgaWYgKHRoaXMuX2FscGhhTW9kZSA9PT0gU3RhbmRhcmRNYXRlcmlhbEFscGhhTW9kZS5tYXNrKSB7XG4gICAgICBzaGFkZXIudW5pZm9ybXMudV9BbHBoYUN1dG9mZiA9IHRoaXMuYWxwaGFDdXRvZmZcbiAgICB9XG4gICAgaWYgKG1lc2gubW9ycGhXZWlnaHRzKSB7XG4gICAgICBzaGFkZXIudW5pZm9ybXMudV9tb3JwaFdlaWdodHMgPSBtZXNoLm1vcnBoV2VpZ2h0c1xuICAgIH1cbiAgICBpZiAodGhpcy5iYXNlQ29sb3JUZXh0dXJlPy52YWxpZCkge1xuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfQmFzZUNvbG9yU2FtcGxlciA9IHRoaXMuYmFzZUNvbG9yVGV4dHVyZVxuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfQmFzZUNvbG9yVVZTZXQgPSAwXG4gICAgICBpZiAoKDxhbnk+dGhpcy5iYXNlQ29sb3JUZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICBzaGFkZXIudW5pZm9ybXMudV9CYXNlQ29sb3JVVlRyYW5zZm9ybSA9ICg8YW55PnRoaXMuYmFzZUNvbG9yVGV4dHVyZSkudXZUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBsaWdodGluZ0Vudmlyb25tZW50ID0gdGhpcy5saWdodGluZ0Vudmlyb25tZW50IHx8IExpZ2h0aW5nRW52aXJvbm1lbnQubWFpblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlnaHRpbmdFbnZpcm9ubWVudC5saWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBsaWdodCA9IGxpZ2h0aW5nRW52aXJvbm1lbnQubGlnaHRzW2ldXG4gICAgICBsZXQgdHlwZSA9IDBcbiAgICAgIHN3aXRjaCAobGlnaHQudHlwZSkge1xuICAgICAgICBjYXNlIExpZ2h0VHlwZS5wb2ludDogdHlwZSA9IDE7IGJyZWFrXG4gICAgICAgIGNhc2UgTGlnaHRUeXBlLmRpcmVjdGlvbmFsOiB0eXBlID0gMDsgYnJlYWtcbiAgICAgICAgY2FzZSBMaWdodFR5cGUuc3BvdDogdHlwZSA9IDI7IGJyZWFrXG4gICAgICAgIGNhc2UgTGlnaHRUeXBlLmFtYmllbnQ6IHR5cGUgPSAzOyBicmVha1xuICAgICAgfVxuICAgICAgc2hhZGVyLnVuaWZvcm1zW2B1X0xpZ2h0c1ske2l9XS50eXBlYF0gPSB0eXBlXG4gICAgICBzaGFkZXIudW5pZm9ybXNbYHVfTGlnaHRzWyR7aX1dLnBvc2l0aW9uYF0gPSBsaWdodC53b3JsZFRyYW5zZm9ybS5wb3NpdGlvblxuICAgICAgc2hhZGVyLnVuaWZvcm1zW2B1X0xpZ2h0c1ske2l9XS5kaXJlY3Rpb25gXSA9IGxpZ2h0LndvcmxkVHJhbnNmb3JtLmZvcndhcmRcbiAgICAgIHNoYWRlci51bmlmb3Jtc1tgdV9MaWdodHNbJHtpfV0ucmFuZ2VgXSA9IGxpZ2h0LnJhbmdlXG4gICAgICBzaGFkZXIudW5pZm9ybXNbYHVfTGlnaHRzWyR7aX1dLmNvbG9yYF0gPSBsaWdodC5jb2xvci5yZ2JcbiAgICAgIHNoYWRlci51bmlmb3Jtc1tgdV9MaWdodHNbJHtpfV0uaW50ZW5zaXR5YF0gPSBsaWdodC5pbnRlbnNpdHlcbiAgICAgIHNoYWRlci51bmlmb3Jtc1tgdV9MaWdodHNbJHtpfV0uaW5uZXJDb25lQ29zYF0gPSBNYXRoLmNvcyhsaWdodC5pbm5lckNvbmVBbmdsZSAqIFBJWEkuREVHX1RPX1JBRClcbiAgICAgIHNoYWRlci51bmlmb3Jtc1tgdV9MaWdodHNbJHtpfV0ub3V0ZXJDb25lQ29zYF0gPSBNYXRoLmNvcyhsaWdodC5vdXRlckNvbmVBbmdsZSAqIFBJWEkuREVHX1RPX1JBRClcbiAgICB9XG4gICAgbGV0IGltYWdlQmFzZWRMaWdodGluZyA9IGxpZ2h0aW5nRW52aXJvbm1lbnQuaW1hZ2VCYXNlZExpZ2h0aW5nXG4gICAgaWYgKGltYWdlQmFzZWRMaWdodGluZz8udmFsaWQpIHtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51X0RpZmZ1c2VFbnZTYW1wbGVyID0gaW1hZ2VCYXNlZExpZ2h0aW5nLmRpZmZ1c2VcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51X1NwZWN1bGFyRW52U2FtcGxlciA9IGltYWdlQmFzZWRMaWdodGluZy5zcGVjdWxhclxuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfYnJkZkxVVCA9IGltYWdlQmFzZWRMaWdodGluZy5icmRmXG4gICAgICBzaGFkZXIudW5pZm9ybXMudV9NaXBDb3VudCA9IGltYWdlQmFzZWRMaWdodGluZy5zcGVjdWxhci5sZXZlbHMgLSAxXG4gICAgfVxuICAgIGlmICh0aGlzLmVtaXNzaXZlVGV4dHVyZT8udmFsaWQpIHtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51X0VtaXNzaXZlU2FtcGxlciA9IHRoaXMuZW1pc3NpdmVUZXh0dXJlXG4gICAgICBzaGFkZXIudW5pZm9ybXMudV9FbWlzc2l2ZVVWU2V0ID0gMFxuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfRW1pc3NpdmVGYWN0b3IgPSBbMSwgMSwgMV1cbiAgICAgIGlmICgoPGFueT50aGlzLmVtaXNzaXZlVGV4dHVyZSkudXZUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfRW1pc3NpdmVVVlRyYW5zZm9ybSA9ICg8YW55PnRoaXMuZW1pc3NpdmVUZXh0dXJlKS51dlRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubm9ybWFsVGV4dHVyZT8udmFsaWQpIHtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51X05vcm1hbFNhbXBsZXIgPSB0aGlzLm5vcm1hbFRleHR1cmVcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51X05vcm1hbFNjYWxlID0gMVxuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfTm9ybWFsVVZTZXQgPSAwXG4gICAgICBpZiAoKDxhbnk+dGhpcy5ub3JtYWxUZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICBzaGFkZXIudW5pZm9ybXMudV9Ob3JtYWxVVlRyYW5zZm9ybSA9ICg8YW55PnRoaXMubm9ybWFsVGV4dHVyZSkudXZUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT8udmFsaWQpIHtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51X01ldGFsbGljUm91Z2huZXNzU2FtcGxlciA9IHRoaXMubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlXG4gICAgICBzaGFkZXIudW5pZm9ybXMudV9NZXRhbGxpY1JvdWdobmVzc1VWU2V0ID0gMFxuICAgICAgaWYgKCg8YW55PnRoaXMubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKS51dlRyYW5zZm9ybSkge1xuICAgICAgICBzaGFkZXIudW5pZm9ybXMudV9NZXRhbGxpY1JvdWdobmVzc1VWVHJhbnNmb3JtID0gKDxhbnk+dGhpcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpLnV2VHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vY2NsdXNpb25UZXh0dXJlPy52YWxpZCkge1xuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfT2NjbHVzaW9uU2FtcGxlciA9IHRoaXMub2NjbHVzaW9uVGV4dHVyZVxuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVfT2NjbHVzaW9uU3RyZW5ndGggPSAxXG4gICAgICBzaGFkZXIudW5pZm9ybXMudV9PY2NsdXNpb25VVlNldCA9IDBcbiAgICAgIGlmICgoPGFueT50aGlzLm9jY2x1c2lvblRleHR1cmUpLnV2VHJhbnNmb3JtKSB7XG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy51X09jY2x1c2lvblVWVHJhbnNmb3JtID0gKDxhbnk+dGhpcy5vY2NsdXNpb25UZXh0dXJlKS51dlRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgSW5zdGFuY2VkTWVzaDNEIH0gZnJvbSBcIi4uLy4uL21lc2gvaW5zdGFuY2VkLW1lc2hcIlxuaW1wb3J0IHsgSW5zdGFuY2VkU3RhbmRhcmRNYXRlcmlhbCB9IGZyb20gXCIuL2luc3RhbmNlZC1zdGFuZGFyZC1tYXRlcmlhbFwiXG5cbmV4cG9ydCBjbGFzcyBTdGFuZGFyZFNoYWRlckluc3RhbmNpbmcge1xuICBwcml2YXRlIF9tYXhJbnN0YW5jZXMgPSAyMDBcblxuICBwcml2YXRlIF9tb2RlbE1hdHJpeDogUElYSS5CdWZmZXJbXSA9IFtcbiAgICBuZXcgUElYSS5CdWZmZXIoKSwgbmV3IFBJWEkuQnVmZmVyKCksIG5ldyBQSVhJLkJ1ZmZlcigpLCBuZXcgUElYSS5CdWZmZXIoKVxuICBdXG4gIHByaXZhdGUgX25vcm1hbE1hdHJpeDogUElYSS5CdWZmZXJbXSA9IFtcbiAgICBuZXcgUElYSS5CdWZmZXIoKSwgbmV3IFBJWEkuQnVmZmVyKCksIG5ldyBQSVhJLkJ1ZmZlcigpLCBuZXcgUElYSS5CdWZmZXIoKVxuICBdXG4gIHByaXZhdGUgX2Jhc2VDb2xvciA9IG5ldyBQSVhJLkJ1ZmZlcigpXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5leHBhbmRCdWZmZXJzKHRoaXMuX21heEluc3RhbmNlcylcbiAgfVxuXG4gIGV4cGFuZEJ1ZmZlcnMoaW5zdGFuY2VDb3VudDogbnVtYmVyKSB7XG4gICAgd2hpbGUgKGluc3RhbmNlQ291bnQgPiB0aGlzLl9tYXhJbnN0YW5jZXMpIHtcbiAgICAgIHRoaXMuX21heEluc3RhbmNlcyArPSBNYXRoLmZsb29yKHRoaXMuX21heEluc3RhbmNlcyAqIDAuNSlcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHRoaXMuX21vZGVsTWF0cml4W2ldLnVwZGF0ZShuZXcgRmxvYXQzMkFycmF5KDQgKiB0aGlzLl9tYXhJbnN0YW5jZXMpKVxuICAgICAgdGhpcy5fbm9ybWFsTWF0cml4W2ldLnVwZGF0ZShuZXcgRmxvYXQzMkFycmF5KDQgKiB0aGlzLl9tYXhJbnN0YW5jZXMpKVxuICAgIH1cbiAgICB0aGlzLl9iYXNlQ29sb3IudXBkYXRlKG5ldyBGbG9hdDMyQXJyYXkoNCAqIHRoaXMuX21heEluc3RhbmNlcykpXG4gIH1cblxuICB1cGRhdGVCdWZmZXJzKGluc3RhbmNlczogSW5zdGFuY2VkTWVzaDNEW10pIHtcbiAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA+IHRoaXMuX21heEluc3RhbmNlcykge1xuICAgICAgdGhpcy5leHBhbmRCdWZmZXJzKGluc3RhbmNlcy5sZW5ndGgpXG4gICAgfVxuICAgIGxldCBidWZmZXJJbmRleCA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpbnN0YW5jZXNbaV0ud29ybGRWaXNpYmxlIHx8ICFpbnN0YW5jZXNbaV0ucmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsID0gaW5zdGFuY2VzW2ldLnRyYW5zZm9ybS5ub3JtYWxUcmFuc2Zvcm0uYXJyYXlcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICg8RmxvYXQzMkFycmF5PnRoaXMuX25vcm1hbE1hdHJpeFtqXS5kYXRhKVxuICAgICAgICAgIC5zZXQobm9ybWFsLnNsaWNlKGogKiA0LCBqICogNCArIDQpLCBidWZmZXJJbmRleCAqIDQpXG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGluc3RhbmNlc1tpXS53b3JsZFRyYW5zZm9ybS5hcnJheVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgKDxGbG9hdDMyQXJyYXk+dGhpcy5fbW9kZWxNYXRyaXhbal0uZGF0YSlcbiAgICAgICAgICAuc2V0KG1vZGVsLnNsaWNlKGogKiA0LCBqICogNCArIDQpLCBidWZmZXJJbmRleCAqIDQpXG4gICAgICB9XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IDxJbnN0YW5jZWRTdGFuZGFyZE1hdGVyaWFsPmluc3RhbmNlc1tpXS5tYXRlcmlhbDtcbiAgICAgICg8RmxvYXQzMkFycmF5PnRoaXMuX2Jhc2VDb2xvci5kYXRhKVxuICAgICAgICAuc2V0KG1hdGVyaWFsLmJhc2VDb2xvci5yZ2JhLCBidWZmZXJJbmRleCAqIDQpXG4gICAgICBidWZmZXJJbmRleCsrXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHRoaXMuX21vZGVsTWF0cml4W2ldLnVwZGF0ZSgpXG4gICAgICB0aGlzLl9ub3JtYWxNYXRyaXhbaV0udXBkYXRlKClcbiAgICB9XG4gICAgdGhpcy5fYmFzZUNvbG9yLnVwZGF0ZSgpXG4gIH1cblxuICBhZGRHZW9tZXRyeUF0dHJpYnV0ZXMoZ2VvbWV0cnk6IFBJWEkuR2VvbWV0cnkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKGBhX01vZGVsTWF0cml4JHtpfWAsXG4gICAgICAgIHRoaXMuX21vZGVsTWF0cml4W2ldLCA0LCBmYWxzZSwgdW5kZWZpbmVkLCAwLCB1bmRlZmluZWQsIHRydWUpXG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoYGFfTm9ybWFsTWF0cml4JHtpfWAsXG4gICAgICAgIHRoaXMuX25vcm1hbE1hdHJpeFtpXSwgNCwgZmFsc2UsIHVuZGVmaW5lZCwgMCwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIH1cbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoXCJhX0Jhc2VDb2xvckZhY3RvclwiLFxuICAgICAgdGhpcy5fYmFzZUNvbG9yLCA0LCBmYWxzZSwgdW5kZWZpbmVkLCAwLCB1bmRlZmluZWQsIHRydWUpXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuZXhwb3J0IG5hbWVzcGFjZSBTdGFuZGFyZFNoYWRlclNvdXJjZSB7XG4gIGV4cG9ydCBmdW5jdGlvbiBidWlsZChzb3VyY2U6IHN0cmluZywgZmVhdHVyZXM6IHN0cmluZ1tdLCByZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIGlmIChyZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoL1ZFUlNJT04vLCBcIjEwMFwiKVxuICAgICAgICAucmVwbGFjZSgvVkVSVF9JTi9nLCBcImF0dHJpYnV0ZVwiKVxuICAgICAgICAucmVwbGFjZSgvVkVSVF9PVVQvZywgXCJ2YXJ5aW5nXCIpXG4gICAgICAgIC5yZXBsYWNlKC9GUkFHX0NPTE9SL2csIFwiZ2xfRnJhZ0NvbG9yXCIpXG4gICAgICAgIC5yZXBsYWNlKC9GUkFHX0lOL2csIFwidmFyeWluZ1wiKVxuICAgIH1cbiAgICBpZiAocmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC9WRVJTSU9OLywgXCIzMDAgZXNcIilcbiAgICAgICAgLnJlcGxhY2UoL1ZFUlRfSU4vZywgXCJpblwiKVxuICAgICAgICAucmVwbGFjZSgvVkVSVF9PVVQvZywgXCJvdXRcIilcbiAgICAgICAgLnJlcGxhY2UoL0ZSQUdfQ09MT1IvZywgXCJnX2ZpbmFsQ29sb3JcIilcbiAgICAgICAgLnJlcGxhY2UoL0ZSQUdfSU4vZywgXCJpblwiKVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoLyNkZWZpbmUgRkVBVFVSRVMvLFxuICAgICAgZmVhdHVyZXMubWFwKHZhbHVlID0+IGAjZGVmaW5lICR7dmFsdWV9YCkuam9pbihcIlxcblwiKSlcbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBNZXNoR2VvbWV0cnkzRCB9IGZyb20gXCIuLi8uLi9tZXNoL2dlb21ldHJ5L21lc2gtZ2VvbWV0cnlcIlxuaW1wb3J0IHsgTWVzaDNEIH0gZnJvbSBcIi4uLy4uL21lc2gvbWVzaFwiXG5pbXBvcnQgeyBNZXNoU2hhZGVyIH0gZnJvbSBcIi4uLy4uL21lc2gvbWVzaC1zaGFkZXJcIlxuaW1wb3J0IHsgU3RhbmRhcmRTaGFkZXJJbnN0YW5jaW5nIH0gZnJvbSBcIi4vc3RhbmRhcmQtc2hhZGVyLWluc3RhbmNpbmdcIlxuaW1wb3J0IHsgU3RhbmRhcmRTaGFkZXJTb3VyY2UgfSBmcm9tIFwiLi9zdGFuZGFyZC1zaGFkZXItc291cmNlXCJcblxuZXhwb3J0IGNsYXNzIFN0YW5kYXJkU2hhZGVyIGV4dGVuZHMgTWVzaFNoYWRlciB7XG4gIHByaXZhdGUgX2luc3RhbmNpbmcgPSBuZXcgU3RhbmRhcmRTaGFkZXJJbnN0YW5jaW5nKClcblxuICBzdGF0aWMgYnVpbGQocmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIsIGZlYXR1cmVzOiBzdHJpbmdbXSkge1xuICAgIGxldCB2ZXJ0ID0gcmVxdWlyZShgLi9zaGFkZXIvcHJpbWl0aXZlLnZlcnRgKVxuICAgIGxldCBmcmFnID0gcmVxdWlyZShgLi9zaGFkZXIvbWV0YWxsaWMtcm91Z2huZXNzLmZyYWdgKVxuXG4gICAgbGV0IHByb2dyYW0gPSBQSVhJLlByb2dyYW0uZnJvbShcbiAgICAgIFN0YW5kYXJkU2hhZGVyU291cmNlLmJ1aWxkKHZlcnQsIGZlYXR1cmVzLCByZW5kZXJlciksXG4gICAgICBTdGFuZGFyZFNoYWRlclNvdXJjZS5idWlsZChmcmFnLCBmZWF0dXJlcywgcmVuZGVyZXIpKVxuXG4gICAgcmV0dXJuIG5ldyBTdGFuZGFyZFNoYWRlcihwcm9ncmFtKVxuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIFwic3RhbmRhcmQtc2hhZGVyXCJcbiAgfVxuXG4gIGNyZWF0ZVNoYWRlckdlb21ldHJ5KGdlb21ldHJ5OiBNZXNoR2VvbWV0cnkzRCwgaW5zdGFuY2VkOiBib29sZWFuKSB7XG4gICAgbGV0IHJlc3VsdCA9IHN1cGVyLmNyZWF0ZVNoYWRlckdlb21ldHJ5KGdlb21ldHJ5LCBpbnN0YW5jZWQpXG4gICAgaWYgKGluc3RhbmNlZCkge1xuICAgICAgdGhpcy5faW5zdGFuY2luZy5hZGRHZW9tZXRyeUF0dHJpYnV0ZXMocmVzdWx0KVxuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnkudGFyZ2V0cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeS50YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwb3NpdGlvbnMgPSBnZW9tZXRyeS50YXJnZXRzW2ldLnBvc2l0aW9uc1xuICAgICAgICBpZiAocG9zaXRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZEF0dHJpYnV0ZShgYV9UYXJnZXRfUG9zaXRpb24ke2l9YCwgbmV3IFBJWEkuQnVmZmVyKHBvc2l0aW9ucy5idWZmZXIpLFxuICAgICAgICAgICAgMywgZmFsc2UsIHBvc2l0aW9ucy5jb21wb25lbnRUeXBlLCBwb3NpdGlvbnMuc3RyaWRlKVxuICAgICAgICB9XG4gICAgICAgIGxldCBub3JtYWxzID0gZ2VvbWV0cnkudGFyZ2V0c1tpXS5ub3JtYWxzXG4gICAgICAgIGlmIChub3JtYWxzKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZEF0dHJpYnV0ZShgYV9UYXJnZXRfTm9ybWFsJHtpfWAsIG5ldyBQSVhJLkJ1ZmZlcihub3JtYWxzLmJ1ZmZlciksXG4gICAgICAgICAgICAzLCBmYWxzZSwgbm9ybWFscy5jb21wb25lbnRUeXBlLCBub3JtYWxzLnN0cmlkZSlcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFuZ2VudHMgPSBnZW9tZXRyeS50YXJnZXRzW2ldLnRhbmdlbnRzXG4gICAgICAgIGlmICh0YW5nZW50cykge1xuICAgICAgICAgIHJlc3VsdC5hZGRBdHRyaWJ1dGUoYGFfVGFyZ2V0X1RhbmdlbnQke2l9YCwgbmV3IFBJWEkuQnVmZmVyKHRhbmdlbnRzLmJ1ZmZlciksXG4gICAgICAgICAgICAzLCBmYWxzZSwgdGFuZ2VudHMuY29tcG9uZW50VHlwZSwgdGFuZ2VudHMuc3RyaWRlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeS5qb2ludHMpIHtcbiAgICAgIHJlc3VsdC5hZGRBdHRyaWJ1dGUoXCJhX0pvaW50MVwiLCBuZXcgUElYSS5CdWZmZXIoZ2VvbWV0cnkuam9pbnRzLmJ1ZmZlciksXG4gICAgICAgIDQsIGZhbHNlLCBnZW9tZXRyeS5qb2ludHMuY29tcG9uZW50VHlwZSwgZ2VvbWV0cnkuam9pbnRzLnN0cmlkZSlcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LndlaWdodHMpIHtcbiAgICAgIHJlc3VsdC5hZGRBdHRyaWJ1dGUoXCJhX1dlaWdodDFcIiwgbmV3IFBJWEkuQnVmZmVyKGdlb21ldHJ5LndlaWdodHMuYnVmZmVyKSxcbiAgICAgICAgNCwgZmFsc2UsIGdlb21ldHJ5LndlaWdodHMuY29tcG9uZW50VHlwZSwgZ2VvbWV0cnkud2VpZ2h0cy5zdHJpZGUpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHJlbmRlcihtZXNoOiBNZXNoM0QsIHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyLCBzdGF0ZTogUElYSS5TdGF0ZSwgZHJhd01vZGU6IFBJWEkuRFJBV19NT0RFUykge1xuICAgIGlmIChtZXNoLmluc3RhbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9pbnN0YW5jaW5nLnVwZGF0ZUJ1ZmZlcnMobWVzaC5pbnN0YW5jZXMpXG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcihtZXNoLCByZW5kZXJlciwgc3RhdGUsIGRyYXdNb2RlKVxuICB9XG59IiwiaW1wb3J0IHsgbWF0MyB9IGZyb20gXCJnbC1tYXRyaXhcIlxuXG5leHBvcnQgY2xhc3MgTWF0MyB7XG4gIHN0YXRpYyBtdWx0aXBseShhOiBGbG9hdDMyQXJyYXksIGI6IEZsb2F0MzJBcnJheSwgb3V0OiBGbG9hdDMyQXJyYXkpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQzLm11bHRpcGx5KG91dCwgYSwgYilcbiAgfVxufSIsImltcG9ydCB7IG1hdDQgfSBmcm9tIFwiZ2wtbWF0cml4XCJcblxuZXhwb3J0IGNsYXNzIE1hdDQge1xuICBzdGF0aWMgZ2V0VHJhbnNsYXRpb24obWF0OiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMykpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LmdldFRyYW5zbGF0aW9uKG91dCwgbWF0KVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+bWF0NC5jcmVhdGUoKVxuICB9XG4gIHN0YXRpYyB0cmFuc2xhdGUobWF0OiBGbG9hdDMyQXJyYXksIHY6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNikpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LnRyYW5zbGF0ZShvdXQsIG1hdCwgdilcbiAgfVxuICBzdGF0aWMgZ2V0U2NhbGluZyhtYXQ6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5Pm1hdDQuZ2V0U2NhbGluZyhvdXQsIG1hdClcbiAgfVxuICBzdGF0aWMgZ2V0Um90YXRpb24obWF0OiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoNCkpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LmdldFJvdGF0aW9uKG91dCwgbWF0KVxuICB9XG4gIHN0YXRpYyBjb3B5KGE6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNikpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LmNvcHkob3V0LCBhKVxuICB9XG4gIHN0YXRpYyBmcm9tUXVhdChxOiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+bWF0NC5mcm9tUXVhdChvdXQsIHEpXG4gIH1cbiAgc3RhdGljIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUocTogRmxvYXQzMkFycmF5LCB2OiBGbG9hdDMyQXJyYXksIHM6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNikpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKVxuICB9XG4gIHN0YXRpYyBmcm9tUm90YXRpb24ocmFkOiBudW1iZXIsIGF4aXM6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNikpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LmZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcylcbiAgfVxuICBzdGF0aWMgZnJvbVNjYWxpbmcodjogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5Pm1hdDQuZnJvbVNjYWxpbmcob3V0LCB2KVxuICB9XG4gIHN0YXRpYyBmcm9tVHJhbnNsYXRpb24odjogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5Pm1hdDQuZnJvbVRyYW5zbGF0aW9uKG91dCwgdilcbiAgfVxuICBzdGF0aWMgbXVsdGlwbHkoYTogRmxvYXQzMkFycmF5LCBiOiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+bWF0NC5tdWx0aXBseShvdXQsIGEsIGIpXG4gIH1cbiAgc3RhdGljIGxvb2tBdChleWU6IEZsb2F0MzJBcnJheSwgY2VudGVyOiBGbG9hdDMyQXJyYXksIHVwOiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+bWF0NC5sb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApXG4gIH1cbiAgc3RhdGljIGlkZW50aXR5KG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+bWF0NC5pZGVudGl0eShvdXQpXG4gIH1cbiAgc3RhdGljIHBlcnNwZWN0aXZlKGZvdnk6IG51bWJlciwgYXNwZWN0OiBudW1iZXIsIG5lYXI6IG51bWJlciwgZmFyOiBudW1iZXIsIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+bWF0NC5wZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKVxuICB9XG4gIHN0YXRpYyBvcnRobyhsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCB0b3A6IG51bWJlciwgbmVhcjogbnVtYmVyLCBmYXI6IG51bWJlciwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNikpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0Lm9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpXG4gIH1cbiAgc3RhdGljIGludmVydChhOiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+bWF0NC5pbnZlcnQob3V0LCBhKVxuICB9XG4gIHN0YXRpYyB0cmFuc3Bvc2UoYTogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5Pm1hdDQudHJhbnNwb3NlKG91dCwgYSlcbiAgfVxuICBzdGF0aWMgdGFyZ2V0VG8oZXllOiBGbG9hdDMyQXJyYXksIHRhcmdldDogRmxvYXQzMkFycmF5LCB1cDogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5Pm1hdDQudGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApXG4gIH1cbiAgc3RhdGljIHJvdGF0ZVgoYTogRmxvYXQzMkFycmF5LCByYWQ6IG51bWJlciwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNikpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LnJvdGF0ZVgob3V0LCBhLCByYWQpXG4gIH1cbiAgc3RhdGljIHJvdGF0ZVkoYTogRmxvYXQzMkFycmF5LCByYWQ6IG51bWJlciwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNikpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LnJvdGF0ZVkob3V0LCBhLCByYWQpXG4gIH1cbiAgc3RhdGljIHJvdGF0ZVooYTogRmxvYXQzMkFycmF5LCByYWQ6IG51bWJlciwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNikpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5tYXQ0LnJvdGF0ZVoob3V0LCBhLCByYWQpXG4gIH1cbiAgc3RhdGljIHJvdGF0ZShhOiBGbG9hdDMyQXJyYXksIHJhZDogbnVtYmVyLCBheGlzOiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+bWF0NC5yb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpXG4gIH1cbiAgc3RhdGljIHNjYWxlKGE6IEZsb2F0MzJBcnJheSwgdjogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5Pm1hdDQuc2NhbGUob3V0LCBhLCB2KVxuICB9XG59IiwiaW1wb3J0IHsgUmF5IH0gZnJvbSBcIi4vcmF5XCJcbmltcG9ydCB7IFZlYzMgfSBmcm9tIFwiLi92ZWMzXCJcblxuZnVuY3Rpb24gYXBwcm94aW1hdGVseShhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5cbmNvbnN0IEVQU0lMT04gPSAwLjAwMDAwMVxuXG5leHBvcnQgY2xhc3MgUGxhbmUge1xuICBwcml2YXRlIF9ub3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG5cbiAgY29uc3RydWN0b3Iobm9ybWFsOiBGbG9hdDMyQXJyYXksIHB1YmxpYyBkaXN0YW5jZTogbnVtYmVyKSB7XG4gICAgVmVjMy5ub3JtYWxpemUobm9ybWFsLCB0aGlzLl9ub3JtYWwpXG4gIH1cblxuICBnZXQgbm9ybWFsKCkge1xuICAgIHJldHVybiB0aGlzLl9ub3JtYWxcbiAgfVxuXG4gIHJheUNhc3QocmF5OiBSYXkpIHtcbiAgICBjb25zdCB2ZG90ID0gVmVjMy5kb3QocmF5LmRpcmVjdGlvbiwgdGhpcy5ub3JtYWwpXG4gICAgaWYgKGFwcHJveGltYXRlbHkodmRvdCwgMCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIGNvbnN0IG5kb3QgPSAtVmVjMy5kb3QocmF5Lm9yaWdpbiwgdGhpcy5ub3JtYWwpIC0gdGhpcy5kaXN0YW5jZVxuICAgIHJldHVybiBuZG90IC8gdmRvdFxuICB9XG59IiwiaW1wb3J0IHsgcXVhdCB9IGZyb20gXCJnbC1tYXRyaXhcIlxuXG5leHBvcnQgY2xhc3MgUXVhdCB7XG4gIHN0YXRpYyBzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlciwgdzogbnVtYmVyLCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+cXVhdC5zZXQob3V0LCB4LCB5LCB6LCB3KVxuICB9XG4gIHN0YXRpYyBmcm9tVmFsdWVzKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIsIHc6IG51bWJlcikge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnF1YXQuZnJvbVZhbHVlcyh4LCB5LCB6LCB3KVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+cXVhdC5jcmVhdGUoKVxuICB9XG4gIHN0YXRpYyBub3JtYWxpemUoYTogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+cXVhdC5ub3JtYWxpemUob3V0LCBhKVxuICB9XG4gIHN0YXRpYyBzbGVycChhOiBGbG9hdDMyQXJyYXksIGI6IEZsb2F0MzJBcnJheSwgdDogbnVtYmVyLCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+cXVhdC5zbGVycChvdXQsIGEsIGIsIHQpXG4gIH1cbiAgc3RhdGljIGZyb21FdWxlcih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyLCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+cXVhdC5mcm9tRXVsZXIob3V0LCB4LCB5LCB6KVxuICB9XG4gIHN0YXRpYyBjb25qdWdhdGUoYTogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+cXVhdC5jb25qdWdhdGUob3V0LCBhKVxuICB9XG4gIHN0YXRpYyByb3RhdGVYKGE6IEZsb2F0MzJBcnJheSwgcmFkOiBudW1iZXIsIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoNCkpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT5xdWF0LnJvdGF0ZVgob3V0LCBhLCByYWQpXG4gIH1cbiAgc3RhdGljIHJvdGF0ZVkoYTogRmxvYXQzMkFycmF5LCByYWQ6IG51bWJlciwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg0KSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnF1YXQucm90YXRlWShvdXQsIGEsIHJhZClcbiAgfVxuICBzdGF0aWMgcm90YXRlWihhOiBGbG9hdDMyQXJyYXksIHJhZDogbnVtYmVyLCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+cXVhdC5yb3RhdGVaKG91dCwgYSwgcmFkKVxuICB9XG59IiwiaW1wb3J0IHsgVmVjMyB9IGZyb20gXCIuL3ZlYzNcIlxuXG5leHBvcnQgY2xhc3MgUmF5IHtcbiAgcHJpdmF0ZSBfZGlyZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICBwcml2YXRlIF9vcmlnaW4gPSBuZXcgRmxvYXQzMkFycmF5KDMpXG5cbiAgY29uc3RydWN0b3Iob3JpZ2luOiBGbG9hdDMyQXJyYXksIGRpcmVjdGlvbjogRmxvYXQzMkFycmF5KSB7XG4gICAgVmVjMy5jb3B5KG9yaWdpbiwgdGhpcy5fb3JpZ2luKVxuICAgIFZlYzMubm9ybWFsaXplKGRpcmVjdGlvbiwgdGhpcy5fZGlyZWN0aW9uKVxuICB9XG5cbiAgZ2V0IG9yaWdpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luXG4gIH1cblxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb25cbiAgfVxuXG4gIGdldFBvaW50KGRpc3RhbmNlOiBudW1iZXIsIHBvaW50ID0gbmV3IEZsb2F0MzJBcnJheSgzKSkge1xuICAgIHJldHVybiBWZWMzLmFkZCh0aGlzLl9vcmlnaW4sIFZlYzMuc2NhbGUoXG4gICAgICB0aGlzLl9kaXJlY3Rpb24sIGRpc3RhbmNlLCBwb2ludCksIHBvaW50KVxuICB9XG59IiwiaW1wb3J0IHsgdmVjMyB9IGZyb20gXCJnbC1tYXRyaXhcIlxuXG5leHBvcnQgY2xhc3MgVmVjMyB7XG4gIHN0YXRpYyBzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlciwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnZlYzMuc2V0KG91dCwgeCwgeSwgeilcbiAgfVxuICBzdGF0aWMgZnJvbVZhbHVlcyh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+dmVjMy5mcm9tVmFsdWVzKHgsIHksIHopXG4gIH1cbiAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT52ZWMzLmNyZWF0ZSgpXG4gIH1cbiAgc3RhdGljIGFkZChhOiBGbG9hdDMyQXJyYXksIGI6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnZlYzMuYWRkKG91dCwgYSwgYilcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtUXVhdChhOiBGbG9hdDMyQXJyYXksIHE6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnZlYzMudHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpXG4gIH1cbiAgc3RhdGljIHN1YnRyYWN0KGE6IEZsb2F0MzJBcnJheSwgYjogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+dmVjMy5zdWJ0cmFjdChvdXQsIGEsIGIpXG4gIH1cbiAgc3RhdGljIHNjYWxlKGE6IEZsb2F0MzJBcnJheSwgYjogbnVtYmVyLCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+dmVjMy5zY2FsZShvdXQsIGEsIGIpXG4gIH1cbiAgc3RhdGljIGRvdChhOiBGbG9hdDMyQXJyYXksIGI6IEZsb2F0MzJBcnJheSkge1xuICAgIHJldHVybiB2ZWMzLmRvdChhLCBiKVxuICB9XG4gIHN0YXRpYyBub3JtYWxpemUoYTogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+dmVjMy5ub3JtYWxpemUob3V0LCBhKVxuICB9XG4gIHN0YXRpYyBjcm9zcyhhOiBGbG9hdDMyQXJyYXksIGI6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnZlYzMuY3Jvc3Mob3V0LCBhLCBiKVxuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm1NYXQ0KGE6IEZsb2F0MzJBcnJheSwgbTogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+dmVjMy50cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSlcbiAgfVxuICBzdGF0aWMgY29weShhOiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMykpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT52ZWMzLmNvcHkob3V0LCBhKVxuICB9XG4gIHN0YXRpYyBtYWduaXR1ZGUoYTogRmxvYXQzMkFycmF5KSB7XG4gICAgcmV0dXJuIHZlYzMubGVuZ3RoKGEpXG4gIH1cbiAgc3RhdGljIGludmVyc2UoYTogRmxvYXQzMkFycmF5LCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+dmVjMy5pbnZlcnNlKG91dCwgYSlcbiAgfVxuICBzdGF0aWMgbmVnYXRlKGE6IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnZlYzMubmVnYXRlKG91dCwgYSlcbiAgfVxuICBzdGF0aWMgbXVsdGlwbHkoYTogRmxvYXQzMkFycmF5LCBiOiBGbG9hdDMyQXJyYXksIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMykpIHtcbiAgICByZXR1cm4gPEZsb2F0MzJBcnJheT52ZWMzLm11bHRpcGx5KG91dCwgYSwgYilcbiAgfVxuICBzdGF0aWMgZGlzdGFuY2UoYTogRmxvYXQzMkFycmF5LCBiOiBGbG9hdDMyQXJyYXkpIHtcbiAgICByZXR1cm4gdmVjMy5kaXN0YW5jZShhLCBiKVxuICB9XG4gIHN0YXRpYyBzcXVhcmVkRGlzdGFuY2UoYTogRmxvYXQzMkFycmF5LCBiOiBGbG9hdDMyQXJyYXkpIHtcbiAgICByZXR1cm4gdmVjMy5zcXVhcmVkRGlzdGFuY2UoYSwgYilcbiAgfVxufSIsImltcG9ydCB7IHZlYzQgfSBmcm9tIFwiZ2wtbWF0cml4XCJcblxuZXhwb3J0IGNsYXNzIFZlYzQge1xuICBzdGF0aWMgc2V0KHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIsIHc6IG51bWJlciwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg0KSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnZlYzQuc2V0KG91dCwgeCwgeSwgeiwgdylcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtTWF0NChhOiBGbG9hdDMyQXJyYXksIG06IEZsb2F0MzJBcnJheSwgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg0KSkge1xuICAgIHJldHVybiA8RmxvYXQzMkFycmF5PnZlYzQudHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pXG4gIH1cbiAgc3RhdGljIGZyb21WYWx1ZXMoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlciwgdzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIDxGbG9hdDMyQXJyYXk+dmVjNC5mcm9tVmFsdWVzKHgsIHksIHosIHcpXG4gIH1cbn0iLCJpbXBvcnQgeyBNZXNoR2VvbWV0cnkzRCB9IGZyb20gXCIuL21lc2gtZ2VvbWV0cnlcIlxuXG5leHBvcnQgbmFtZXNwYWNlIEN1YmVHZW9tZXRyeSB7XG4gIGV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IE1lc2hHZW9tZXRyeTNEKCksIHtcbiAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICBidWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAxLCAxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDEsIDEsIC0xLCAxLCAxLCAtMSwgMSwgLTEsIDEsIDEsIC0xLCAtMSwgMSwgMSwgMSwgMSwgMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgMSwgLTEsIDEsIDEsIDEsIC0xLCAxLCAtMSwgLTEsIC0xLCAxLCAtMSwgLTEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIDFdKVxuICAgICAgfSxcbiAgICAgIGluZGljZXM6IHtcbiAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShbMCwgMSwgMiwgMCwgMywgMSwgNCwgNSwgNiwgNCwgNywgNSwgOCwgOSwgMTAsIDgsIDExLCA5LCAxMiwgMTMsIDE0LCAxMiwgMTUsIDEzLCAxNiwgMTcsIDE4LCAxNiwgMTksIDE3LCAyMCwgMjEsIDIyLCAyMCwgMjMsIDIxXSlcbiAgICAgIH0sXG4gICAgICBub3JtYWxzOiB7XG4gICAgICAgIGJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheShbLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMF0pXG4gICAgICB9LFxuICAgICAgdXZzOiBbe1xuICAgICAgICBidWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkoWzAuNjI1LCAxLCAwLjM3NSwgMC43NSwgMC4zNzUsIDEsIDAuNjI1LCAwLjc1LCAwLjYyNSwgMC43NSwgMC4zNzUsIDAuNSwgMC4zNzUsIDAuNzUsIDAuNjI1LCAwLjUsIDAuNjI1LCAwLjUsIDAuMzc1LCAwLjI1LCAwLjM3NSwgMC41LCAwLjYyNSwgMC4yNSwgMC42MjUsIDAuMjUsIDAuMzc1LCAwLCAwLjM3NSwgMC4yNSwgMC42MjUsIDAsIDAuMzc1LCAwLjI1LCAwLjEyNSwgMC41LCAwLjM3NSwgMC41LCAwLjEyNSwgMC4yNSwgMC44NzUsIDAuMjUsIDAuNjI1LCAwLjUsIDAuODc1LCAwLjUsIDAuNjI1LCAwLjI1XSlcbiAgICAgIH1dLFxuICAgICAgdGFuZ2VudHM6IHtcbiAgICAgICAgYnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAtMSwgMCwgMCwgMSwgLTEsIDAsIDAsIDEsIC0xLCAwLCAwLCAxLCAtMSwgMCwgMCwgMV0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBNZXNoU2hhZGVyIH0gZnJvbSBcIi4uL21lc2gtc2hhZGVyXCJcbmltcG9ydCB7IE1lc2hHZW9tZXRyeUF0dHJpYnV0ZSB9IGZyb20gXCIuL21lc2gtZ2VvbWV0cnktYXR0cmlidXRlXCJcbmltcG9ydCB7IE1lc2hHZW9tZXRyeVRhcmdldCB9IGZyb20gXCIuL21lc2gtZ2VvbWV0cnktdGFyZ2V0XCJcblxuLyoqXG4gKiBHZW9tZXRyeSB3aXRoIG1lc2ggZGF0YSAoaS5lLiBwb3NpdGlvbnMsIG5vcm1hbHMsIHV2cykuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNoR2VvbWV0cnkzRCB7XG4gIHByaXZhdGUgX3NoYWRlckdlb21ldHJ5OiB7IFtpZDogc3RyaW5nXTogUElYSS5HZW9tZXRyeSB9ID0ge31cblxuICBpbmRpY2VzPzogTWVzaEdlb21ldHJ5QXR0cmlidXRlXG4gIHBvc2l0aW9ucz86IE1lc2hHZW9tZXRyeUF0dHJpYnV0ZVxuICB1dnM/OiBNZXNoR2VvbWV0cnlBdHRyaWJ1dGVbXVxuICBub3JtYWxzPzogTWVzaEdlb21ldHJ5QXR0cmlidXRlXG4gIHRhbmdlbnRzPzogTWVzaEdlb21ldHJ5QXR0cmlidXRlXG4gIHRhcmdldHM/OiBNZXNoR2VvbWV0cnlUYXJnZXRbXVxuICBqb2ludHM/OiBNZXNoR2VvbWV0cnlBdHRyaWJ1dGVcbiAgd2VpZ2h0cz86IE1lc2hHZW9tZXRyeUF0dHJpYnV0ZVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGdlb21ldHJ5IHdpdGggYXR0cmlidXRlcyByZXF1aXJlZCBieSB0aGUgc3BlY2lmaWVkIHNoYWRlci5cbiAgICogQHBhcmFtIHNoYWRlciBUaGUgc2hhZGVyIHRvIHVzZS5cbiAgICovXG4gIGdldFNoYWRlckdlb21ldHJ5KHNoYWRlcjogTWVzaFNoYWRlcikge1xuICAgIHJldHVybiB0aGlzLl9zaGFkZXJHZW9tZXRyeVtzaGFkZXIubmFtZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGdlb21ldHJ5IHdpdGggYXR0cmlidXRlcyByZXF1aXJlZCBieSB0aGUgc3BlY2lmaWVkIHNoYWRlci5cbiAgICogQHBhcmFtIHNoYWRlciBUaGUgc2hhZGVyIHRvIHVzZS5cbiAgICogQHBhcmFtIGluc3RhbmNlZCBWYWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBnZW9tZXRyeSB3aWxsIGJlIGluc3RhbmNlZC5cbiAgICovXG4gIGFkZFNoYWRlckdlb21ldHJ5KHNoYWRlcjogTWVzaFNoYWRlciwgaW5zdGFuY2VkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2hhZGVyR2VvbWV0cnlbc2hhZGVyLm5hbWVdID0gc2hhZGVyLmNyZWF0ZVNoYWRlckdlb21ldHJ5KHRoaXMsIGluc3RhbmNlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyBpZiBnZW9tZXRyeSB3aXRoIHJlcXVpcmVkIGF0dHJpYnV0ZXMgaGFzIGJlZW4gY3JlYXRlZCB0aGUgc3BlY2lmaWVkIHNoYWRlci5cbiAgICogQHBhcmFtIHNoYWRlciBUaGUgc2hhZGVyIHRvIHRlc3QuXG4gICAqIEBwYXJhbSBpbnN0YW5jZWQgVmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgZ2VvbWV0cnkgaXMgaW5zdGFuY2VkLlxuICAgKi9cbiAgaGFzU2hhZGVyR2VvbWV0cnkoc2hhZGVyOiBNZXNoU2hhZGVyLCBpbnN0YW5jZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5fc2hhZGVyR2VvbWV0cnlbc2hhZGVyLm5hbWVdKSB7XG4gICAgICByZXR1cm4gIWluc3RhbmNlZCB8fCAoaW5zdGFuY2VkICYmIHRoaXMuX3NoYWRlckdlb21ldHJ5W3NoYWRlci5uYW1lXS5pbnN0YW5jZWQpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBnZW9tZXRyeSBhbmQgaXQncyB1c2VkIHJlc291cmNlcy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLl9zaGFkZXJHZW9tZXRyeSkge1xuICAgICAgdGhpcy5fc2hhZGVyR2VvbWV0cnlbbmFtZV0uZGVzdHJveSgpXG4gICAgfVxuICAgIHRoaXMuX3NoYWRlckdlb21ldHJ5ID0ge31cbiAgfVxufSIsImltcG9ydCB7IE1lc2hHZW9tZXRyeTNEIH0gZnJvbSBcIi4vbWVzaC1nZW9tZXRyeVwiXG5cbmV4cG9ydCBuYW1lc3BhY2UgUGxhbmVHZW9tZXRyeSB7XG4gIGV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IE1lc2hHZW9tZXRyeTNEKCksIHtcbiAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICBidWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAwLCAxLCAxLCAwLCAtMSwgLTEsIDAsIC0xLCAxLCAwLCAxXSlcbiAgICAgIH0sXG4gICAgICBpbmRpY2VzOiB7XG4gICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoWzAsIDEsIDIsIDAsIDMsIDFdKVxuICAgICAgfSxcbiAgICAgIG5vcm1hbHM6IHtcbiAgICAgICAgYnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwXSlcbiAgICAgIH0sXG4gICAgICB1dnM6IFt7XG4gICAgICAgIGJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMCwgMCwgMCwgMSwgMV0pXG4gICAgICB9XVxuICAgIH0pXG4gIH1cbn0iLCJpbXBvcnQgeyBNZXNoR2VvbWV0cnkzRCB9IGZyb20gXCIuL21lc2gtZ2VvbWV0cnlcIlxuXG5leHBvcnQgbmFtZXNwYWNlIFF1YWRHZW9tZXRyeSB7XG4gIGV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IE1lc2hHZW9tZXRyeTNEKCksIHtcbiAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICBidWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAxLCAwLCAxLCAtMSwgMCwgLTEsIC0xLCAwLCAxLCAxLCAwXSlcbiAgICAgIH0sXG4gICAgICBpbmRpY2VzOiB7XG4gICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoWzAsIDIsIDEsIDAsIDEsIDNdKVxuICAgICAgfSxcbiAgICAgIG5vcm1hbHM6IHtcbiAgICAgICAgYnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSlcbiAgICAgIH0sXG4gICAgICB1dnM6IFt7XG4gICAgICAgIGJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMSwgMCwgMSwgMSwgMF0pXG4gICAgICB9XVxuICAgIH0pXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgQ29udGFpbmVyM0QgfSBmcm9tIFwiLi4vY29udGFpbmVyXCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuL21lc2hcIlxuXG5leHBvcnQgY2xhc3MgSW5zdGFuY2VkTWVzaDNEIGV4dGVuZHMgQ29udGFpbmVyM0Qge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBtZXNoOiBNZXNoM0QsIHJlYWRvbmx5IG1hdGVyaWFsOiB1bmtub3duKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgZGVzdHJveShvcHRpb25zOiBib29sZWFuIHwgUElYSS5JRGVzdHJveU9wdGlvbnMgfCB1bmRlZmluZWQpIHtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpXG4gICAgdGhpcy5tZXNoLnJlbW92ZUluc3RhbmNlKHRoaXMpXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgTWVzaEdlb21ldHJ5M0QgfSBmcm9tIFwiLi9nZW9tZXRyeS9tZXNoLWdlb21ldHJ5XCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuL21lc2hcIlxuXG4vKipcbiAqIFNoYWRlciB1c2VkIHNwZWNpZmljYWxseSB0byByZW5kZXIgYSBtZXNoLlxuICovXG5leHBvcnQgY2xhc3MgTWVzaFNoYWRlciBleHRlbmRzIFBJWEkuU2hhZGVyIHtcbiAgcHJpdmF0ZSBfc3RhdGUgPSBPYmplY3QuYXNzaWduKG5ldyBQSVhJLlN0YXRlKCksIHtcbiAgICBjdWxsaW5nOiB0cnVlLCBjbG9ja3dpc2VGcm9udEZhY2U6IGZhbHNlLCBkZXB0aFRlc3Q6IHRydWVcbiAgfSlcblxuICAvKiogVGhlIG5hbWUgb2YgdGhlIG1lc2ggc2hhZGVyLiBVc2VkIGZvciBmaWd1cmluZyBvdXQgaWYgZ2VvbWV0cnkgYXR0cmlidXRlc2lzIGNvbXBhdGlibGUgd2l0aCB0aGUgc2hhZGVyLiBUaGlzIG5lZWRzIHRvIGJlIHNldCB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZGVmYXVsdCB2YWx1ZSB3aGVuIGN1c3RvbSBhdHRyaWJ1dGVzIGlzIHVzZWQuICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBcIm1lc2gtc2hhZGVyXCJcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGdlb21ldHJ5IHdpdGggcmVxdWlyZWQgYXR0cmlidXRlcyB1c2VkIGJ5IHRoaXMgc2hhZGVyLiBPdmVycmlkZSB3aGVuIHVzaW5nIGN1c3RvbSBhdHRyaWJ1dGVzLlxuICAgKiBAcGFyYW0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5IHdpdGggbWVzaCBkYXRhLlxuICAgKiBAcGFyYW0gaW5zdGFuY2VkIFZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGdlb21ldHJ5IHdpbGwgYmUgaW5zdGFuY2VkLlxuICAgKi9cbiAgY3JlYXRlU2hhZGVyR2VvbWV0cnkoZ2VvbWV0cnk6IE1lc2hHZW9tZXRyeTNELCBpbnN0YW5jZWQ6IGJvb2xlYW4pIHtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFBJWEkuR2VvbWV0cnkoKVxuICAgIGlmIChnZW9tZXRyeS5pbmRpY2VzKSB7XG4gICAgICBpZiAoZ2VvbWV0cnkuaW5kaWNlcy5idWZmZXIuQllURVNfUEVSX0VMRU1FTlQgPT09IDEpIHtcbiAgICAgICAgLy8gUElYSSBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggVWludDhBcnJheSwgbGV0J3MgY29udmVydCB0byBVTlNJR05FRF9TSE9SVC5cbiAgICAgICAgcmVzdWx0LmFkZEluZGV4KG5ldyBQSVhJLkJ1ZmZlcihuZXcgVWludDE2QXJyYXkoZ2VvbWV0cnkuaW5kaWNlcy5idWZmZXIpKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5hZGRJbmRleChuZXcgUElYSS5CdWZmZXIoZ2VvbWV0cnkuaW5kaWNlcy5idWZmZXIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnkucG9zaXRpb25zKSB7XG4gICAgICByZXN1bHQuYWRkQXR0cmlidXRlKFwiYV9Qb3NpdGlvblwiLCBuZXcgUElYSS5CdWZmZXIoZ2VvbWV0cnkucG9zaXRpb25zLmJ1ZmZlciksXG4gICAgICAgIDMsIGZhbHNlLCBnZW9tZXRyeS5wb3NpdGlvbnMuY29tcG9uZW50VHlwZSwgZ2VvbWV0cnkucG9zaXRpb25zLnN0cmlkZSlcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LnV2cyAmJiBnZW9tZXRyeS51dnNbMF0pIHtcbiAgICAgIHJlc3VsdC5hZGRBdHRyaWJ1dGUoXCJhX1VWMVwiLCBuZXcgUElYSS5CdWZmZXIoZ2VvbWV0cnkudXZzWzBdLmJ1ZmZlciksXG4gICAgICAgIDIsIGZhbHNlLCBnZW9tZXRyeS51dnNbMF0uY29tcG9uZW50VHlwZSwgZ2VvbWV0cnkudXZzWzBdLnN0cmlkZSlcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5Lm5vcm1hbHMpIHtcbiAgICAgIHJlc3VsdC5hZGRBdHRyaWJ1dGUoXCJhX05vcm1hbFwiLCBuZXcgUElYSS5CdWZmZXIoZ2VvbWV0cnkubm9ybWFscy5idWZmZXIpLFxuICAgICAgICAzLCBmYWxzZSwgZ2VvbWV0cnkubm9ybWFscy5jb21wb25lbnRUeXBlLCBnZW9tZXRyeS5ub3JtYWxzLnN0cmlkZSlcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LnRhbmdlbnRzKSB7XG4gICAgICByZXN1bHQuYWRkQXR0cmlidXRlKFwiYV9UYW5nZW50XCIsIG5ldyBQSVhJLkJ1ZmZlcihnZW9tZXRyeS50YW5nZW50cy5idWZmZXIpLFxuICAgICAgICA0LCBmYWxzZSwgZ2VvbWV0cnkudGFuZ2VudHMuY29tcG9uZW50VHlwZSwgZ2VvbWV0cnkudGFuZ2VudHMuc3RyaWRlKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2VvbWV0cnkgb2YgdGhlIHNwZWNpZmllZCBtZXNoLlxuICAgKiBAcGFyYW0gbWVzaCBNZXNoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHJlbmRlcmVyIFJlbmRlcmVyIHRvIHVzZS5cbiAgICogQHBhcmFtIHN0YXRlIFJlbmRlcmluZyBzdGF0ZSB0byB1c2UuXG4gICAqIEBwYXJhbSBkcmF3TW9kZSBEcmF3IG1vZGUgdG8gdXNlLlxuICAgKi9cbiAgcmVuZGVyKG1lc2g6IE1lc2gzRCwgcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIsIHN0YXRlOiBQSVhJLlN0YXRlID0gdGhpcy5fc3RhdGUsIGRyYXdNb2RlID0gUElYSS5EUkFXX01PREVTLlRSSUFOR0xFUykge1xuICAgIGNvbnN0IGluc3RhbmNlQ291bnQgPSBtZXNoLmluc3RhbmNlcy5maWx0ZXIoaSA9PlxuICAgICAgaS53b3JsZFZpc2libGUgJiYgaS5yZW5kZXJhYmxlKS5sZW5ndGhcbiAgICBjb25zdCBpbnN0YW5jaW5nID0gbWVzaC5pbnN0YW5jZXMubGVuZ3RoID4gMFxuICAgIGlmICghbWVzaC5nZW9tZXRyeS5oYXNTaGFkZXJHZW9tZXRyeSh0aGlzLCBpbnN0YW5jaW5nKSkge1xuICAgICAgbWVzaC5nZW9tZXRyeS5hZGRTaGFkZXJHZW9tZXRyeSh0aGlzLCBpbnN0YW5jaW5nKVxuICAgIH1cbiAgICBsZXQgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5LmdldFNoYWRlckdlb21ldHJ5KHRoaXMpXG4gICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcywgZmFsc2UpXG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KHN0YXRlKVxuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoZ2VvbWV0cnksIHRoaXMpXG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyhkcmF3TW9kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluc3RhbmNlQ291bnQpXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgUGxhbmVHZW9tZXRyeSB9IGZyb20gXCIuL2dlb21ldHJ5L3BsYW5lLWdlb21ldHJ5XCJcbmltcG9ydCB7IEN1YmVHZW9tZXRyeSB9IGZyb20gXCIuL2dlb21ldHJ5L2N1YmUtZ2VvbWV0cnlcIlxuaW1wb3J0IHsgTWVzaEdlb21ldHJ5M0QgfSBmcm9tIFwiLi9nZW9tZXRyeS9tZXNoLWdlb21ldHJ5XCJcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSBcIi4uL21hdGVyaWFsL21hdGVyaWFsXCJcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtbWF0ZXJpYWxcIlxuaW1wb3J0IHsgQ29udGFpbmVyM0QgfSBmcm9tIFwiLi4vY29udGFpbmVyXCJcbmltcG9ydCB7IFF1YWRHZW9tZXRyeSB9IGZyb20gXCIuL2dlb21ldHJ5L3F1YWQtZ2VvbWV0cnlcIlxuaW1wb3J0IHsgU2tpbiB9IGZyb20gXCIuLi9za2lubmluZy9za2luXCJcbmltcG9ydCB7IEluc3RhbmNlZE1lc2gzRCB9IGZyb20gXCIuL2luc3RhbmNlZC1tZXNoXCJcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSBcIi4uL3BsYXRmb3JtXCJcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbWVzaCB3aGljaCBjb250YWlucyBnZW9tZXRyeSBhbmQgaGFzIGEgbWF0ZXJpYWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNoM0QgZXh0ZW5kcyBDb250YWluZXIzRCB7XG5cbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBtZXNoLiAqL1xuICBwbHVnaW5OYW1lID0gXCJwaXBlbGluZVwiXG5cbiAgLyoqIEFycmF5IG9mIHdlaWdodHMgdXNlZCBmb3IgbW9ycGhpbmcgYmV0d2VlbiBnZW9tZXRyeSB0YXJnZXRzLiAqL1xuICBtb3JwaFdlaWdodHM/OiBudW1iZXJbXVxuXG4gIC8qKiBUaGUgc2tpbiB1c2VkIGZvciB2ZXJ0ZXggc2tpbm5pbmcuICovXG4gIHNraW4/OiBTa2luXG5cbiAgLyoqIFRoZSBlbmFibGVkIHJlbmRlciBwYXNzZXMgZm9yIHRoaXMgbWVzaC4gKi9cbiAgZW5hYmxlZFJlbmRlclBhc3NlcyA9IFtcIm1hdGVyaWFsXCJdXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbWVzaCB3aXRoIHRoZSBzcGVjaWZpZWQgZ2VvbWV0cnkgYW5kIG1hdGVyaWFsLlxuICAgKiBAcGFyYW0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5IGZvciB0aGUgbWVzaC5cbiAgICogQHBhcmFtIG1hdGVyaWFsIFRoZSBtYXRlcmlhbCBmb3IgdGhlIG1lc2guIElmIHRoZSBtYXRlcmlhbCBpcyBlbXB0eSB0aGUgbWVzaCB3b24ndCBiZSByZW5kZXJlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBnZW9tZXRyeTogTWVzaEdlb21ldHJ5M0QsIHB1YmxpYyBtYXRlcmlhbD86IE1hdGVyaWFsKSB7XG4gICAgc3VwZXIoKVxuICAgIGlmICghZ2VvbWV0cnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBJWEkzRDogR2VvbWV0cnkgaXMgcmVxdWlyZWQgd2hlbiBjcmVhdGluZyBhIG1lc2guXCIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIGlmIHNwZWNpZmllZCByZW5kZXJlciBzdXBwb3J0cyBpbnN0YW5jaW5nLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgVGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgc3RhdGljIGlzSW5zdGFuY2luZ1N1cHBvcnRlZChyZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIHJldHVybiBQbGF0Zm9ybS5pc0luc3RhbmNpbmdTdXBwb3J0ZWQocmVuZGVyZXIpXG4gIH1cblxuICBwcml2YXRlIF9pbnN0YW5jZXM6IEluc3RhbmNlZE1lc2gzRFtdID0gW11cblxuICAvKiogQW4gYXJyYXkgb2YgaW5zdGFuY2VzIGNyZWF0ZWQgZnJvbSB0aGlzIG1lc2guICovXG4gIGdldCBpbnN0YW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBtZXNoLlxuICAgKi9cbiAgY3JlYXRlSW5zdGFuY2UoKSB7XG4gICAgaWYgKHRoaXMubWF0ZXJpYWwgJiYgIXRoaXMubWF0ZXJpYWwuaXNJbnN0YW5jaW5nU3VwcG9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQSVhJM0Q6IENhbid0IGNyZWF0ZSBpbnN0YW5jZSBvZiBtZXNoLCBtYXRlcmlhbCBkb2VzIG5vdCBzdXBwb3J0ZWQgaW5zdGFuY2luZy5cIilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlc1tcbiAgICAgIHRoaXMuX2luc3RhbmNlcy5wdXNoKG5ldyBJbnN0YW5jZWRNZXNoM0QodGhpcywgdGhpcy5tYXRlcmlhbD8uY3JlYXRlSW5zdGFuY2UoKSkpIC0gMVxuICAgIF1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgaW5zdGFuY2VkIG1lc2ggZnJvbSB0aGlzIG1lc2guXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlSW5zdGFuY2UoaW5zdGFuY2U6IEluc3RhbmNlZE1lc2gzRCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faW5zdGFuY2VzLmluZGV4T2YoaW5zdGFuY2UpXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIHJlbmRlciBwYXNzIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVuZGVyIHBhc3MgdG8gZW5hYmxlLlxuICAgKi9cbiAgZW5hYmxlUmVuZGVyUGFzcyhuYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkUmVuZGVyUGFzc2VzLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICB0aGlzLmVuYWJsZWRSZW5kZXJQYXNzZXMucHVzaChuYW1lKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgcmVuZGVyIHBhc3Mgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSByZW5kZXIgcGFzcyB0byBkaXNhYmxlLlxuICAgKi9cbiAgZGlzYWJsZVJlbmRlclBhc3MobmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmVuYWJsZWRSZW5kZXJQYXNzZXMuaW5kZXhPZihuYW1lKVxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmVuYWJsZWRSZW5kZXJQYXNzZXMuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgc3BlY2lmaWVkIHJlbmRlciBwYXNzIGlzIGVuYWJsZWQuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSByZW5kZXIgcGFzcyB0byBjaGVjay5cbiAgICovXG4gIGlzUmVuZGVyUGFzc0VuYWJsZWQobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZFJlbmRlclBhc3Nlcy5pbmRleE9mKG5hbWUpID49IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgbWVzaCBhbmQgaXQncyB1c2VkIHJlc291cmNlcy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5kZXN0cm95KClcbiAgICBpZiAodGhpcy5tYXRlcmlhbCkge1xuICAgICAgdGhpcy5tYXRlcmlhbC5kZXN0cm95KClcbiAgICB9XG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cblxuICBfcmVuZGVyKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIoXG4gICAgICA8UElYSS5PYmplY3RSZW5kZXJlcj4oPGFueT5yZW5kZXJlci5wbHVnaW5zKVt0aGlzLnBsdWdpbk5hbWVdXG4gICAgKTtcbiAgICA8UElYSS5PYmplY3RSZW5kZXJlcj4oPGFueT5yZW5kZXJlci5wbHVnaW5zKVt0aGlzLnBsdWdpbk5hbWVdLnJlbmRlcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcXVhZCAoZmxhdCBzcXVhcmUpIG1lc2ggd2l0aCB0aGUgc3BlY2lmaWVkIG1hdGVyaWFsLlxuICAgKiBAcGFyYW0gbWF0ZXJpYWwgVGhlIG1hdGVyaWFsIHRvIHVzZS5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVRdWFkKG1hdGVyaWFsOiBNYXRlcmlhbCA9IG5ldyBTdGFuZGFyZE1hdGVyaWFsKCkpIHtcbiAgICByZXR1cm4gbmV3IE1lc2gzRChRdWFkR2VvbWV0cnkuY3JlYXRlKCksIG1hdGVyaWFsKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3ViZSAoc2l4IGZhY2VzKSBtZXNoIHdpdGggdGhlIHNwZWNpZmllZCBtYXRlcmlhbC5cbiAgICogQHBhcmFtIG1hdGVyaWFsIFRoZSBtYXRlcmlhbCB0byB1c2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQ3ViZShtYXRlcmlhbDogTWF0ZXJpYWwgPSBuZXcgU3RhbmRhcmRNYXRlcmlhbCgpKSB7XG4gICAgcmV0dXJuIG5ldyBNZXNoM0QoQ3ViZUdlb21ldHJ5LmNyZWF0ZSgpLCBtYXRlcmlhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBsYW5lIChmbGF0IHNxdWFyZSkgbWVzaCB3aXRoIHRoZSBzcGVjaWZpZWQgbWF0ZXJpYWwuXG4gICAqIEBwYXJhbSBtYXRlcmlhbCBUaGUgbWF0ZXJpYWwgdG8gdXNlLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVBsYW5lKG1hdGVyaWFsOiBNYXRlcmlhbCA9IG5ldyBTdGFuZGFyZE1hdGVyaWFsKCkpIHtcbiAgICByZXR1cm4gbmV3IE1lc2gzRChQbGFuZUdlb21ldHJ5LmNyZWF0ZSgpLCBtYXRlcmlhbClcbiAgfVxufSIsImltcG9ydCB7IGdsVEZQYXJzZXIgfSBmcm9tIFwiLi9nbHRmL2dsdGYtcGFyc2VyXCJcbmltcG9ydCB7IGdsVEZBc3NldCB9IGZyb20gXCIuL2dsdGYvZ2x0Zi1hc3NldFwiXG5pbXBvcnQgeyBNYXRlcmlhbEZhY3RvcnkgfSBmcm9tIFwiLi9tYXRlcmlhbC9tYXRlcmlhbC1mYWN0b3J5XCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuL21lc2gvbWVzaFwiXG5pbXBvcnQgeyBBbmltYXRpb24gfSBmcm9tIFwiLi9hbmltYXRpb25cIlxuaW1wb3J0IHsgQ29udGFpbmVyM0QgfSBmcm9tIFwiLi9jb250YWluZXJcIlxuaW1wb3J0IHsgSW5zdGFuY2VkTW9kZWwgfSBmcm9tIFwiLi9pbnN0YW5jZWQtbW9kZWxcIlxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtb2RlbCB3aGljaCBpbmNsdWRlcyBhIGhpZXJhcmNoeSBvZiBtZXNoZXMgYW5kIGFuaW1hdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RlbCBleHRlbmRzIENvbnRhaW5lcjNEIHtcbiAgLyoqIFRoZSBhbmltYXRpb25zIGluY2x1ZGVkIGluIHRoZSBtb2RlbC4gKi9cbiAgYW5pbWF0aW9uczogQW5pbWF0aW9uW10gPSBbXVxuXG4gIC8qKlxuICAgKiBUaGUgbWVzaGVzIGluY2x1ZGVkIGluIHRoZSBtb2RlbC4gTm90ZSB0aGF0IHRoaXMgYXJyYXkgYW5kIHRoZSBhY3R1YWwgXG4gICAqIGNoaWxkZW4gYXJlIG5vdCBhdXRvbWF0aWNhbGx5IHN5bmNocm9uaXplZCBhZnRlciB0aGUgbW9kZWwgaGFzIGJlZW4gbG9hZGVkLlxuICAgKi9cbiAgbWVzaGVzOiBNZXNoM0RbXSA9IFtdXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbW9kZWwgZnJvbSBhIHNvdXJjZS5cbiAgICogQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIHRvIGNyZWF0ZSB0aGUgbW9kZWwgZnJvbS5cbiAgICogQHBhcmFtIG1hdGVyaWFsRmFjdG9yeSBUaGUgZmFjdG9yeSB0byB1c2UgZm9yIGNyZWF0aW5nIG1hdGVyaWFscy5cbiAgICovXG4gIHN0YXRpYyBmcm9tKHNvdXJjZTogZ2xURkFzc2V0LCBtYXRlcmlhbEZhY3Rvcnk/OiBNYXRlcmlhbEZhY3RvcnkpIHtcbiAgICByZXR1cm4gZ2xURlBhcnNlci5jcmVhdGVNb2RlbChzb3VyY2UsIG1hdGVyaWFsRmFjdG9yeSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgbW9kZWwuXG4gICAqL1xuICBjcmVhdGVJbnN0YW5jZSgpIHtcbiAgICByZXR1cm4gSW5zdGFuY2VkTW9kZWwuZnJvbSh0aGlzKVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IFBpY2tpbmdNYW5hZ2VyIH0gZnJvbSBcIi4vcGlja2luZy1tYW5hZ2VyXCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuLi9tZXNoL21lc2hcIlxuaW1wb3J0IHsgTW9kZWwgfSBmcm9tIFwiLi4vbW9kZWxcIlxuaW1wb3J0IHsgUGlja2luZ0lkIH0gZnJvbSBcIi4vcGlja2luZy1pZFwiXG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiLi4vY2FtZXJhL2NhbWVyYVwiXG5cbi8qKlxuICogSGl0IGFyZWEgd2hpY2ggdXNlcyB0aGUgc2hhcGUgb2YgYW4gb2JqZWN0IHRvIGRldGVybWluZSBpbnRlcmFjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFBpY2tpbmdIaXRBcmVhIGltcGxlbWVudHMgUElYSS5JSGl0QXJlYSB7XG4gIHByaXZhdGUgX21hbmFnZXI6IFBpY2tpbmdNYW5hZ2VyXG5cbiAgLyoqIFRoZSBpZCB3aGljaCBtYXBzIHRvIHRoZSBvYmplY3QuICovXG4gIGlkID0gUGlja2luZ0lkLm5leHQoKVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGhpdGFyZWEgdXNpbmcgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gICAqIEBwYXJhbSByZW5kZXJlciBUaGUgcmVuZGVyZXIgdG8gdXNlLlxuICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBtb2RlbCBvciBtZXNoIHRvIHRlc3QgZm9yIGludGVyYWN0aW9uLlxuICAgKiBAcGFyYW0gY2FtZXJhIFRoZSBjYW1lcmEgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcjogUElYSS5SZW5kZXJlciwgcHVibGljIG9iamVjdDogTWVzaDNEIHwgTW9kZWwsIHB1YmxpYyBjYW1lcmE/OiBDYW1lcmEpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gKDxhbnk+cmVuZGVyZXIucGx1Z2lucykucGlja2luZ1xuICB9XG5cbiAgY29udGFpbnMoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFuYWdlci5jb250YWluc0hpdEFyZWEoeCwgeSwgdGhpcylcbiAgfVxufSIsImV4cG9ydCBuYW1lc3BhY2UgUGlja2luZ0lkIHtcbiAgbGV0IGlkID0gMFxuICBleHBvcnQgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZCsrXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIChpZCA+PiAxNikgJiAyNTUsIChpZCA+PiA4KSAmIDI1NSwgaWQgJiAyNTVcbiAgICBdKVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IFBpY2tpbmdIaXRBcmVhIH0gZnJvbSBcIi4vcGlja2luZy1oaXRhcmVhXCJcbmltcG9ydCB7IFBpY2tpbmdNYXAgfSBmcm9tIFwiLi9waWNraW5nLW1hcFwiXG5cbi8qKlxuICogTWFuYWdlcyB0aGUgcGlja2luZyBoaXQgYXJlYXMgYnkga2VlcGluZyB0cmFjayBvbiB3aGljaCBoaXQgYXJlYXMgbmVlZHMgdG8gXG4gKiBiZSBjaGVja2VkIGZvciBpbnRlcmFjdGlvbi4gUmVuZGVycyB0aGUgaGl0IGFyZWEgbWVzaGVzIHRvIGEgdGV4dHVyZSB3aGljaFxuICogaXMgdGhlbiB1c2VkIHRvIG1hcCBhIG1lc2ggdG8gYSB4L3kgY29vcmRpbmF0ZS4gVGhlIHBpY2tpbmcgbWFuYWdlciBpcyBcbiAqIHJlZ2lzdGVyZWQgYXMgYSByZW5kZXJlciBwbHVnaW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBQaWNraW5nTWFuYWdlciBpbXBsZW1lbnRzIFBJWEkuSVJlbmRlcmVyUGx1Z2luIHtcbiAgcHJpdmF0ZSBfbWFwOiBQaWNraW5nTWFwXG4gIHByaXZhdGUgX2hpdEFyZWFzOiBQaWNraW5nSGl0QXJlYVtdID0gW11cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwaWNraW5nIG1hbmFnZXIgdXNpbmcgdGhlIHNwZWNpZmllZCByZW5kZXJlci5cbiAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICB0aGlzLl9tYXAgPSBuZXcgUGlja2luZ01hcCh0aGlzLnJlbmRlcmVyLCAxMjggKiBNYXRoLmZsb29yKHRoaXMucmVuZGVyZXIud2lkdGggLyB0aGlzLnJlbmRlcmVyLmhlaWdodCksIDEyOClcblxuICAgIHJlbmRlcmVyLm9uKFwicG9zdHJlbmRlclwiLCAoKSA9PiB7XG4gICAgICAvLyBCZWNhdXNlIG9mIGhvdyBQaXhpSlMgaW50ZXJhY3Rpb24gd29ya3MgYW5kIHRoZSBkZXNpZ24gb2YgdGhlIHBpY2tpbmcsXG4gICAgICAvLyB0aGUgXCJoaXRUZXN0XCIgZnVuY3Rpb24gbmVlZHMgdG8gYmUgY2FsbGVkLiBPdGhlcndpc2UsIGluIHNvbWUgXG4gICAgICAvLyBjaXJjdW1zdGFuY2VzOyB0aGUgcGlja2luZyBpcyBhZmZlY3RlZCBieSBpbiB3aGljaCBvcmRlciB0aGUgaW50ZXJhY3Rpb24gXG4gICAgICAvLyBvYmplY3Qgd2FzIGFkZGVkIHRvIHRoZSBoZWlyYXJjaHkuXG4gICAgICB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb24uaGl0VGVzdChuZXcgUElYSS5Qb2ludCgwLCAwKSlcblxuICAgICAgaWYgKHRoaXMuX2hpdEFyZWFzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gfVxuXG4gICAgICBsZXQgd2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX21hcC5oZWlnaHQgKiAodGhpcy5yZW5kZXJlci53aWR0aCAvIHRoaXMucmVuZGVyZXIuaGVpZ2h0KSlcbiAgICAgIGlmICh0aGlzLl9tYXAud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIHRoaXMuX21hcC5yZXNpemUod2lkdGgsIHRoaXMuX21hcC5oZWlnaHQpXG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAudXBkYXRlKHRoaXMuX2hpdEFyZWFzKTsgdGhpcy5faGl0QXJlYXMgPSBbXVxuICAgIH0pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbiAgLyoqXG4gICAqIEhpdCB0ZXN0cyBhIGFyZWEgdXNpbmcgdGhlIHNwZWNpZmllZCB4L3kgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB4IFRoZSB4IGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB5IFRoZSB5IGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSBoaXRBcmVhIFRoZSBoaXQgYXJlYSB0byB0ZXN0LlxuICAgKi9cbiAgY29udGFpbnNIaXRBcmVhKHg6IG51bWJlciwgeTogbnVtYmVyLCBoaXRBcmVhOiBQaWNraW5nSGl0QXJlYSkge1xuICAgIGlmICh0aGlzLl9oaXRBcmVhcy5pbmRleE9mKGhpdEFyZWEpIDwgMCkge1xuICAgICAgdGhpcy5faGl0QXJlYXMucHVzaChoaXRBcmVhKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWFwLmNvbnRhaW5zSWQoeCwgeSwgaGl0QXJlYS5pZClcbiAgfVxufVxuXG5QSVhJLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKFwicGlja2luZ1wiLCA8YW55PlBpY2tpbmdNYW5hZ2VyKSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBQaWNraW5nSGl0QXJlYSB9IGZyb20gXCIuL3BpY2tpbmctaGl0YXJlYVwiXG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiLi4vY2FtZXJhL2NhbWVyYVwiXG5pbXBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCJcbmltcG9ydCB7IE1lc2hTaGFkZXIgfSBmcm9tIFwiLi4vbWVzaC9tZXNoLXNoYWRlclwiXG5cbmV4cG9ydCBjbGFzcyBQaWNraW5nTWFwIHtcbiAgcHJpdmF0ZSBfcGl4ZWxzOiBVaW50OEFycmF5XG4gIHByaXZhdGUgX291dHB1dDogUElYSS5SZW5kZXJUZXh0dXJlXG4gIHByaXZhdGUgX3NoYWRlcjogTWVzaFNoYWRlclxuICBwcml2YXRlIF91cGRhdGUgPSAwXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XG4gICAgdGhpcy5fcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KVxuICAgIHRoaXMuX291dHB1dCA9IFBJWEkuUmVuZGVyVGV4dHVyZS5jcmVhdGUoeyB3aWR0aCwgaGVpZ2h0IH0pXG4gICAgdGhpcy5fc2hhZGVyID0gbmV3IE1lc2hTaGFkZXIoXG4gICAgICBQSVhJLlByb2dyYW0uZnJvbShyZXF1aXJlKFwiLi9zaGFkZXIvcGlja2luZy52ZXJ0XCIpLCByZXF1aXJlKFwiLi9zaGFkZXIvcGlja2luZy5mcmFnXCIpKSlcbiAgICB0aGlzLl9vdXRwdXQuZnJhbWVidWZmZXIuYWRkRGVwdGhUZXh0dXJlKClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fb3V0cHV0LmRlc3Ryb3kodHJ1ZSlcbiAgICB0aGlzLl9zaGFkZXIuZGVzdHJveSgpXG4gIH1cblxuICByZXNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcbiAgICB0aGlzLl9waXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpXG4gICAgdGhpcy5fb3V0cHV0LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICB9XG5cbiAgY29udGFpbnNJZCh4OiBudW1iZXIsIHk6IG51bWJlciwgaWQ6IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX3JlbmRlcmVyLnNjcmVlblxuXG4gICAgeCA9IE1hdGguZmxvb3IoeCAvIHdpZHRoICogdGhpcy5fb3V0cHV0LndpZHRoKVxuICAgIHkgPSBNYXRoLmZsb29yKChoZWlnaHQgLSB5KSAvIGhlaWdodCAqIHRoaXMuX291dHB1dC5oZWlnaHQpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChpZFtpXSAhPT0gdGhpcy5fcGl4ZWxzWyh5ICogdGhpcy5fb3V0cHV0LndpZHRoICsgeCkgKiA0ICsgaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl9vdXRwdXQud2lkdGggfVxuXG4gIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLl9vdXRwdXQuaGVpZ2h0IH1cblxuICB1cGRhdGUoaGl0QXJlYXM6IFBpY2tpbmdIaXRBcmVhW10pIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQodGhpcy5fb3V0cHV0KVxuICAgIGlmICh0aGlzLl91cGRhdGUrKyAlIDIgPT09IDApIHtcbiAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0aGUgdXBkYXRlIG1ldGhvZCBhbHRlcm5hdGVzIGJldHdlZW4gcmVuZGVyaW5nIFxuICAgICAgLy8gdGhlIG1lc2hlcyBhbmQgcmVhZGluZyB0aGUgcGl4ZWxzIGZyb20gdGhlIHJlbmRlcmVkIHRleHR1cmUuXG4gICAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmNsZWFyKClcbiAgICAgIGZvciAobGV0IGhpdEFyZWEgb2YgaGl0QXJlYXMpIHtcbiAgICAgICAgbGV0IG1lc2hlcyA9IGhpdEFyZWEub2JqZWN0IGluc3RhbmNlb2YgTWVzaDNEID8gW2hpdEFyZWEub2JqZWN0XSA6IGhpdEFyZWEub2JqZWN0Lm1lc2hlc1xuICAgICAgICBsZXQgY2FtZXJhID0gaGl0QXJlYS5jYW1lcmEgfHwgQ2FtZXJhLm1haW5cbiAgICAgICAgZm9yIChsZXQgbWVzaCBvZiBtZXNoZXMpIHtcbiAgICAgICAgICB0aGlzLl9zaGFkZXIudW5pZm9ybXMudV9Xb3JsZCA9IG1lc2gudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLmFycmF5XG4gICAgICAgICAgdGhpcy5fc2hhZGVyLnVuaWZvcm1zLnVfSWQgPSBoaXRBcmVhLmlkXG4gICAgICAgICAgdGhpcy5fc2hhZGVyLnVuaWZvcm1zLnVfVmlld1Byb2plY3Rpb24gPSBjYW1lcmEudmlld1Byb2plY3Rpb25cbiAgICAgICAgICB0aGlzLl9zaGFkZXIucmVuZGVyKG1lc2gsIHRoaXMuX3JlbmRlcmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2xcbiAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgdGhpcy5fb3V0cHV0LndpZHRoLCB0aGlzLl9vdXRwdXQuaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLl9waXhlbHMpXG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZCh1bmRlZmluZWQpXG4gIH1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2Vsc2VcXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gdmVjMyB1X0lkO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQodV9JZCAvIDI1NS4wLCAxLjApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG5hdHRyaWJ1dGUgdmVjMyBhX1Bvc2l0aW9uO1xcblxcbnVuaWZvcm0gbWF0NCB1X1dvcmxkO1xcbnVuaWZvcm0gbWF0NCB1X1ZpZXdQcm9qZWN0aW9uO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGdsX1Bvc2l0aW9uID0gdV9WaWV3UHJvamVjdGlvbiAqIHVfV29ybGQgKiB2ZWM0KGFfUG9zaXRpb24sIDEuMCk7XFxufVwiIiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IENvbG9yIH0gZnJvbSBcIi4uL2NvbG9yXCJcbmltcG9ydCB7IFJlbmRlclBhc3MgfSBmcm9tIFwiLi9yZW5kZXItcGFzc1wiXG5pbXBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCJcblxuLyoqXG4gKiBQYXNzIHVzZWQgZm9yIHJlbmRlcmluZyBtYXRlcmlhbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRlcmlhbFJlbmRlclBhc3MgaW1wbGVtZW50cyBSZW5kZXJQYXNzIHtcbiAgcHJpdmF0ZSBfcmVuZGVyVGV4dHVyZT86IFBJWEkuUmVuZGVyVGV4dHVyZVxuXG4gIC8qKiBUaGUgY29sb3IgKHIsZyxiLGEpIHVzZWQgZm9yIGNsZWFyaW5nIHRoZSByZW5kZXIgdGV4dHVyZS4gSWYgdGhpcyB2YWx1ZSBpcyBlbXB0eSwgdGhlIHJlbmRlciB0ZXh0dXJlIHdpbGwgbm90IGJlIGNsZWFyZWQuICovXG4gIGNsZWFyQ29sb3I/PSBuZXcgQ29sb3IoMCwgMCwgMCwgMClcblxuICAvKiogVGhlIHRleHR1cmUgdXNlZCB3aGVuIHJlbmRlcmluZyB0byBhIHRleHR1cmUuICovXG4gIGdldCByZW5kZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJUZXh0dXJlXG4gIH1cblxuICBzZXQgcmVuZGVyVGV4dHVyZSh2YWx1ZTogUElYSS5SZW5kZXJUZXh0dXJlIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBtYXRlcmlhbCByZW5kZXIgcGFzcy5cbiAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSByZW5kZXIgcGFzcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZW5kZXJlcjogUElYSS5SZW5kZXJlciwgcHVibGljIG5hbWU6IHN0cmluZykge1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmUgJiYgdGhpcy5jbGVhckNvbG9yKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnRcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHRoaXMuX3JlbmRlclRleHR1cmUpXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuY2xlYXIoQXJyYXkuZnJvbSh0aGlzLmNsZWFyQ29sb3IucmdiYSkpXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChjdXJyZW50KVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcihtZXNoZXM6IE1lc2gzRFtdKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jdXJyZW50XG4gICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHRoaXMuX3JlbmRlclRleHR1cmUpXG4gICAgfVxuICAgIGZvciAobGV0IG1lc2ggb2YgbWVzaGVzKSB7XG4gICAgICBpZiAobWVzaC5tYXRlcmlhbCkge1xuICAgICAgICBtZXNoLm1hdGVyaWFsLnJlbmRlcihtZXNoLCB0aGlzLnJlbmRlcmVyKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoY3VycmVudClcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBNYXRlcmlhbFJlbmRlclBhc3MgfSBmcm9tIFwiLi9tYXRlcmlhbC1yZW5kZXItcGFzc1wiXG5pbXBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCJcbmltcG9ydCB7IFNoYWRvd1JlbmRlclBhc3MgfSBmcm9tIFwiLi4vc2hhZG93L3NoYWRvdy1yZW5kZXItcGFzc1wiXG5pbXBvcnQgeyBQb3N0UHJvY2Vzc2luZ1Nwcml0ZSwgUG9zdFByb2Nlc3NpbmdTcHJpdGVPcHRpb25zIH0gZnJvbSBcIi4uL3Nwcml0ZS9wb3N0LXByb2Nlc3Npbmctc3ByaXRlXCJcbmltcG9ydCB7IE1vZGVsIH0gZnJvbSBcIi4uL21vZGVsXCJcbmltcG9ydCB7IFNoYWRvd0Nhc3RpbmdMaWdodCB9IGZyb20gXCIuLi9zaGFkb3cvc2hhZG93LWNhc3RpbmctbGlnaHRcIlxuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gXCIuL3JlbmRlci1wYXNzXCJcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtbWF0ZXJpYWxcIlxuaW1wb3J0IHsgTWF0ZXJpYWxSZW5kZXJTb3J0VHlwZSB9IGZyb20gXCIuLi9tYXRlcmlhbC9tYXRlcmlhbC1yZW5kZXItc29ydC10eXBlXCJcblxuLyoqXG4gKiBUaGUgc3RhbmRhcmQgcGlwZWxpbmUgcmVuZGVycyBtZXNoZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZW5kZXIgcGFzc2VzLiBUaGUgXG4gKiBzdGFuZGFyZCBwaXBlbGluZSBpcyBjcmVhdGVkIGFuZCB1c2VkIGJ5IGRlZmF1bHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFuZGFyZFBpcGVsaW5lIGV4dGVuZHMgUElYSS5PYmplY3RSZW5kZXJlciB7XG4gIHByaXZhdGUgX3JlbmRlclBhc3NlczogUmVuZGVyUGFzc1tdID0gW11cbiAgcHJpdmF0ZSBfbWVzaGVzOiBNZXNoM0RbXSA9IFtdXG4gIHByaXZhdGUgX21hdGVyaWFsUGFzczogTWF0ZXJpYWxSZW5kZXJQYXNzXG4gIHByaXZhdGUgX3NoYWRvd1Bhc3M6IFNoYWRvd1JlbmRlclBhc3NcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhbmRhcmQgcGlwZWxpbmUgZnJvbSB0aGUgc3BlY2lmaWVkIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgVGhlIHJlbmRlcmVyIHRvIHVzZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgcmV0dXJuIDxTdGFuZGFyZFBpcGVsaW5lPig8YW55PnJlbmRlcmVyLnBsdWdpbnMpLnBpcGVsaW5lXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdGFuZGFyZCBwaXBlbGluZSB1c2luZyB0aGUgc3BlY2lmaWVkIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgVGhlIHJlbmRlcmVyIHRvIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKVxuXG4gICAgdGhpcy5fc2hhZG93UGFzcyA9IHRoaXMuYWRkUmVuZGVyUGFzcyhuZXcgU2hhZG93UmVuZGVyUGFzcyhyZW5kZXJlciwgXCJzaGFkb3dcIikpXG4gICAgdGhpcy5fbWF0ZXJpYWxQYXNzID0gdGhpcy5hZGRSZW5kZXJQYXNzKG5ldyBNYXRlcmlhbFJlbmRlclBhc3MocmVuZGVyZXIsIFwibWF0ZXJpYWxcIikpXG5cbiAgICByZW5kZXJlci5vbihcInByZXJlbmRlclwiLCAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBwYXNzIG9mIHRoaXMuX3JlbmRlclBhc3Nlcykge1xuICAgICAgICBpZiAocGFzcy5jbGVhcikgeyBwYXNzLmNsZWFyKCkgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHJlbmRlciBwYXNzLlxuICAgKiBAcGFyYW0gcmVuZGVyUGFzcyBUaGUgcGFzcyB0byBhZGQuXG4gICAqL1xuICBhZGRSZW5kZXJQYXNzPFQgZXh0ZW5kcyBSZW5kZXJQYXNzPihyZW5kZXJQYXNzOiBUKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBhc3Nlcy5pbmRleE9mKHJlbmRlclBhc3MpIDwgMCkge1xuICAgICAgdGhpcy5fcmVuZGVyUGFzc2VzLnB1c2gocmVuZGVyUGFzcylcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlclBhc3NcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgcmVuZGVyIHBhc3MuXG4gICAqIEBwYXJhbSByZW5kZXJQYXNzIFRoZSBwYXNzIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZVJlbmRlclBhc3MocmVuZGVyUGFzczogUmVuZGVyUGFzcykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcmVuZGVyUGFzc2VzLmluZGV4T2YocmVuZGVyUGFzcylcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5fcmVuZGVyUGFzc2VzLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwb3N0IHByb2Nlc3Npbmcgc3ByaXRlIGFuZCB1c2VzIHRoYXQgdG8gcmVuZGVyIHRvIGl0J3MgXG4gICAqIHRleHR1cmUuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHdoZW4gY3JlYXRpbmcgdGhlIHNwcml0ZS5cbiAgICovXG4gIGNyZWF0ZVBvc3RQcm9jZXNzaW5nU3ByaXRlKG9wdGlvbnM/OiBQb3N0UHJvY2Vzc2luZ1Nwcml0ZU9wdGlvbnMpIHtcbiAgICBjb25zdCBzcHJpdGUgPVxuICAgICAgbmV3IFBvc3RQcm9jZXNzaW5nU3ByaXRlKHRoaXMucmVuZGVyZXIsIG9wdGlvbnMpXG4gICAgdGhpcy5fbWF0ZXJpYWxQYXNzLnJlbmRlclRleHR1cmUgPSBzcHJpdGUucmVuZGVyVGV4dHVyZVxuICAgIHJldHVybiBzcHJpdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbWVzaCB0byBiZSByZW5kZXJlZC5cbiAgICogQHBhcmFtIG1lc2ggTWVzaCB0byBhZGQuXG4gICAqL1xuICByZW5kZXIobWVzaDogTWVzaDNEKSB7XG4gICAgdGhpcy5fbWVzaGVzLnB1c2gobWVzaClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBhZGRlZCBtZXNoZXMgdXNpbmcgdGhlIHNwZWNpZmllZCByZW5kZXIgcGFzc2VzLlxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgdGhpcy5zb3J0KClcbiAgICBmb3IgKGxldCBwYXNzIG9mIHRoaXMuX3JlbmRlclBhc3Nlcykge1xuICAgICAgcGFzcy5yZW5kZXIodGhpcy5fbWVzaGVzLmZpbHRlcihtZXNoID0+IG1lc2guaXNSZW5kZXJQYXNzRW5hYmxlZChwYXNzLm5hbWUpKSlcbiAgICB9XG4gICAgdGhpcy5fbWVzaGVzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyB0aGUgbWVzaGVzIGJ5IHJlbmRlcmluZyBvcmRlci5cbiAgICovXG4gIHNvcnQoKSB7XG4gICAgdGhpcy5fbWVzaGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGlmICghYS5tYXRlcmlhbCB8fCAhYi5tYXRlcmlhbCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgaWYgKGEubWF0ZXJpYWwucmVuZGVyU29ydFR5cGUgIT09IGIubWF0ZXJpYWwucmVuZGVyU29ydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGEubWF0ZXJpYWwucmVuZGVyU29ydFR5cGUgPT09IE1hdGVyaWFsUmVuZGVyU29ydFR5cGUudHJhbnNwYXJlbnQgPyAxIDogLTFcbiAgICAgIH1cbiAgICAgIHJldHVybiAwXG4gICAgfSlcbiAgfVxuXG4gIC8qKiBUaGUgcGFzcyB1c2VkIGZvciByZW5kZXJpbmcgc2hhZG93cy4gKi9cbiAgZ2V0IHNoYWRvd1Bhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NoYWRvd1Bhc3NcbiAgfVxuXG4gIC8qKiBUaGUgcGFzcyB1c2VkIGZvciByZW5kZXJpbmcgbWF0ZXJpYWxzLiAqL1xuICBnZXQgbWF0ZXJpYWxQYXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbFBhc3NcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHNoYWRvd3MgZm9yIHRoZSBzcGVjaWZpZWQgb2JqZWN0LiBBZGRzIHRoZSBzaGFkb3cgcmVuZGVyIHBhc3MgdG8gXG4gICAqIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGFuZCBlbmFibGVzIHRoZSBzdGFuZGFyZCBtYXRlcmlhbCB0byB1c2UgdGhlIGNhc3RpbmcgXG4gICAqIGxpZ2h0LlxuICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBtZXNoIG9yIG1vZGVsIHRvIGVuYWJsZSBzaGFkb3dzIGZvci5cbiAgICogQHBhcmFtIGxpZ2h0IFRoZSBzaGFkb3cgY2FzdGluZyBsaWdodCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgXG4gICAqIG9iamVjdCB3aGVuIHVzaW5nIHRoZSBzdGFuZGFyZCBtYXRlcmlhbC5cbiAgICovXG4gIGVuYWJsZVNoYWRvd3Mob2JqZWN0OiBNZXNoM0QgfCBNb2RlbCwgbGlnaHQ/OiBTaGFkb3dDYXN0aW5nTGlnaHQpIHtcbiAgICBsZXQgbWVzaGVzID0gb2JqZWN0IGluc3RhbmNlb2YgTW9kZWwgPyBvYmplY3QubWVzaGVzIDogW29iamVjdF1cbiAgICBmb3IgKGxldCBtZXNoIG9mIG1lc2hlcykge1xuICAgICAgaWYgKGxpZ2h0ICYmIG1lc2gubWF0ZXJpYWwgaW5zdGFuY2VvZiBTdGFuZGFyZE1hdGVyaWFsKSB7XG4gICAgICAgIG1lc2gubWF0ZXJpYWwuc2hhZG93Q2FzdGluZ0xpZ2h0ID0gbGlnaHRcbiAgICAgIH1cbiAgICAgIG1lc2guZW5hYmxlUmVuZGVyUGFzcyh0aGlzLl9zaGFkb3dQYXNzLm5hbWUpXG4gICAgfVxuICAgIGlmIChsaWdodCkge1xuICAgICAgdGhpcy5fc2hhZG93UGFzcy5hZGRTaGFkb3dDYXN0aW5nTGlnaHQobGlnaHQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHNoYWRvd3MgZm9yIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBtZXNoIG9yIG1vZGVsIHRvIGRpc2FibGUgc2hhZG93cyBmb3IuXG4gICAqL1xuICBkaXNhYmxlU2hhZG93cyhvYmplY3Q6IE1lc2gzRCB8IE1vZGVsKSB7XG4gICAgbGV0IG1lc2hlcyA9IG9iamVjdCBpbnN0YW5jZW9mIE1vZGVsID8gb2JqZWN0Lm1lc2hlcyA6IFtvYmplY3RdXG4gICAgZm9yIChsZXQgbWVzaCBvZiBtZXNoZXMpIHtcbiAgICAgIGlmIChtZXNoLm1hdGVyaWFsIGluc3RhbmNlb2YgU3RhbmRhcmRNYXRlcmlhbCkge1xuICAgICAgICBtZXNoLm1hdGVyaWFsLnNoYWRvd0Nhc3RpbmdMaWdodCA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgICAgbWVzaC5kaXNhYmxlUmVuZGVyUGFzcyh0aGlzLl9zaGFkb3dQYXNzLm5hbWUpXG4gICAgfVxuICB9XG59XG5cblBJWEkuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oXCJwaXBlbGluZVwiLCA8YW55PlN0YW5kYXJkUGlwZWxpbmUpIiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBBcnJheVJlc291cmNlOiB0eXBlb2YgUElYSS5BcnJheVJlc291cmNlID0gUElYSS5BcnJheVJlc291cmNlIHx8IFBJWEkucmVzb3VyY2VzLkFycmF5UmVzb3VyY2UiLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGNvbnN0IEJhc2VJbWFnZVJlc291cmNlOiB0eXBlb2YgUElYSS5CYXNlSW1hZ2VSZXNvdXJjZSA9IFBJWEkuQmFzZUltYWdlUmVzb3VyY2UgfHwgUElYSS5yZXNvdXJjZXMuQmFzZUltYWdlUmVzb3VyY2UiLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGNvbnN0IEJ1ZmZlclJlc291cmNlOiB0eXBlb2YgUElYSS5CdWZmZXJSZXNvdXJjZSA9IFBJWEkuQnVmZmVyUmVzb3VyY2UgfHwgUElYSS5yZXNvdXJjZXMuQnVmZmVyUmVzb3VyY2UiLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGNvbnN0IEN1YmVSZXNvdXJjZTogdHlwZW9mIFBJWEkuQ3ViZVJlc291cmNlID0gUElYSS5DdWJlUmVzb3VyY2UgfHwgUElYSS5yZXNvdXJjZXMuQ3ViZVJlc291cmNlIiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmV4cG9ydCBuYW1lc3BhY2UgUGxhdGZvcm0ge1xuICBsZXQgX21heFZlcnRleFVuaWZvcm1WZWN0b3JzOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0TWF4VmVydGV4VW5pZm9ybVZlY3RvcnMocmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICBpZiAoX21heFZlcnRleFVuaWZvcm1WZWN0b3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfbWF4VmVydGV4VW5pZm9ybVZlY3RvcnNcbiAgICB9XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbFxuICAgIF9tYXhWZXJ0ZXhVbmlmb3JtVmVjdG9ycyA9IDxudW1iZXI+Z2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKVxuICAgIHJldHVybiBfbWF4VmVydGV4VW5pZm9ybVZlY3RvcnNcbiAgfVxuXG4gIGxldCBfaXNGbG9hdFRleHR1cmVTdXBwb3J0ZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWRcblxuICBleHBvcnQgZnVuY3Rpb24gaXNGbG9hdFRleHR1cmVTdXBwb3J0ZWQocmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICBpZiAocmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDIpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChfaXNGbG9hdFRleHR1cmVTdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9pc0Zsb2F0VGV4dHVyZVN1cHBvcnRlZFxuICAgIH1cbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsXG4gICAgY29uc3QgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIilcbiAgICBpZiAoZXh0KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSlcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDgsIDgsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKVxuICAgIF9pc0Zsb2F0VGV4dHVyZVN1cHBvcnRlZCA9IGdsLmdldEVycm9yKCkgPT09IGdsLk5PX0VSUk9SXG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKVxuICAgIHJldHVybiBfaXNGbG9hdFRleHR1cmVTdXBwb3J0ZWRcbiAgfVxuXG4gIGxldCBfaXNIYWxmRmxvYXRGcmFtZWJ1ZmZlclN1cHBvcnRlZDogYm9vbGVhbiB8IHVuZGVmaW5lZFxuXG4gIGV4cG9ydCBmdW5jdGlvbiBpc0hhbGZGbG9hdEZyYW1lYnVmZmVyU3VwcG9ydGVkKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgaWYgKHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoX2lzSGFsZkZsb2F0RnJhbWVidWZmZXJTdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9pc0hhbGZGbG9hdEZyYW1lYnVmZmVyU3VwcG9ydGVkXG4gICAgfVxuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2xcbiAgICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpXG4gICAgaWYgKCFleHQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSlcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDgsIDgsIDAsIGdsLlJHQkEsIGV4dC5IQUxGX0ZMT0FUX09FUywgbnVsbClcbiAgICBjb25zdCBmYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiKVxuICAgIGNvbnN0IGF0dGFjaG1lbnRQb2ludCA9IGdsLkNPTE9SX0FUVEFDSE1FTlQwXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnRQb2ludCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMClcbiAgICBfaXNIYWxmRmxvYXRGcmFtZWJ1ZmZlclN1cHBvcnRlZCA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURVxuICAgIHJldHVybiBfaXNIYWxmRmxvYXRGcmFtZWJ1ZmZlclN1cHBvcnRlZFxuICB9XG5cbiAgbGV0IF9pc0Zsb2F0RnJhbWVidWZmZXJTdXBwb3J0ZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWRcblxuICBleHBvcnQgZnVuY3Rpb24gaXNGbG9hdEZyYW1lYnVmZmVyU3VwcG9ydGVkKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgaWYgKHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoX2lzRmxvYXRGcmFtZWJ1ZmZlclN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX2lzRmxvYXRGcmFtZWJ1ZmZlclN1cHBvcnRlZFxuICAgIH1cbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsXG4gICAgY29uc3QgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIilcbiAgICBpZiAoIWV4dCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKVxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgOCwgOCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpXG4gICAgY29uc3QgZmIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYilcbiAgICBjb25zdCBhdHRhY2htZW50UG9pbnQgPSBnbC5DT0xPUl9BVFRBQ0hNRU5UMFxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50UG9pbnQsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApXG4gICAgX2lzRmxvYXRGcmFtZWJ1ZmZlclN1cHBvcnRlZCA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURVxuICAgIHJldHVybiBfaXNGbG9hdEZyYW1lYnVmZmVyU3VwcG9ydGVkXG4gIH1cblxuICBsZXQgX2lzRmxvYXRMaW5lYXJTdXBwb3J0ZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWRcblxuICBleHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNGbG9hdExpbmVhcihyZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIGlmIChfaXNGbG9hdExpbmVhclN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX2lzRmxvYXRMaW5lYXJTdXBwb3J0ZWRcbiAgICB9XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbFxuICAgIF9pc0Zsb2F0TGluZWFyU3VwcG9ydGVkID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpICE9PSBudWxsXG4gICAgcmV0dXJuIF9pc0Zsb2F0TGluZWFyU3VwcG9ydGVkXG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gaXNTaGFkZXJUZXh0dXJlTG9kU3VwcG9ydGVkKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgaWYgKHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyZXIuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFwiKSAhPT0gbnVsbFxuICB9XG5cbiAgbGV0IF9pc0luc3RhbmNpbmdTdXBwb3J0ZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWRcblxuICBleHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jaW5nU3VwcG9ydGVkKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgaWYgKF9pc0luc3RhbmNpbmdTdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9pc0luc3RhbmNpbmdTdXBwb3J0ZWRcbiAgICB9XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbFxuICAgIF9pc0luc3RhbmNpbmdTdXBwb3J0ZWQgPSBnbC5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKSAhPT0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIF9pc0luc3RhbmNpbmdTdXBwb3J0ZWRcbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWMyIHZfVVYxO1xcblxcbnVuaWZvcm0gdmVjMiB1X0JsdXJTY2FsZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X0ZpbHRlclNhbXBsZXI7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXG4gIGNvbG9yICs9IHRleHR1cmUyRCh1X0ZpbHRlclNhbXBsZXIsIHZfVVYxICsgKHZlYzIoLTMuMCkgKiB1X0JsdXJTY2FsZS54eSkpICogKDEuMC82NC4wKTtcXG4gIGNvbG9yICs9IHRleHR1cmUyRCh1X0ZpbHRlclNhbXBsZXIsIHZfVVYxICsgKHZlYzIoLTIuMCkgKiB1X0JsdXJTY2FsZS54eSkpICogKDYuMC82NC4wKTtcXG4gIGNvbG9yICs9IHRleHR1cmUyRCh1X0ZpbHRlclNhbXBsZXIsIHZfVVYxICsgKHZlYzIoLTEuMCkgKiB1X0JsdXJTY2FsZS54eSkpICogKDE1LjAvNjQuMCk7XFxuICBjb2xvciArPSB0ZXh0dXJlMkQodV9GaWx0ZXJTYW1wbGVyLCB2X1VWMSArICh2ZWMyKCswLjApICogdV9CbHVyU2NhbGUueHkpKSAqICgyMC4wLzY0LjApO1xcbiAgY29sb3IgKz0gdGV4dHVyZTJEKHVfRmlsdGVyU2FtcGxlciwgdl9VVjEgKyAodmVjMigrMS4wKSAqIHVfQmx1clNjYWxlLnh5KSkgKiAoMTUuMC82NC4wKTtcXG4gIGNvbG9yICs9IHRleHR1cmUyRCh1X0ZpbHRlclNhbXBsZXIsIHZfVVYxICsgKHZlYzIoKzIuMCkgKiB1X0JsdXJTY2FsZS54eSkpICogKDYuMC82NC4wKTtcXG4gIGNvbG9yICs9IHRleHR1cmUyRCh1X0ZpbHRlclNhbXBsZXIsIHZfVVYxICsgKHZlYzIoKzMuMCkgKiB1X0JsdXJTY2FsZS54eSkpICogKDEuMC82NC4wKTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG5hdHRyaWJ1dGUgdmVjMyBhX1Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfVVYxO1xcblxcbnZhcnlpbmcgdmVjMiB2X1VWMTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2X1VWMSA9IGFfVVYxO1xcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfUG9zaXRpb24sIDEuMCk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXFxuXFxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2Vsc2VcXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLno7XFxuICBmbG9hdCBkeCA9IDAuMDtcXG4gIGZsb2F0IGR5ID0gMC4wO1xcblxcbiAgI2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcbiAgICBkeCA9IGRGZHgoZGVwdGgpO1xcbiAgICBkeSA9IGRGZHkoZGVwdGgpO1xcbiAgI2VuZGlmXFxuXFxuICBmbG9hdCBtb21lbnQyID0gZGVwdGggKiBkZXB0aCArIDAuMjUgKiAoZHggKiBkeCArIGR5ICogZHkpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAgLSBkZXB0aCwgMS4wIC0gbW9tZW50MiwgMC4wLCAwLjApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG4jZGVmaW5lIEZFQVRVUkVTXFxuXFxuYXR0cmlidXRlIHZlYzMgYV9Qb3NpdGlvbjtcXG5cXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxuYXR0cmlidXRlIHZlYzQgYV9Kb2ludDE7XFxuYXR0cmlidXRlIHZlYzQgYV9XZWlnaHQxO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gbWF0NCB1X1ZpZXdQcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1X01vZGVsTWF0cml4O1xcblxcbiNpZmRlZiBVU0VfU0tJTk5JTkdcXG4gICNpZmRlZiBVU0VfU0tJTk5JTkdfVEVYVFVSRVxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2pvaW50TWF0cml4U2FtcGxlcjtcXG4gICNlbHNlXFxuICAgIHVuaWZvcm0gbWF0NCB1X2pvaW50TWF0cml4W01BWF9KT0lOVF9DT1VOVF07XFxuICAjZW5kaWZcXG4jZW5kaWZcXG5cXG4vLyB0aGVzZSBvZmZzZXRzIGFzc3VtZSB0aGUgdGV4dHVyZSBpcyA0IHBpeGVscyBhY3Jvc3NcXG4jZGVmaW5lIFJPVzBfVSAoKDAuNSArIDAuMCkgLyA0LjApXFxuI2RlZmluZSBST1cxX1UgKCgwLjUgKyAxLjApIC8gNC4wKVxcbiNkZWZpbmUgUk9XMl9VICgoMC41ICsgMi4wKSAvIDQuMClcXG4jZGVmaW5lIFJPVzNfVSAoKDAuNSArIDMuMCkgLyA0LjApXFxuXFxuI2lmZGVmIFVTRV9TS0lOTklOR1xcbm1hdDQgZ2V0Sm9pbnRNYXRyaXgoZmxvYXQgYm9uZU5keCkge1xcbiAgICAjaWZkZWYgVVNFX1NLSU5OSU5HX1RFWFRVUkVcXG4gICAgZmxvYXQgdiA9IChib25lTmR4ICsgMC41KSAvIGZsb2F0KE1BWF9KT0lOVF9DT1VOVCk7XFxuICAgIHJldHVybiBtYXQ0KFxcbiAgICAgICAgdGV4dHVyZTJEKHVfam9pbnRNYXRyaXhTYW1wbGVyLCB2ZWMyKFJPVzBfVSwgdikpICogMi4wIC0gMS4wLFxcbiAgICAgICAgdGV4dHVyZTJEKHVfam9pbnRNYXRyaXhTYW1wbGVyLCB2ZWMyKFJPVzFfVSwgdikpICogMi4wIC0gMS4wLFxcbiAgICAgICAgdGV4dHVyZTJEKHVfam9pbnRNYXRyaXhTYW1wbGVyLCB2ZWMyKFJPVzJfVSwgdikpICogMi4wIC0gMS4wLFxcbiAgICAgICAgdGV4dHVyZTJEKHVfam9pbnRNYXRyaXhTYW1wbGVyLCB2ZWMyKFJPVzNfVSwgdikpICogMi4wIC0gMS4wXFxuICAgICk7XFxuICAgICNlbHNlXFxuICAgIHJldHVybiB1X2pvaW50TWF0cml4W2ludChib25lTmR4KV07XFxuICAgICNlbmRpZlxcbn1cXG5cXG5tYXQ0IGdldFNraW5uaW5nTWF0cml4KClcXG57XFxuICAgIG1hdDQgc2tpbiA9IG1hdDQoMCk7XFxuICAgIHNraW4gKz1cXG4gICAgICAgIGFfV2VpZ2h0MS54ICogZ2V0Sm9pbnRNYXRyaXgoYV9Kb2ludDEueCkgK1xcbiAgICAgICAgYV9XZWlnaHQxLnkgKiBnZXRKb2ludE1hdHJpeChhX0pvaW50MS55KSArXFxuICAgICAgICBhX1dlaWdodDEueiAqIGdldEpvaW50TWF0cml4KGFfSm9pbnQxLnopICtcXG4gICAgICAgIGFfV2VpZ2h0MS53ICogZ2V0Sm9pbnRNYXRyaXgoYV9Kb2ludDEudyk7XFxuICAgIHJldHVybiBza2luO1xcbn1cXG4jZW5kaWZcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9Qb3NpdGlvbiwgMS4wKTtcXG4gICNpZmRlZiBVU0VfU0tJTk5JTkdcXG4gICAgcG9zID0gZ2V0U2tpbm5pbmdNYXRyaXgoKSAqIHBvcztcXG4gICNlbmRpZlxcbiAgZ2xfUG9zaXRpb24gPSB1X1ZpZXdQcm9qZWN0aW9uTWF0cml4ICogdV9Nb2RlbE1hdHJpeCAqIHBvcztcXG59XCIiLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgTGlnaHQgfSBmcm9tIFwiLi4vbGlnaHRpbmcvbGlnaHRcIlxuaW1wb3J0IHsgTGlnaHRUeXBlIH0gZnJvbSBcIi4uL2xpZ2h0aW5nL2xpZ2h0LXR5cGVcIlxuaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSBcIi4uL2NhbWVyYS9jYW1lcmFcIlxuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tIFwiLi4vcGxhdGZvcm1cIlxuaW1wb3J0IHsgU2hhZG93VGV4dHVyZSB9IGZyb20gXCIuL3NoYWRvdy10ZXh0dXJlXCJcbmltcG9ydCB7IFNoYWRvd1F1YWxpdHkgfSBmcm9tIFwiLi9zaGFkb3ctcXVhbGl0eVwiXG5pbXBvcnQgeyBTaGFkb3dNYXRoIH0gZnJvbSBcIi4vc2hhZG93LW1hdGhcIlxuXG4vKipcbiAqIENvbnRhaW5zIHRoZSByZXF1aXJlZCBjb21wb25lbnRzIHVzZWQgZm9yIHJlbmRlcmluZyBhIHNoYWRvdyBjYXN0ZWQgYnkgYSBsaWdodC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNoYWRvd0Nhc3RpbmdMaWdodCB7XG4gIHByaXZhdGUgX3NoYWRvd1RleHR1cmU6IFBJWEkuUmVuZGVyVGV4dHVyZVxuICBwcml2YXRlIF9maWx0ZXJUZXh0dXJlOiBQSVhJLlJlbmRlclRleHR1cmVcbiAgcHJpdmF0ZSBfbGlnaHRWaWV3UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpXG5cbiAgLyoqIFRoZSBsaWdodCB2aWV3IHByb2plY3Rpb24gbWF0cml4LiAqL1xuICBnZXQgbGlnaHRWaWV3UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlnaHRWaWV3UHJvamVjdGlvblxuICB9XG5cbiAgLyoqIFRoZSBjYW1lcmEgdG8gZm9sbG93IHdoZW4gdXNpbmcgZGlyZWN0aW9uYWwgbGlnaHRzLiAqL1xuICBjYW1lcmE/OiBDYW1lcmFcblxuICAvKipcbiAgICogVmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgc2hhZG93IHNob3VsZCBmb2xsb3cgdGhlIHNwZWNpZmllZCBjYW1lcmEuIElmIHRoZSBcbiAgICogY2FtZXJhIGlzIG5vdCBzZXQsIHRoZSBtYWluIGNhbWVyYSB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdC4gT25seSBhdmFpbGFibGUgXG4gICAqIHdoZW4gdXNpbmcgZGlyZWN0aW9uYWwgbGlnaHRzLlxuICAgKi9cbiAgZm9sbG93Q2FtZXJhID0gdHJ1ZVxuXG4gIC8qKlxuICAgKiBUaGUgcmVuZGVyZWQgc2hhZG93IHRleHR1cmUuXG4gICAqL1xuICBnZXQgc2hhZG93VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hhZG93VGV4dHVyZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZW5kZXJlZCBmaWx0ZXIgdGV4dHVyZS5cbiAgICovXG4gIGdldCBmaWx0ZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl9maWx0ZXJUZXh0dXJlXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzaGFkb3cgY2FzdGluZyBsaWdodCB1c2VkIGZvciByZW5kZXJpbmcgYSBzaGFkb3cgdGV4dHVyZS5cbiAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UuXG4gICAqIEBwYXJhbSBsaWdodCBUaGUgbGlnaHQgd2hpY2ggaXMgY2FzdGluZyB0aGUgc2hhZG93LlxuICAgKiBAcGFyYW0gc2hhZG93VGV4dHVyZVNpemUgVGhlIHNpemUgKHdpZHRoL2hlaWdodCkgaW4gcGl4ZWxzIGZvciB0aGUgc2hhZG93IFxuICAgKiB0ZXh0dXJlLiBJbmNyZWFzaW5nIHRoZSBzaXplIHdpbGwgaW1wcm92ZSB0aGUgcXVhbGl0eSBvZiB0aGUgc2hhZG93LlxuICAgKiBAcGFyYW0gc2hhZG93QXJlYSBUaGUgYXJlYSBpbiB1bml0cyBvZiB0aGUgc2hhZG93IHdoZW4gdXNpbmcgZGlyZWN0aW9uYWwgXG4gICAqIGxpZ2h0cy4gUmVkdWNpbmcgdGhlIGFyZWEgd2lsbCBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIHRoZSBzaGFkb3cuXG4gICAqIEBwYXJhbSBzb2Z0bmVzcyBUaGUgc29mdG5lc3Mgb2YgdGhlIGVkZ2VzIG9mIHRoZSBzaGFkb3cuXG4gICAqIEBwYXJhbSBxdWFsaXR5IFRoZSBxdWFsaXR5IChwcmVjaXNpb24pIG9mIHRoZSBzaGFkb3cuIElmIHRoZSBxdWFsaXR5IGlzIG5vdCBcbiAgICogc3VwcG9ydGVkIGJ5IGN1cnJlbnQgcGxhdGZvcm0sIGEgbG93ZXIgcXVhbGl0eSB3aWxsIGJlIHNlbGVjdGVkIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIsIHB1YmxpYyBsaWdodDogTGlnaHQsIHNoYWRvd1RleHR1cmVTaXplOiBudW1iZXIsIHB1YmxpYyBzaGFkb3dBcmVhOiBudW1iZXIsIHB1YmxpYyBzb2Z0bmVzcyA9IDAsIHF1YWxpdHkgPSBTaGFkb3dRdWFsaXR5Lm1lZGl1bSkge1xuICAgIGlmIChsaWdodC50eXBlID09PSBMaWdodFR5cGUucG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBJWEkzRDogT25seSBkaXJlY3Rpb25hbCBhbmQgc3BvdCBsaWdodHMgYXJlIHN1cHBvcnRlZCBhcyBzaGFkb3cgY2FzdGVycy5cIilcbiAgICB9XG4gICAgdGhpcy5fc2hhZG93VGV4dHVyZSA9IFNoYWRvd1RleHR1cmUuY3JlYXRlKHJlbmRlcmVyLCBzaGFkb3dUZXh0dXJlU2l6ZSwgcXVhbGl0eSlcbiAgICB0aGlzLl9zaGFkb3dUZXh0dXJlLmJhc2VUZXh0dXJlLmZyYW1lYnVmZmVyLmFkZERlcHRoVGV4dHVyZSgpXG4gICAgdGhpcy5fZmlsdGVyVGV4dHVyZSA9IFNoYWRvd1RleHR1cmUuY3JlYXRlKHJlbmRlcmVyLCBzaGFkb3dUZXh0dXJlU2l6ZSwgcXVhbGl0eSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgc2hhZG93IGNhc3RpbmcgbGlnaHQgYW5kIGl0J3MgdXNlZCByZXNvdXJjZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3NoYWRvd1RleHR1cmUuZGVzdHJveSh0cnVlKVxuICAgIHRoaXMuX2ZpbHRlclRleHR1cmUuZGVzdHJveSh0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgcmVuZGVyZWQgc2hhZG93IHRleHR1cmUuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZCh0aGlzLl9zaGFkb3dUZXh0dXJlKVxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jbGVhcihbMCwgMCwgMCwgMF0sIHRoaXMucmVuZGVyZXIuZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMucmVuZGVyZXIuZ2wuREVQVEhfQlVGRkVSX0JJVClcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZCh1bmRlZmluZWQpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbGlnaHQgdmlldyBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgICovXG4gIHVwZGF0ZUxpZ2h0Vmlld1Byb2plY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGlnaHQudHlwZSA9PT0gTGlnaHRUeXBlLmRpcmVjdGlvbmFsKSB7XG4gICAgICBTaGFkb3dNYXRoLmNhbGN1bGF0ZURpcmVjdGlvbmFsTGlnaHRWaWV3UHJvamVjdGlvbih0aGlzKVxuICAgIH0gZWxzZSBpZiAodGhpcy5saWdodC50eXBlID09PSBMaWdodFR5cGUuc3BvdCkge1xuICAgICAgU2hhZG93TWF0aC5jYWxjdWxhdGVTcG90TGlnaHRWaWV3UHJvamVjdGlvbih0aGlzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyBpZiBtZWRpdW0gcXVhbGl0eSAoMTYtYml0IHByZWNpc2lvbikgc2hhZG93cyBpcyBcbiAgICogc3VwcG9ydGVkIGJ5IGN1cnJlbnQgcGxhdGZvcm0uXG4gICAqIEBwYXJhbSByZW5kZXJlciBUaGUgcmVuZGVyZXIgdG8gdXNlLlxuICAgKi9cbiAgc3RhdGljIGlzTWVkaXVtUXVhbGl0eVN1cHBvcnRlZChyZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIHJldHVybiBQbGF0Zm9ybS5pc0hhbGZGbG9hdEZyYW1lYnVmZmVyU3VwcG9ydGVkKHJlbmRlcmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIGlmIGhpZ2ggcXVhbGl0eSAoMzItYml0IHByZWNpc2lvbikgc2hhZG93cyBpcyBcbiAgICogc3VwcG9ydGVkIGJ5IGN1cnJlbnQgcGxhdGZvcm0uXG4gICAqIEBwYXJhbSByZW5kZXJlciBUaGUgcmVuZGVyZXIgdG8gdXNlLlxuICAgKi9cbiAgc3RhdGljIGlzSGlnaFF1YWxpdHlTdXBwb3J0ZWQocmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICByZXR1cm4gUGxhdGZvcm0uaXNGbG9hdEZyYW1lYnVmZmVyU3VwcG9ydGVkKHJlbmRlcmVyKVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IE1lc2hTaGFkZXIgfSBmcm9tIFwiLi4vbWVzaC9tZXNoLXNoYWRlclwiXG5pbXBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCJcbmltcG9ydCB7IFNoYWRvd0Nhc3RpbmdMaWdodCB9IGZyb20gXCIuL3NoYWRvdy1jYXN0aW5nLWxpZ2h0XCJcblxuZXhwb3J0IGNsYXNzIFNoYWRvd0ZpbHRlciB7XG4gIHByaXZhdGUgX2dhdXNzaWFuQmx1clNoYWRlcjogTWVzaFNoYWRlclxuICBwcml2YXRlIF9tZXNoOiBNZXNoM0RcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICB0aGlzLl9tZXNoID0gTWVzaDNELmNyZWF0ZVF1YWQoKVxuICAgIHRoaXMuX2dhdXNzaWFuQmx1clNoYWRlciA9IG5ldyBNZXNoU2hhZGVyKFBJWEkuUHJvZ3JhbS5mcm9tKFxuICAgICAgcmVxdWlyZShcIi4vc2hhZGVyL2dhdXNzaWFuLWJsdXIudmVydFwiKSxcbiAgICAgIHJlcXVpcmUoXCIuL3NoYWRlci9nYXVzc2lhbi1ibHVyLmZyYWdcIilcbiAgICApKVxuICB9XG5cbiAgYXBwbHlHYXVzc2lhbkJsdXIobGlnaHQ6IFNoYWRvd0Nhc3RpbmdMaWdodCkge1xuICAgIHRoaXMuYXBwbHlCbHVyU2NhbGUobGlnaHQuc2hhZG93VGV4dHVyZSwgbGlnaHQuZmlsdGVyVGV4dHVyZSxcbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIGxpZ2h0LnNvZnRuZXNzIC8gbGlnaHQuc2hhZG93VGV4dHVyZS5oZWlnaHRdKSlcbiAgICB0aGlzLmFwcGx5Qmx1clNjYWxlKGxpZ2h0LmZpbHRlclRleHR1cmUsIGxpZ2h0LnNoYWRvd1RleHR1cmUsXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KFtsaWdodC5zb2Z0bmVzcyAvIGxpZ2h0LnNoYWRvd1RleHR1cmUud2lkdGgsIDBdKSlcbiAgfVxuXG4gIGFwcGx5Qmx1clNjYWxlKGlucHV0OiBQSVhJLlJlbmRlclRleHR1cmUsIG91dHB1dDogUElYSS5SZW5kZXJUZXh0dXJlLCBzY2FsZTogRmxvYXQzMkFycmF5KSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQob3V0cHV0KVxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jbGVhcigpXG5cbiAgICB0aGlzLl9nYXVzc2lhbkJsdXJTaGFkZXIudW5pZm9ybXMudV9GaWx0ZXJTYW1wbGVyID0gaW5wdXRcbiAgICB0aGlzLl9nYXVzc2lhbkJsdXJTaGFkZXIudW5pZm9ybXMudV9CbHVyU2NhbGUgPSBzY2FsZVxuICAgIHRoaXMuX2dhdXNzaWFuQmx1clNoYWRlci5yZW5kZXIodGhpcy5fbWVzaCwgdGhpcy5yZW5kZXJlcilcblxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHVuZGVmaW5lZClcbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBTaGFkb3dDYXN0aW5nTGlnaHQgfSBmcm9tIFwiLi9zaGFkb3ctY2FzdGluZy1saWdodFwiXG5pbXBvcnQgeyBNYXQ0IH0gZnJvbSBcIi4uL21hdGgvbWF0NFwiXG5pbXBvcnQgeyBMaWdodFR5cGUgfSBmcm9tIFwiLi4vbGlnaHRpbmcvbGlnaHQtdHlwZVwiXG5pbXBvcnQgeyBWZWMzIH0gZnJvbSBcIi4uL21hdGgvdmVjM1wiXG5pbXBvcnQgeyBRdWF0IH0gZnJvbSBcIi4uL21hdGgvcXVhdFwiXG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiLi4vY2FtZXJhL2NhbWVyYVwiXG5cbmV4cG9ydCBuYW1lc3BhY2UgU2hhZG93TWF0aCB7XG5cbiAgY29uc3QgX2xpZ2h0UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpXG4gIGNvbnN0IF9saWdodFZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KDE2KVxuICBjb25zdCBfdXAgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwXSlcbiAgY29uc3QgX2Nvbmp1Z2F0ZVJvdGF0aW9uID0gbmV3IEZsb2F0MzJBcnJheSg0KVxuICBjb25zdCBfbGlnaHRTcGFjZVBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICBjb25zdCBfbGlnaHRTcGFjZUZvcndhcmQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gIGNvbnN0IF9jYW1lcmFUYXJnZXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gIGNvbnN0IF9jYW1lcmFGb3J3YXJkID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEaXJlY3Rpb25hbExpZ2h0Vmlld1Byb2plY3Rpb24oc2hhZG93Q2FzdGluZ0xpZ2h0OiBTaGFkb3dDYXN0aW5nTGlnaHQpIHtcbiAgICBpZiAoc2hhZG93Q2FzdGluZ0xpZ2h0LmxpZ2h0LnR5cGUgIT09IExpZ2h0VHlwZS5kaXJlY3Rpb25hbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxldCBoYWxmU2hhZG93QXJlYSA9IHNoYWRvd0Nhc3RpbmdMaWdodC5zaGFkb3dBcmVhIC8gMlxuICAgIGxldCB3b3JsZFRleGVsU2l6ZSA9IChoYWxmU2hhZG93QXJlYSAqIDIpIC8gc2hhZG93Q2FzdGluZ0xpZ2h0LnNoYWRvd0FyZWFcbiAgICBsZXQgbGlnaHRQcm9qZWN0aW9uID0gTWF0NC5vcnRobygtaGFsZlNoYWRvd0FyZWEsIGhhbGZTaGFkb3dBcmVhLFxuICAgICAgLWhhbGZTaGFkb3dBcmVhLCBoYWxmU2hhZG93QXJlYSwgLWhhbGZTaGFkb3dBcmVhLCBoYWxmU2hhZG93QXJlYSwgX2xpZ2h0UHJvamVjdGlvbilcbiAgICBsZXQgbGlnaHQgPSBzaGFkb3dDYXN0aW5nTGlnaHQubGlnaHRcbiAgICBsZXQgY2FtZXJhID0gc2hhZG93Q2FzdGluZ0xpZ2h0LmNhbWVyYSB8fCBDYW1lcmEubWFpblxuXG4gICAgaWYgKGNhbWVyYSAmJiBzaGFkb3dDYXN0aW5nTGlnaHQuZm9sbG93Q2FtZXJhKSB7XG4gICAgICBWZWMzLnNjYWxlKGNhbWVyYS53b3JsZFRyYW5zZm9ybS5mb3J3YXJkLCBoYWxmU2hhZG93QXJlYSwgX2NhbWVyYUZvcndhcmQpXG4gICAgICBWZWMzLmFkZChjYW1lcmEud29ybGRUcmFuc2Zvcm0ucG9zaXRpb24sIF9jYW1lcmFGb3J3YXJkLCBfY2FtZXJhVGFyZ2V0KVxuICAgICAgVmVjMy50cmFuc2Zvcm1RdWF0KF9jYW1lcmFUYXJnZXQsIFF1YXQuY29uanVnYXRlKFxuICAgICAgICBzaGFkb3dDYXN0aW5nTGlnaHQubGlnaHQud29ybGRUcmFuc2Zvcm0ucm90YXRpb24sIF9jb25qdWdhdGVSb3RhdGlvbiksIF9saWdodFNwYWNlUG9zaXRpb24pXG5cbiAgICAgIF9saWdodFNwYWNlUG9zaXRpb25bMF0gPSB3b3JsZFRleGVsU2l6ZSAqXG4gICAgICAgIE1hdGguZmxvb3IoX2xpZ2h0U3BhY2VQb3NpdGlvblswXSAvIHdvcmxkVGV4ZWxTaXplKVxuICAgICAgX2xpZ2h0U3BhY2VQb3NpdGlvblsxXSA9IHdvcmxkVGV4ZWxTaXplICpcbiAgICAgICAgTWF0aC5mbG9vcihfbGlnaHRTcGFjZVBvc2l0aW9uWzFdIC8gd29ybGRUZXhlbFNpemUpXG5cbiAgICAgIFZlYzMudHJhbnNmb3JtUXVhdChfbGlnaHRTcGFjZVBvc2l0aW9uLCBsaWdodC53b3JsZFRyYW5zZm9ybS5yb3RhdGlvbiwgX2xpZ2h0U3BhY2VQb3NpdGlvbilcbiAgICAgIFZlYzMuYWRkKF9saWdodFNwYWNlUG9zaXRpb24sIGxpZ2h0LndvcmxkVHJhbnNmb3JtLmZvcndhcmQsIF9saWdodFNwYWNlRm9yd2FyZClcbiAgICAgIE1hdDQubG9va0F0KF9saWdodFNwYWNlUG9zaXRpb24sIF9saWdodFNwYWNlRm9yd2FyZCwgbGlnaHQud29ybGRUcmFuc2Zvcm0udXAsIF9saWdodFZpZXcpXG4gICAgICBNYXQ0Lm11bHRpcGx5KGxpZ2h0UHJvamVjdGlvbiwgX2xpZ2h0Vmlldywgc2hhZG93Q2FzdGluZ0xpZ2h0LmxpZ2h0Vmlld1Byb2plY3Rpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIFZlYzMuYWRkKGxpZ2h0LndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uLFxuICAgICAgICBzaGFkb3dDYXN0aW5nTGlnaHQubGlnaHQud29ybGRUcmFuc2Zvcm0uZm9yd2FyZCwgX2NhbWVyYVRhcmdldClcbiAgICAgIE1hdDQubG9va0F0KGxpZ2h0LndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uLFxuICAgICAgICBfY2FtZXJhVGFyZ2V0LCBsaWdodC53b3JsZFRyYW5zZm9ybS51cCwgX2xpZ2h0VmlldylcbiAgICAgIE1hdDQubXVsdGlwbHkobGlnaHRQcm9qZWN0aW9uLCBfbGlnaHRWaWV3LCBzaGFkb3dDYXN0aW5nTGlnaHQubGlnaHRWaWV3UHJvamVjdGlvbilcbiAgICB9XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU3BvdExpZ2h0Vmlld1Byb2plY3Rpb24oc2hhZG93Q2FzdGluZ0xpZ2h0OiBTaGFkb3dDYXN0aW5nTGlnaHQpIHtcbiAgICBpZiAoc2hhZG93Q2FzdGluZ0xpZ2h0LmxpZ2h0LnR5cGUgIT09IExpZ2h0VHlwZS5zcG90KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IGxpZ2h0ID0gc2hhZG93Q2FzdGluZ0xpZ2h0LmxpZ2h0XG5cbiAgICBNYXQ0LnBlcnNwZWN0aXZlKGxpZ2h0Lm91dGVyQ29uZUFuZ2xlICogUElYSS5ERUdfVE9fUkFEICogMiwgMSwgMiwgbGlnaHQucmFuZ2UsIF9saWdodFByb2plY3Rpb24pXG4gICAgVmVjMy5hZGQobGlnaHQud29ybGRUcmFuc2Zvcm0ucG9zaXRpb24sIGxpZ2h0LndvcmxkVHJhbnNmb3JtLmZvcndhcmQsIF9jYW1lcmFUYXJnZXQpXG4gICAgTWF0NC5sb29rQXQobGlnaHQud29ybGRUcmFuc2Zvcm0ucG9zaXRpb24sIF9jYW1lcmFUYXJnZXQsIGxpZ2h0LndvcmxkVHJhbnNmb3JtLnVwLCBfbGlnaHRWaWV3KVxuICAgIE1hdDQubXVsdGlwbHkoX2xpZ2h0UHJvamVjdGlvbiwgX2xpZ2h0Vmlldywgc2hhZG93Q2FzdGluZ0xpZ2h0LmxpZ2h0Vmlld1Byb2plY3Rpb24pXG4gIH1cbn0iLCJleHBvcnQgZW51bSBTaGFkb3dRdWFsaXR5IHtcbiAgLyoqXG4gICAqIExvdyBxdWFsaXR5ICg4LWJpdCkgc2hhZG93cy5cbiAgICovXG4gIGxvdyAgPSBcImxvd1wiLFxuICAvKipcbiAgICogTWVkaXVtIHF1YWxpdHkgKDE2LWJpdCkgc2hhZG93cy5cbiAgICovXG4gIG1lZGl1bSA9IFwibWVkaXVtXCIsXG4gIC8qKlxuICAgKiBIaWdoIHF1YWxpdHkgKDMyLWJpdCkgc2hhZG93cy5cbiAgICovXG4gIGhpZ2ggPSBcImhpZ2hcIlxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBSZW5kZXJQYXNzIH0gZnJvbSBcIi4uL3BpcGVsaW5lL3JlbmRlci1wYXNzXCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuLi9tZXNoL21lc2hcIlxuaW1wb3J0IHsgU2hhZG93RmlsdGVyIH0gZnJvbSBcIi4vc2hhZG93LWZpbHRlclwiXG5pbXBvcnQgeyBTaGFkb3dDYXN0aW5nTGlnaHQgfSBmcm9tIFwiLi9zaGFkb3ctY2FzdGluZy1saWdodFwiXG5pbXBvcnQgeyBTaGFkb3dSZW5kZXJlciB9IGZyb20gXCIuL3NoYWRvdy1yZW5kZXJlclwiXG5cbi8qKlxuICogUGFzcyB1c2VkIGZvciByZW5kZXJpbmcgc2hhZG93cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNoYWRvd1JlbmRlclBhc3MgaW1wbGVtZW50cyBSZW5kZXJQYXNzIHtcbiAgcHJpdmF0ZSBfbGlnaHRzOiBTaGFkb3dDYXN0aW5nTGlnaHRbXSA9IFtdXG4gIHByaXZhdGUgX2ZpbHRlcjogU2hhZG93RmlsdGVyXG4gIHByaXZhdGUgX3NoYWRvdzogU2hhZG93UmVuZGVyZXJcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzaGFkb3cgcmVuZGVyIHBhc3MgdXNpbmcgdGhlIHNwZWNpZmllZCByZW5kZXJlci5cbiAgICogQHBhcmFtIHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIGZvciB0aGUgcmVuZGVyIHBhc3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIsIHB1YmxpYyBuYW1lID0gXCJzaGFkb3dcIikge1xuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBTaGFkb3dGaWx0ZXIocmVuZGVyZXIpXG4gICAgdGhpcy5fc2hhZG93ID0gbmV3IFNoYWRvd1JlbmRlcmVyKHJlbmRlcmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBzaGFkb3cgY2FzdGluZyBsaWdodC5cbiAgICogQHBhcmFtIHNoYWRvd0Nhc3RpbmdMaWdodCBUaGUgbGlnaHQgdG8gYWRkLlxuICAgKi9cbiAgYWRkU2hhZG93Q2FzdGluZ0xpZ2h0KHNoYWRvd0Nhc3RpbmdMaWdodDogU2hhZG93Q2FzdGluZ0xpZ2h0KSB7XG4gICAgaWYgKHRoaXMuX2xpZ2h0cy5pbmRleE9mKHNoYWRvd0Nhc3RpbmdMaWdodCkgPCAwKSB7XG4gICAgICB0aGlzLl9saWdodHMucHVzaChzaGFkb3dDYXN0aW5nTGlnaHQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzaGFkb3cgY2FzdGluZyBsaWdodC5cbiAgICogQHBhcmFtIHNoYWRvd0Nhc3RpbmdMaWdodCBUaGUgbGlnaHQgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlU2hhZG93Q2FzdGluZ0xpZ2h0KHNoYWRvd0Nhc3RpbmdMaWdodDogU2hhZG93Q2FzdGluZ0xpZ2h0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9saWdodHMuaW5kZXhPZihzaGFkb3dDYXN0aW5nTGlnaHQpXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuX2xpZ2h0cy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChsZXQgc2hhZG93Q2FzdGluZ0xpZ2h0IG9mIHRoaXMuX2xpZ2h0cykge1xuICAgICAgc2hhZG93Q2FzdGluZ0xpZ2h0LmNsZWFyKClcbiAgICB9XG4gIH1cblxuICByZW5kZXIobWVzaGVzOiBNZXNoM0RbXSkge1xuICAgIGlmIChtZXNoZXMubGVuZ3RoID09PSAwIHx8IHRoaXMuX2xpZ2h0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnRcbiAgICBmb3IgKGxldCBzaGFkb3dDYXN0aW5nTGlnaHQgb2YgdGhpcy5fbGlnaHRzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChzaGFkb3dDYXN0aW5nTGlnaHQuc2hhZG93VGV4dHVyZSlcbiAgICAgIHNoYWRvd0Nhc3RpbmdMaWdodC51cGRhdGVMaWdodFZpZXdQcm9qZWN0aW9uKClcbiAgICAgIGZvciAobGV0IG1lc2ggb2YgbWVzaGVzKSB7XG4gICAgICAgIHRoaXMuX3NoYWRvdy5yZW5kZXIobWVzaCwgc2hhZG93Q2FzdGluZ0xpZ2h0KVxuICAgICAgfVxuICAgICAgaWYgKHNoYWRvd0Nhc3RpbmdMaWdodC5zb2Z0bmVzcyA+IDApIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyLmFwcGx5R2F1c3NpYW5CbHVyKHNoYWRvd0Nhc3RpbmdMaWdodClcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoY3VycmVudClcbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBTaGFkb3dTaGFkZXIgfSBmcm9tIFwiLi9zaGFkb3ctc2hhZGVyXCJcbmltcG9ydCB7IE1lc2gzRCB9IGZyb20gXCIuLi9tZXNoL21lc2hcIlxuaW1wb3J0IHsgU2hhZG93Q2FzdGluZ0xpZ2h0IH0gZnJvbSBcIi4vc2hhZG93LWNhc3RpbmctbGlnaHRcIlxuaW1wb3J0IHsgU2tpbm5pbmdTaGFkZXIgfSBmcm9tIFwiLi9za2lubmluZy1zaGFkZXJcIlxuaW1wb3J0IHsgVGV4dHVyZVNoYWRlciB9IGZyb20gXCIuL3RleHR1cmUtc2hhZGVyXCJcbmltcG9ydCB7IENvbnNvbGUgfSBmcm9tIFwiLi4vY29uc29sZVwiXG5cbmV4cG9ydCBjbGFzcyBTaGFkb3dSZW5kZXJlciB7XG4gIHByaXZhdGUgX3N0YXRlID0gT2JqZWN0LmFzc2lnbihuZXcgUElYSS5TdGF0ZSgpLCB7XG4gICAgZGVwdGhUZXN0OiB0cnVlLCBjbG9ja3dpc2VGcm9udEZhY2U6IGZhbHNlLCBjdWxsaW5nOiB0cnVlLCBibGVuZE1vZGU6IFBJWEkuQkxFTkRfTU9ERVMuTk9ORVxuICB9KVxuICBwcml2YXRlIF9zaGFkb3dTaGFkZXI6IFNoYWRvd1NoYWRlclxuICBwcml2YXRlIF9za2lubmluZ1NoYWRlcj86IFNraW5uaW5nU2hhZGVyXG4gIHByaXZhdGUgX3RleHR1cmVTaGFkZXI/OiBUZXh0dXJlU2hhZGVyXG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgdGhpcy5fc2hhZG93U2hhZGVyID0gbmV3IFNoYWRvd1NoYWRlcih0aGlzLnJlbmRlcmVyKVxuICB9XG5cbiAgcmVuZGVyKG1lc2g6IE1lc2gzRCwgc2hhZG93Q2FzdGluZ0xpZ2h0OiBTaGFkb3dDYXN0aW5nTGlnaHQpIHtcbiAgICBsZXQgc2hhZGVyOiBTaGFkb3dTaGFkZXIgfCB1bmRlZmluZWQgPSB0aGlzLl9zaGFkb3dTaGFkZXJcbiAgICBpZiAobWVzaC5za2luICYmIG1lc2guZ2VvbWV0cnkuam9pbnRzICYmIG1lc2guZ2VvbWV0cnkud2VpZ2h0cykge1xuICAgICAgaWYgKCF0aGlzLl9za2lubmluZ1NoYWRlcikge1xuICAgICAgICB0aGlzLl9za2lubmluZ1NoYWRlciA9IG5ldyBTa2lubmluZ1NoYWRlcih0aGlzLnJlbmRlcmVyKVxuICAgICAgfVxuICAgICAgc2hhZGVyID0gdGhpcy5fc2tpbm5pbmdTaGFkZXJcbiAgICAgIGlmIChtZXNoLnNraW4uam9pbnRzLmxlbmd0aCA+IHRoaXMuX3NraW5uaW5nU2hhZGVyLm1heFN1cHBvcnRlZEpvaW50cykge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmVTaGFkZXIpIHtcbiAgICAgICAgICBpZiAoVGV4dHVyZVNoYWRlci5pc1N1cHBvcnRlZCh0aGlzLnJlbmRlcmVyKSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVNoYWRlciA9IG5ldyBUZXh0dXJlU2hhZGVyKHRoaXMucmVuZGVyZXIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoYWRlciA9IHRoaXMuX3RleHR1cmVTaGFkZXJcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYWRlcikge1xuICAgICAgc2hhZGVyLnVwZGF0ZVVuaWZvcm1zKG1lc2gsIHNoYWRvd0Nhc3RpbmdMaWdodClcbiAgICAgIHNoYWRlci5yZW5kZXIobWVzaCwgdGhpcy5yZW5kZXJlciwgdGhpcy5fc3RhdGUpXG4gICAgfVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IE1lc2hHZW9tZXRyeTNEIH0gZnJvbSBcIi4uL21lc2gvZ2VvbWV0cnkvbWVzaC1nZW9tZXRyeVwiXG5pbXBvcnQgeyBNZXNoU2hhZGVyIH0gZnJvbSBcIi4uL21lc2gvbWVzaC1zaGFkZXJcIlxuaW1wb3J0IHsgU3RhbmRhcmRTaGFkZXJTb3VyY2UgfSBmcm9tIFwiLi4vbWF0ZXJpYWwvc3RhbmRhcmQvc3RhbmRhcmQtc2hhZGVyLXNvdXJjZVwiXG5pbXBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCJcbmltcG9ydCB7IFNoYWRvd0Nhc3RpbmdMaWdodCB9IGZyb20gXCIuL3NoYWRvdy1jYXN0aW5nLWxpZ2h0XCJcblxuZXhwb3J0IGNsYXNzIFNoYWRvd1NoYWRlciBleHRlbmRzIE1lc2hTaGFkZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcjogUElYSS5SZW5kZXJlciwgZmVhdHVyZXM6IHN0cmluZ1tdID0gW10pIHtcbiAgICBsZXQgdmVydCA9IHJlcXVpcmUoXCIuL3NoYWRlci9zaGFkb3cudmVydFwiKVxuICAgIGxldCBmcmFnID0gcmVxdWlyZShcIi4vc2hhZGVyL3NoYWRvdy5mcmFnXCIpXG5cbiAgICBzdXBlcihQSVhJLlByb2dyYW0uZnJvbShcbiAgICAgIFN0YW5kYXJkU2hhZGVyU291cmNlLmJ1aWxkKHZlcnQsIGZlYXR1cmVzLCByZW5kZXJlciksXG4gICAgICBTdGFuZGFyZFNoYWRlclNvdXJjZS5idWlsZChmcmFnLCBmZWF0dXJlcywgcmVuZGVyZXIpKSlcbiAgfVxuXG4gIGNyZWF0ZVNoYWRlckdlb21ldHJ5KGdlb21ldHJ5OiBNZXNoR2VvbWV0cnkzRCkge1xuICAgIGxldCByZXN1bHQgPSBuZXcgUElYSS5HZW9tZXRyeSgpXG4gICAgaWYgKGdlb21ldHJ5LmluZGljZXMpIHtcbiAgICAgIGlmIChnZW9tZXRyeS5pbmRpY2VzLmJ1ZmZlci5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMSkge1xuICAgICAgICAvLyBQSVhJIHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCBVaW50OEFycmF5LCBsZXQncyBjb252ZXJ0IHRvIFVOU0lHTkVEX1NIT1JULlxuICAgICAgICByZXN1bHQuYWRkSW5kZXgobmV3IFBJWEkuQnVmZmVyKG5ldyBVaW50MTZBcnJheShnZW9tZXRyeS5pbmRpY2VzLmJ1ZmZlcikpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LmFkZEluZGV4KG5ldyBQSVhJLkJ1ZmZlcihnZW9tZXRyeS5pbmRpY2VzLmJ1ZmZlcikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeS5wb3NpdGlvbnMpIHtcbiAgICAgIHJlc3VsdC5hZGRBdHRyaWJ1dGUoXCJhX1Bvc2l0aW9uXCIsIG5ldyBQSVhJLkJ1ZmZlcihnZW9tZXRyeS5wb3NpdGlvbnMuYnVmZmVyKSxcbiAgICAgICAgMywgZmFsc2UsIGdlb21ldHJ5LnBvc2l0aW9ucy5jb21wb25lbnRUeXBlLCBnZW9tZXRyeS5wb3NpdGlvbnMuc3RyaWRlKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gXCJzaGFkb3ctc2hhZGVyXCJcbiAgfVxuXG4gIHVwZGF0ZVVuaWZvcm1zKG1lc2g6IE1lc2gzRCwgc2hhZG93Q2FzdGluZ0xpZ2h0OiBTaGFkb3dDYXN0aW5nTGlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfTW9kZWxNYXRyaXggPSBtZXNoLndvcmxkVHJhbnNmb3JtLmFycmF5XG4gICAgdGhpcy51bmlmb3Jtcy51X1ZpZXdQcm9qZWN0aW9uTWF0cml4ID0gc2hhZG93Q2FzdGluZ0xpZ2h0LmxpZ2h0Vmlld1Byb2plY3Rpb25cbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBTaGFkb3dRdWFsaXR5IH0gZnJvbSBcIi4vc2hhZG93LXF1YWxpdHlcIlxuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tIFwiLi4vcGxhdGZvcm1cIlxuXG5leHBvcnQgbmFtZXNwYWNlIFNoYWRvd1RleHR1cmUge1xuICBleHBvcnQgZnVuY3Rpb24gY3JlYXRlKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyLCBzaXplOiBudW1iZXIsIHF1YWxpdHk6IFNoYWRvd1F1YWxpdHkpIHtcbiAgICBsZXQgdHlwZSA9IGdldFN1cHBvcnRlZFR5cGUocmVuZGVyZXIsIHF1YWxpdHkpXG4gICAgcmV0dXJuIFBJWEkuUmVuZGVyVGV4dHVyZS5jcmVhdGUoe1xuICAgICAgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSwgdHlwZTogdHlwZSwgc2NhbGVNb2RlOiBnZXRTdXBwb3J0ZWRTY2FsZU1vZGUocmVuZGVyZXIpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN1cHBvcnRlZFNjYWxlTW9kZShyZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIGlmIChQbGF0Zm9ybS5zdXBwb3J0c0Zsb2F0TGluZWFyKHJlbmRlcmVyKSkge1xuICAgICAgcmV0dXJuIFBJWEkuU0NBTEVfTU9ERVMuTElORUFSXG4gICAgfVxuICAgIHJldHVybiBQSVhJLlNDQUxFX01PREVTLk5FQVJFU1RcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN1cHBvcnRlZFR5cGUocmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIsIHF1YWxpdHk6IFNoYWRvd1F1YWxpdHkpIHtcbiAgICBpZiAocXVhbGl0eSA9PT0gU2hhZG93UXVhbGl0eS5oaWdoKSB7XG4gICAgICBpZiAoUGxhdGZvcm0uaXNGbG9hdEZyYW1lYnVmZmVyU3VwcG9ydGVkKHJlbmRlcmVyKSkge1xuICAgICAgICByZXR1cm4gUElYSS5UWVBFUy5GTE9BVFxuICAgICAgfVxuICAgICAgaWYgKFBsYXRmb3JtLmlzSGFsZkZsb2F0RnJhbWVidWZmZXJTdXBwb3J0ZWQocmVuZGVyZXIpKSB7XG4gICAgICAgIHJldHVybiBQSVhJLlRZUEVTLkhBTEZfRkxPQVRcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1YWxpdHkgPT09IFNoYWRvd1F1YWxpdHkubWVkaXVtICYmIFBsYXRmb3JtLmlzSGFsZkZsb2F0RnJhbWVidWZmZXJTdXBwb3J0ZWQocmVuZGVyZXIpKSB7XG4gICAgICByZXR1cm4gUElYSS5UWVBFUy5IQUxGX0ZMT0FUXG4gICAgfVxuICAgIHJldHVybiBQSVhJLlRZUEVTLlVOU0lHTkVEX0JZVEVcbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBNZXNoR2VvbWV0cnkzRCB9IGZyb20gXCIuLi9tZXNoL2dlb21ldHJ5L21lc2gtZ2VvbWV0cnlcIlxuaW1wb3J0IHsgTWVzaDNEIH0gZnJvbSBcIi4uL21lc2gvbWVzaFwiXG5pbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gXCIuLi9wbGF0Zm9ybVwiXG5pbXBvcnQgeyBTaGFkb3dDYXN0aW5nTGlnaHQgfSBmcm9tIFwiLi9zaGFkb3ctY2FzdGluZy1saWdodFwiXG5pbXBvcnQgeyBTaGFkb3dTaGFkZXIgfSBmcm9tIFwiLi9zaGFkb3ctc2hhZGVyXCJcblxuZXhwb3J0IGNsYXNzIFNraW5uaW5nU2hhZGVyIGV4dGVuZHMgU2hhZG93U2hhZGVyIHtcbiAgcHJpdmF0ZSBfbWF4U3VwcG9ydGVkSm9pbnRzOiBudW1iZXJcblxuICBnZXQgbWF4U3VwcG9ydGVkSm9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhTdXBwb3J0ZWRKb2ludHNcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgbGV0IHVuaWZvcm1zUmVxdWlyZWRGb3JPdGhlckZlYXR1cmVzID0gOFxuICAgIGxldCBhdmFpbGFibGVWZXJ0ZXhVbmlmb3JtcyA9XG4gICAgICBQbGF0Zm9ybS5nZXRNYXhWZXJ0ZXhVbmlmb3JtVmVjdG9ycyhyZW5kZXJlcikgLSB1bmlmb3Jtc1JlcXVpcmVkRm9yT3RoZXJGZWF0dXJlc1xuICAgIGxldCB1bmlmb3Jtc1JlcXVpcmVkUGVySm9pbnQgPSA0XG4gICAgbGV0IG1heEpvaW50Q291bnQgPSBNYXRoLmZsb29yKGF2YWlsYWJsZVZlcnRleFVuaWZvcm1zIC8gdW5pZm9ybXNSZXF1aXJlZFBlckpvaW50KVxuXG4gICAgc3VwZXIocmVuZGVyZXIsIFtcIlVTRV9TS0lOTklORyAxXCIsIFwiTUFYX0pPSU5UX0NPVU5UIFwiICsgbWF4Sm9pbnRDb3VudF0pXG4gICAgdGhpcy5fbWF4U3VwcG9ydGVkSm9pbnRzID0gbWF4Sm9pbnRDb3VudFxuICB9XG5cbiAgY3JlYXRlU2hhZGVyR2VvbWV0cnkoZ2VvbWV0cnk6IE1lc2hHZW9tZXRyeTNEKSB7XG4gICAgbGV0IHJlc3VsdCA9IHN1cGVyLmNyZWF0ZVNoYWRlckdlb21ldHJ5KGdlb21ldHJ5KVxuICAgIGlmIChnZW9tZXRyeS5qb2ludHMpIHtcbiAgICAgIHJlc3VsdC5hZGRBdHRyaWJ1dGUoXCJhX0pvaW50MVwiLCBuZXcgUElYSS5CdWZmZXIoZ2VvbWV0cnkuam9pbnRzLmJ1ZmZlciksXG4gICAgICAgIDQsIGZhbHNlLCBnZW9tZXRyeS5qb2ludHMuY29tcG9uZW50VHlwZSwgZ2VvbWV0cnkuam9pbnRzLnN0cmlkZSlcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LndlaWdodHMpIHtcbiAgICAgIHJlc3VsdC5hZGRBdHRyaWJ1dGUoXCJhX1dlaWdodDFcIiwgbmV3IFBJWEkuQnVmZmVyKGdlb21ldHJ5LndlaWdodHMuYnVmZmVyKSxcbiAgICAgICAgNCwgZmFsc2UsIGdlb21ldHJ5LndlaWdodHMuY29tcG9uZW50VHlwZSwgZ2VvbWV0cnkud2VpZ2h0cy5zdHJpZGUpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBcInNraW5uZWQtc2hhZG93LXNoYWRlclwiXG4gIH1cblxuICB1cGRhdGVVbmlmb3JtcyhtZXNoOiBNZXNoM0QsIHNoYWRvd0Nhc3RpbmdMaWdodDogU2hhZG93Q2FzdGluZ0xpZ2h0KSB7XG4gICAgc3VwZXIudXBkYXRlVW5pZm9ybXMobWVzaCwgc2hhZG93Q2FzdGluZ0xpZ2h0KVxuICAgIGlmICghbWVzaC5za2luKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IHsgam9pbnRWZXJ0ZXhNYXRyaWNlcyB9ID0gbWVzaC5za2luLmNhbGN1bGF0ZUpvaW50TWF0cmljZXMoKVxuICAgIHRoaXMudW5pZm9ybXMudV9qb2ludE1hdHJpeCA9IGpvaW50VmVydGV4TWF0cmljZXNcbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBNZXNoR2VvbWV0cnkzRCB9IGZyb20gXCIuLi9tZXNoL2dlb21ldHJ5L21lc2gtZ2VvbWV0cnlcIlxuaW1wb3J0IHsgTWVzaDNEIH0gZnJvbSBcIi4uL21lc2gvbWVzaFwiXG5pbXBvcnQgeyBTaGFkb3dDYXN0aW5nTGlnaHQgfSBmcm9tIFwiLi9zaGFkb3ctY2FzdGluZy1saWdodFwiXG5pbXBvcnQgeyBTaGFkb3dTaGFkZXIgfSBmcm9tIFwiLi9zaGFkb3ctc2hhZGVyXCJcbmltcG9ydCB7IFN0YW5kYXJkTWF0ZXJpYWxNYXRyaXhUZXh0dXJlIH0gZnJvbSBcIi4uL21hdGVyaWFsL3N0YW5kYXJkL3N0YW5kYXJkLW1hdGVyaWFsLW1hdHJpeC10ZXh0dXJlXCJcblxuY29uc3QgTUFYX1NVUFBPUlRFRF9KT0lOVFMgPSAyNTZcblxuZXhwb3J0IGNsYXNzIFRleHR1cmVTaGFkZXIgZXh0ZW5kcyBTaGFkb3dTaGFkZXIge1xuICBwcml2YXRlIF9qb2ludE1hdHJpeFRleHR1cmU6IFN0YW5kYXJkTWF0ZXJpYWxNYXRyaXhUZXh0dXJlXG5cbiAgZ2V0IG1heFN1cHBvcnRlZEpvaW50cygpIHtcbiAgICByZXR1cm4gTUFYX1NVUFBPUlRFRF9KT0lOVFNcbiAgfVxuXG4gIHN0YXRpYyBpc1N1cHBvcnRlZChyZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIHJldHVybiBTdGFuZGFyZE1hdGVyaWFsTWF0cml4VGV4dHVyZS5pc1N1cHBvcnRlZChyZW5kZXJlcilcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIsIFtcbiAgICAgIFwiVVNFX1NLSU5OSU5HIDFcIiwgXCJVU0VfU0tJTk5JTkdfVEVYVFVSRSAxXCIsIFwiTUFYX0pPSU5UX0NPVU5UIFwiICsgTUFYX1NVUFBPUlRFRF9KT0lOVFNcbiAgICBdKVxuICAgIHRoaXMuX2pvaW50TWF0cml4VGV4dHVyZSA9XG4gICAgICBuZXcgU3RhbmRhcmRNYXRlcmlhbE1hdHJpeFRleHR1cmUoTUFYX1NVUFBPUlRFRF9KT0lOVFMpXG4gIH1cblxuICBjcmVhdGVTaGFkZXJHZW9tZXRyeShnZW9tZXRyeTogTWVzaEdlb21ldHJ5M0QpIHtcbiAgICBsZXQgcmVzdWx0ID0gc3VwZXIuY3JlYXRlU2hhZGVyR2VvbWV0cnkoZ2VvbWV0cnkpXG4gICAgaWYgKGdlb21ldHJ5LmpvaW50cykge1xuICAgICAgcmVzdWx0LmFkZEF0dHJpYnV0ZShcImFfSm9pbnQxXCIsIG5ldyBQSVhJLkJ1ZmZlcihnZW9tZXRyeS5qb2ludHMuYnVmZmVyKSxcbiAgICAgICAgNCwgZmFsc2UsIGdlb21ldHJ5LmpvaW50cy5jb21wb25lbnRUeXBlLCBnZW9tZXRyeS5qb2ludHMuc3RyaWRlKVxuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnkud2VpZ2h0cykge1xuICAgICAgcmVzdWx0LmFkZEF0dHJpYnV0ZShcImFfV2VpZ2h0MVwiLCBuZXcgUElYSS5CdWZmZXIoZ2VvbWV0cnkud2VpZ2h0cy5idWZmZXIpLFxuICAgICAgICA0LCBmYWxzZSwgZ2VvbWV0cnkud2VpZ2h0cy5jb21wb25lbnRUeXBlLCBnZW9tZXRyeS53ZWlnaHRzLnN0cmlkZSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIFwic2tpbm5lZC1zaGFkb3ctc2hhZGVyXCJcbiAgfVxuXG4gIHVwZGF0ZVVuaWZvcm1zKG1lc2g6IE1lc2gzRCwgc2hhZG93Q2FzdGluZ0xpZ2h0OiBTaGFkb3dDYXN0aW5nTGlnaHQpIHtcbiAgICBzdXBlci51cGRhdGVVbmlmb3JtcyhtZXNoLCBzaGFkb3dDYXN0aW5nTGlnaHQpXG4gICAgaWYgKCFtZXNoLnNraW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsZXQgeyBqb2ludFZlcnRleE1hdHJpY2VzIH0gPSBtZXNoLnNraW4uY2FsY3VsYXRlSm9pbnRNYXRyaWNlcygpXG4gICAgdGhpcy5fam9pbnRNYXRyaXhUZXh0dXJlLnVwZGF0ZUJ1ZmZlcihqb2ludFZlcnRleE1hdHJpY2VzKVxuICAgIHRoaXMudW5pZm9ybXMudV9qb2ludE1hdHJpeFNhbXBsZXIgPSB0aGlzLl9qb2ludE1hdHJpeFRleHR1cmVcbiAgfVxufSIsImltcG9ydCB7IENvbnRhaW5lcjNEIH0gZnJvbSBcIi4uL2NvbnRhaW5lclwiXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGpvaW50IHVzZWQgZm9yIHZlcnRleCBza2lubmluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEpvaW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgam9pbnQuXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIGNvbnRhaW5lciB1c2luZyB0aGlzIHNraW4uXG4gICAqIEBwYXJhbSBpbnZlcnNlQmluZE1hdHJpeCBUaGUgaW52ZXJzZSBvZiB0aGUgZ2xvYmFsIHRyYW5zZm9ybSBtYXRyaXguXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbm9kZTogQ29udGFpbmVyM0QsIHB1YmxpYyBpbnZlcnNlQmluZE1hdHJpeDogRmxvYXQzMkFycmF5KSB7XG4gIH1cbn1cbiIsImltcG9ydCB7IE1hdDQgfSBmcm9tIFwiLi4vbWF0aC9tYXQ0XCJcbmltcG9ydCB7IENvbnRhaW5lcjNEIH0gZnJvbSBcIi4uL2NvbnRhaW5lclwiXG5pbXBvcnQgeyBKb2ludCB9IGZyb20gXCIuL2pvaW50XCJcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2tpbiB1c2VkIGZvciB2ZXJ0ZXggc2tpbm5pbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBTa2luIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc2tpbi5cbiAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IGNvbnRhaW5lciBub2RlIGZvciB0aGUgc2tpbi5cbiAgICogQHBhcmFtIGpvaW50cyBUaGUgYXJyYXkgb2Ygam9pbnRzIGluY2x1ZGVkIGluIHRoZSBza2luLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHBhcmVudDogQ29udGFpbmVyM0QsIHB1YmxpYyBqb2ludHM6IEpvaW50W10pIHtcbiAgICB0aGlzLl9qb2ludFZlcnRleE1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheShqb2ludHMubGVuZ3RoICogMTYpXG4gICAgdGhpcy5fam9pbnROb3JtYWxNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoam9pbnRzLmxlbmd0aCAqIDE2KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgam9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9hcnJheVZlcnRleE1hdHJpY2VzLnB1c2gobmV3IEZsb2F0MzJBcnJheSh0aGlzLl9qb2ludFZlcnRleE1hdHJpY2VzLmJ1ZmZlciwgMTYgKiA0ICogaSwgMTYpKVxuICAgICAgdGhpcy5fYXJyYXlOb3JtYWxNYXRyaWNlcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fam9pbnROb3JtYWxNYXRyaWNlcy5idWZmZXIsIDE2ICogNCAqIGksIDE2KSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9qb2ludFZlcnRleE1hdHJpY2VzOiBGbG9hdDMyQXJyYXlcbiAgcHJpdmF0ZSBfYXJyYXlWZXJ0ZXhNYXRyaWNlczogRmxvYXQzMkFycmF5W10gPSBbXVxuICBwcml2YXRlIF9qb2ludE5vcm1hbE1hdHJpY2VzOiBGbG9hdDMyQXJyYXlcbiAgcHJpdmF0ZSBfYXJyYXlOb3JtYWxNYXRyaWNlczogRmxvYXQzMkFycmF5W10gPSBbXVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBqb2ludCBtYXRyaWNlcy5cbiAgICovXG4gIGNhbGN1bGF0ZUpvaW50TWF0cmljZXMoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmpvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgLyogVGhlIHZlcnRpY2VzIGhhdmUgdG8gYmUgdHJhbnNmb3JtZWQgd2l0aCB0aGUgY3VycmVudCBnbG9iYWwgdHJhbnNmb3JtIFxuICAgICAgb2YgdGhlIGpvaW50IG5vZGUuIFRvZ2V0aGVyIHdpdGggdGhlIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIFxuICAgICAgaW52ZXJzZUJpbmRNYXRyaXgsIHRoaXMgd2lsbCBjYXVzZSB0aGUgdmVydGljZXMgdG8gYmUgdHJhbnNmb3JtZWQgb25seSBcbiAgICAgIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgbm9kZSwgaW4gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIFxuICAgICAgY3VycmVudCBqb2ludCBub2RlLiAqL1xuICAgICAgTWF0NC5tdWx0aXBseSg8RmxvYXQzMkFycmF5Pjx1bmtub3duPnRoaXMuam9pbnRzW2ldLm5vZGUud29ybGRUcmFuc2Zvcm0uYXJyYXksXG4gICAgICAgIHRoaXMuam9pbnRzW2ldLmludmVyc2VCaW5kTWF0cml4LCB0aGlzLl9hcnJheVZlcnRleE1hdHJpY2VzW2ldKVxuXG4gICAgICAvKiBUaGUgdmVydGljZXMgaGF2ZSB0byBiZSB0cmFuc2Zvcm1lZCB3aXRoIGludmVyc2Ugb2YgdGhlIGdsb2JhbCBcbiAgICAgIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSB0aGF0IHRoZSBtZXNoIGlzIGF0dGFjaGVkIHRvLCBiZWNhdXNlIHRoaXMgdHJhbnNmb3JtIFxuICAgICAgaXMgYWxyZWFkeSBkb25lIHVzaW5nIHRoZSBtb2RlbC12aWV3LW1hdHJpeCwgYW5kIHRodXMgaGFzIHRvIGJlIGNhbmNlbGxlZCBcbiAgICAgIG91dCBmcm9tIHRoZSBza2lubmluZyBjb21wdXRhdGlvbi4gKi9cbiAgICAgIE1hdDQubXVsdGlwbHkoPEZsb2F0MzJBcnJheT48dW5rbm93bj50aGlzLnBhcmVudC50cmFuc2Zvcm0uaW52ZXJzZVdvcmxkVHJhbnNmb3JtLmFycmF5LFxuICAgICAgICB0aGlzLl9hcnJheVZlcnRleE1hdHJpY2VzW2ldLCB0aGlzLl9hcnJheVZlcnRleE1hdHJpY2VzW2ldKVxuXG4gICAgICBNYXQ0LmludmVydCh0aGlzLl9hcnJheVZlcnRleE1hdHJpY2VzW2ldLCB0aGlzLl9hcnJheU5vcm1hbE1hdHJpY2VzW2ldKVxuICAgICAgTWF0NC50cmFuc3Bvc2UodGhpcy5fYXJyYXlOb3JtYWxNYXRyaWNlc1tpXSwgdGhpcy5fYXJyYXlOb3JtYWxNYXRyaWNlc1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGpvaW50VmVydGV4TWF0cmljZXM6IHRoaXMuX2pvaW50VmVydGV4TWF0cmljZXMsXG4gICAgICBqb2ludE5vcm1hbE1hdHJpY2VzOiB0aGlzLl9qb2ludE5vcm1hbE1hdHJpY2VzXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyeWluZyB2ZWMzIHZfUG9zaXRpb247XFxuXFxudW5pZm9ybSBzYW1wbGVyQ3ViZSB1X0Vudmlyb25tZW50U2FtcGxlcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHRleHR1cmVDdWJlKHVfRW52aXJvbm1lbnRTYW1wbGVyLCB2X1Bvc2l0aW9uKS5yZ2IsIDEuMCk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMzIGFfUG9zaXRpb247XFxuXFxudmFyeWluZyB2ZWMzIHZfUG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQ0IHVfTW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVfVmlldztcXG51bmlmb3JtIG1hdDQgdV9Qcm9qZWN0aW9uO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZfUG9zaXRpb24gPSBhX1Bvc2l0aW9uLnh5ejtcXG5cXG4gIC8vIENvbnZlcnRpbmcgdGhlIHZpZXcgdG8gM3gzIG1hdHJpeCBhbmQgdGhlbiBiYWNrIHRvIDR4NCBtYXRyaXggXFxuICAvLyByZW1vdmVzIHRoZSB0cmFuc2xhdGlvbi4gV2UgZG8gdGhpcyBiZWNhdXNlIHdlIHdhbnQgdGhlIHNreWJveCB0byBcXG4gIC8vIGJlIGNlbnRlcmVkIGFyb3VuZCB0aGUgY2FtZXJhLlxcbiAgZ2xfUG9zaXRpb24gPSB1X1Byb2plY3Rpb24gKiBtYXQ0KG1hdDModV9WaWV3KSkgKiB1X01vZGVsTWF0cml4ICogdmVjNChhX1Bvc2l0aW9uLCAxLjApO1xcbn1cIiIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBDdWJlbWFwIH0gZnJvbSBcIi4uL2N1YmVtYXAvY3ViZW1hcFwiXG5pbXBvcnQgeyBNZXNoU2hhZGVyIH0gZnJvbSBcIi4uL21lc2gvbWVzaC1zaGFkZXJcIlxuaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSBcIi4uL2NhbWVyYS9jYW1lcmFcIlxuaW1wb3J0IHsgTWVzaDNEIH0gZnJvbSBcIi4uL21lc2gvbWVzaFwiXG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbC9tYXRlcmlhbFwiXG5cbmV4cG9ydCBjbGFzcyBTa3lib3hNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcbiAgcHJpdmF0ZSBfY3ViZW1hcDogQ3ViZW1hcFxuXG4gIGdldCBjdWJlbWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9jdWJlbWFwXG4gIH1cblxuICBzZXQgY3ViZW1hcCh2YWx1ZTogQ3ViZW1hcCkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fY3ViZW1hcCkge1xuICAgICAgaWYgKCF0aGlzLl9jdWJlbWFwLnZhbGlkKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc2hhZGVyIHNvIGl0IGNhbiBiZSByZWJ1aWx0IHdpdGggdGhlIGN1cnJlbnQgZmVhdHVyZXMuIFxuICAgICAgICAvLyBJdCBtYXkgaGFwcGVuIHRoYXQgd2Ugc2V0IGEgdGV4dHVyZSB3aGljaCBpcyBub3QgeWV0IHZhbGlkLCBpbiB0aGF0IFxuICAgICAgICAvLyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gcmVuZGVyIHRoZSBza3lib3ggdW50aWwgaXQgaGFzIGJlY29tZSB2YWxpZC5cbiAgICAgICAgdGhpcy5fc2hhZGVyID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgICB0aGlzLl9jdWJlbWFwID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICBjYW1lcmE/OiBDYW1lcmFcblxuICBjb25zdHJ1Y3RvcihjdWJlbWFwOiBDdWJlbWFwKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2N1YmVtYXAgPSBjdWJlbWFwXG4gICAgdGhpcy5zdGF0ZSA9IE9iamVjdC5hc3NpZ24obmV3IFBJWEkuU3RhdGUoKSwge1xuICAgICAgY3VsbGluZzogdHJ1ZSwgY2xvY2t3aXNlRnJvbnRGYWNlOiB0cnVlLCBkZXB0aFRlc3Q6IHRydWVcbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlVW5pZm9ybXMobWVzaDogTWVzaDNELCBzaGFkZXI6IE1lc2hTaGFkZXIpIHtcbiAgICBsZXQgY2FtZXJhID0gdGhpcy5jYW1lcmEgfHwgQ2FtZXJhLm1haW5cblxuICAgIHNoYWRlci51bmlmb3Jtcy51X01vZGVsTWF0cml4ID0gbWVzaC53b3JsZFRyYW5zZm9ybS5hcnJheVxuICAgIHNoYWRlci51bmlmb3Jtcy51X1ZpZXcgPSBjYW1lcmEudmlld1xuICAgIHNoYWRlci51bmlmb3Jtcy51X1Byb2plY3Rpb24gPSBjYW1lcmEucHJvamVjdGlvblxuICAgIHNoYWRlci51bmlmb3Jtcy51X0Vudmlyb25tZW50U2FtcGxlciA9IHRoaXMuY3ViZW1hcFxuICB9XG5cbiAgcmVuZGVyKG1lc2g6IE1lc2gzRCwgcmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICAvLyBEaXNhYmxlIHdyaXRpbmcgdG8gdGhlIGRlcHRoIGJ1ZmZlci4gVGhpcyBpcyBiZWNhdXNlIHdlIHdhbnQgYWxsIG90aGVyIFxuICAgIC8vIG9iamVjdHMgdG8gYmUgaW4tZnJvbnQgb2YgdGhlIHNreWJveC5cbiAgICByZW5kZXJlci5nbC5kZXB0aE1hc2soZmFsc2UpXG4gICAgc3VwZXIucmVuZGVyKG1lc2gsIHJlbmRlcmVyKVxuICAgIHJlbmRlcmVyLmdsLmRlcHRoTWFzayh0cnVlKVxuICB9XG5cbiAgY3JlYXRlU2hhZGVyKCkge1xuICAgIGxldCB2ZXJ0ID0gcmVxdWlyZShcIi4vc2hhZGVyL3NreWJveC52ZXJ0XCIpXG4gICAgbGV0IGZyYWcgPSByZXF1aXJlKFwiLi9zaGFkZXIvc2t5Ym94LmZyYWdcIilcblxuICAgIGlmICh0aGlzLmN1YmVtYXAudmFsaWQpIHtcbiAgICAgIHJldHVybiBuZXcgTWVzaFNoYWRlcihQSVhJLlByb2dyYW0uZnJvbSh2ZXJ0LCBmcmFnKSlcbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgeyBTa3lib3hNYXRlcmlhbCB9IGZyb20gXCIuL3NreWJveC1tYXRlcmlhbFwiXG5pbXBvcnQgeyBNZXNoM0QgfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCJcbmltcG9ydCB7IENvbnRhaW5lcjNEIH0gZnJvbSBcIi4uL2NvbnRhaW5lclwiXG5pbXBvcnQgeyBDdWJlbWFwIH0gZnJvbSBcIi4uL2N1YmVtYXAvY3ViZW1hcFwiXG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiLi4vY2FtZXJhL2NhbWVyYVwiXG5pbXBvcnQgeyBDdWJlbWFwRmFjZXMgfSBmcm9tIFwiLi4vY3ViZW1hcC9jdWJlbWFwLWZhY2VzXCJcblxuLyoqXG4gKiBBIHNreWJveCBpcyBhIG1ldGhvZCBvZiBjcmVhdGluZyBiYWNrZ3JvdW5kcyBpbiBhIDNEIHNjZW5lLiBJdCBjb25zaXN0cyBvZlxuICogYSBjdWJlbWFwIHRleHR1cmUgd2hpY2ggaGFzIHNpeCBzaWRlcy4gTm90ZSB0aGF0IHRoZSBza3lib3ggc2hvdWxkIGJlIHJlbmRlcmVkIFxuICogYmVmb3JlIGFsbCBvdGhlciBvYmplY3RzIGluIHRoZSBzY2VuZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNreWJveCBleHRlbmRzIENvbnRhaW5lcjNEIHtcbiAgcHJpdmF0ZSBfbWVzaDogTWVzaDNEXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc2t5Ym94IHVzaW5nIHRoZSBzcGVjaWZpZWQgY3ViZW1hcC5cbiAgICogQHBhcmFtIGN1YmVtYXAgQ3ViZW1hcCB0byB1c2UgZm9yIHJlbmRlcmluZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGN1YmVtYXA6IEN1YmVtYXApIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fbWVzaCA9IHRoaXMuYWRkQ2hpbGQoTWVzaDNELmNyZWF0ZUN1YmUobmV3IFNreWJveE1hdGVyaWFsKGN1YmVtYXApKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW1lcmEgdXNlZCB3aGVuIHJlbmRlcmluZy4gSWYgdGhpcyB2YWx1ZSBpcyBub3Qgc2V0LCB0aGUgbWFpbiBjYW1lcmEgd2lsbCBcbiAgICogYmUgdXNlZCBieSBkZWZhdWx0LlxuICAgKi9cbiAgZ2V0IGNhbWVyYSgpIHtcbiAgICByZXR1cm4gKDxTa3lib3hNYXRlcmlhbD50aGlzLl9tZXNoLm1hdGVyaWFsKS5jYW1lcmFcbiAgfVxuXG4gIHNldCBjYW1lcmEodmFsdWU6IENhbWVyYSB8IHVuZGVmaW5lZCkge1xuICAgICg8U2t5Ym94TWF0ZXJpYWw+dGhpcy5fbWVzaC5tYXRlcmlhbCkuY2FtZXJhID0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3ViZW1hcCB0ZXh0dXJlIHVzZWQgd2hlbiByZW5kZXJpbmcuXG4gICAqL1xuICBnZXQgY3ViZW1hcCgpIHtcbiAgICByZXR1cm4gKDxTa3lib3hNYXRlcmlhbD50aGlzLl9tZXNoLm1hdGVyaWFsKS5jdWJlbWFwXG4gIH1cblxuICBzZXQgY3ViZW1hcCh2YWx1ZTogQ3ViZW1hcCkge1xuICAgICg8U2t5Ym94TWF0ZXJpYWw+dGhpcy5fbWVzaC5tYXRlcmlhbCkuY3ViZW1hcCA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBza3lib3ggZnJvbSB0aGUgc3BlY2lmaWVkIHNvdXJjZS5cbiAgICogQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIHRvIGNyZWF0ZSB0aGUgc2t5Ym94IGZyb20uXG4gICAqL1xuICBzdGF0aWMgZnJvbShzb3VyY2U6IEN1YmVtYXBGYWNlcykge1xuICAgIHJldHVybiBuZXcgU2t5Ym94KEN1YmVtYXAuZnJvbUZhY2VzKHNvdXJjZSkpXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuZXhwb3J0IGludGVyZmFjZSBQb3N0UHJvY2Vzc2luZ1Nwcml0ZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlIGZvciB0aGUgc3ByaXRlLlxuICAgKi9cbiAgd2lkdGg/OiBudW1iZXIsXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlIGZvciB0aGUgc3ByaXRlLlxuICAgKi9cbiAgaGVpZ2h0PzogbnVtYmVyLFxuICAvKipcbiAgICogVGhlIG9iamVjdCB0byByZW5kZXIuIFdoZW4gc2V0LCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgcmVuZGVyZWQgdG8gdGhlIFxuICAgKiBzcHJpdGUncyB0ZXh0dXJlIGVhY2ggZnJhbWUuXG4gICAqL1xuICBvYmplY3RUb1JlbmRlcj86IFBJWEkuRGlzcGxheU9iamVjdFxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzcHJpdGUgd2hpY2ggaGFzIHBvc3QgcHJvY2Vzc2luZyBlZmZlY3RzLiBDYW4gYmUgdXNlZCBmb3IgXG4gKiByZW5kZXJpbmcgM0Qgb2JqZWN0cyBhcyAyRCBzcHJpdGVzLlxuICovXG5leHBvcnQgY2xhc3MgUG9zdFByb2Nlc3NpbmdTcHJpdGUgZXh0ZW5kcyBQSVhJLlNwcml0ZSB7XG4gIHByaXZhdGUgX3JlbmRlclRleHR1cmU6IFBJWEkuUmVuZGVyVGV4dHVyZVxuXG4gIC8qKiBUaGUgcmVuZGVyIHRleHR1cmUuICovXG4gIGdldCByZW5kZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJUZXh0dXJlXG4gIH1cblxuICAvKiogVGhlIGRlcHRoIHRleHR1cmUuICovXG4gIGdldCBkZXB0aFRleHR1cmUoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLmZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBvc3QgcHJvY2Vzc2luZyBzcHJpdGUgdXNpbmcgdGhlIHNwZWNpZmllZCBvcHRpb25zLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgVGhlIHJlbmRlcmVyIHRvIHVzZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSByZW5kZXIgdGV4dHVyZS4gSWYgYm90aCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAqIGhhcyBub3QgYmVlbiBzZXQsIGl0IHdpbGwgYXV0b21hdGljYWxseSBiZSByZXNpemVkIHRvIHRoZSByZW5kZXJlciBzaXplLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHJlbmRlcmVyOiBQSVhJLlJlbmRlcmVyLCBvcHRpb25zPzogUG9zdFByb2Nlc3NpbmdTcHJpdGVPcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgbGV0IHsgd2lkdGggPSA1MTIsIGhlaWdodCA9IDUxMiwgb2JqZWN0VG9SZW5kZXIgfSA9IG9wdGlvbnMgfHwge31cblxuICAgIHRoaXMuX3JlbmRlclRleHR1cmUgPSBQSVhJLlJlbmRlclRleHR1cmUuY3JlYXRlKHsgd2lkdGgsIGhlaWdodCB9KVxuICAgIC8qIFdoZW4gcmVuZGVyaW5nIHRvIGEgdGV4dHVyZSwgaXQncyBmbGlwcGVkIHZlcnRpY2FsbHkgZm9yIHNvbWUgcmVhc29uLiBcbiAgICBUaGlzIHdpbGwgZmxpcCBpdCBiYWNrIHRvIGl0J3MgZXhwZWN0ZWQgb3JpZW50YXRpb24uICovXG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yb3RhdGUgPSA4XG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlci5hZGREZXB0aFRleHR1cmUoKVxuICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl9yZW5kZXJUZXh0dXJlXG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2lkdGggfHwgIW9wdGlvbnMuaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5vbihcInByZXJlbmRlclwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUucmVzaXplKHJlbmRlcmVyLnNjcmVlbi53aWR0aCwgcmVuZGVyZXIuc2NyZWVuLmhlaWdodClcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChvYmplY3RUb1JlbmRlcikge1xuICAgICAgUElYSS5UaWNrZXIuc2hhcmVkLmFkZCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLndvcmxkVmlzaWJsZSAmJiB0aGlzLndvcmxkQWxwaGEgPiAwICYmIHRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgIG9iamVjdFRvUmVuZGVyICYmIHRoaXMucmVuZGVyT2JqZWN0KG9iamVjdFRvUmVuZGVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzcHJpdGUncyB0ZXh0dXJlIGJ5IHJlbmRlcmluZyB0aGUgc3BlY2lmaWVkIG9iamVjdCB0byBpdC5cbiAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIHJlbmRlci5cbiAgICovXG4gIHJlbmRlck9iamVjdChvYmplY3Q6IFBJWEkuRGlzcGxheU9iamVjdCkge1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKG9iamVjdCwgdGhpcy5fcmVuZGVyVGV4dHVyZSlcbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5leHBvcnQgY2xhc3MgUHJvamVjdGlvblNwcml0ZSBleHRlbmRzIFBJWEkuU3ByaXRlIHtcbiAgcHJpdmF0ZSBfcGl4ZWxzUGVyVW5pdCA9IDEwMFxuXG4gIG1vZGVsVmlld1Byb2plY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KDE2KVxuICBcbiAgY29uc3RydWN0b3IodGV4dHVyZT86IFBJWEkuVGV4dHVyZTxQSVhJLlJlc291cmNlPikge1xuICAgIHN1cGVyKHRleHR1cmUpXG4gICAgdGhpcy5wbHVnaW5OYW1lID0gXCJzcHJpdGUzZFwiXG4gIH1cblxuICBnZXQgcGl4ZWxzUGVyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxzUGVyVW5pdFxuICB9XG5cbiAgc2V0IHBpeGVsc1BlclVuaXQodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcGl4ZWxzUGVyVW5pdCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMVxuICAgICAgdGhpcy5fcGl4ZWxzUGVyVW5pdCA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmVcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCAmJiB0aGlzLl90ZXh0dXJlSUQgPT09IHRleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHRoaXMuX3RleHR1cmVJRCAhPT0gdGV4dHVyZS5fdXBkYXRlSUQpIHtcbiAgICAgIHRoaXMudXZzID0gdGhpcy5fdGV4dHVyZS5fdXZzLnV2c0Zsb2F0MzJcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSURcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSB0ZXh0dXJlLl91cGRhdGVJRFxuXG4gICAgY29uc3Qgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICBjb25zdCBvcmlnID0gdGV4dHVyZS5vcmlnXG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5fYW5jaG9yXG5cbiAgICBjb25zdCB3MSA9IHRleHR1cmUudHJpbSA/IHRleHR1cmUudHJpbS54IC0gKGFuY2hvci5feCAqIG9yaWcud2lkdGgpIDogLWFuY2hvci5feCAqIG9yaWcud2lkdGhcbiAgICBjb25zdCB3MCA9IHRleHR1cmUudHJpbSA/IHcxICsgdGV4dHVyZS50cmltLndpZHRoIDogdzEgKyBvcmlnLndpZHRoXG4gICAgY29uc3QgaDEgPSB0ZXh0dXJlLnRyaW0gPyB0ZXh0dXJlLnRyaW0ueSAtIChhbmNob3IuX3kgKiBvcmlnLmhlaWdodCkgOiAtYW5jaG9yLl95ICogb3JpZy5oZWlnaHRcbiAgICBjb25zdCBoMCA9IHRleHR1cmUudHJpbSA/IGgxICsgdGV4dHVyZS50cmltLmhlaWdodCA6IGgxICsgb3JpZy5oZWlnaHRcblxuICAgIHRoaXMudmVydGV4RGF0YVswXSA9ICgod3QuYSAqIHcxKSArICh3dC5jICogLWgxKSkgLyB0aGlzLl9waXhlbHNQZXJVbml0XG4gICAgdGhpcy52ZXJ0ZXhEYXRhWzFdID0gKCh3dC5kICogLWgxKSArICh3dC5iICogdzEpKSAvIHRoaXMuX3BpeGVsc1BlclVuaXRcblxuICAgIHRoaXMudmVydGV4RGF0YVsyXSA9ICgod3QuYSAqIHcwKSArICh3dC5jICogLWgxKSkgLyB0aGlzLl9waXhlbHNQZXJVbml0XG4gICAgdGhpcy52ZXJ0ZXhEYXRhWzNdID0gKCh3dC5kICogLWgxKSArICh3dC5iICogdzApKSAvIHRoaXMuX3BpeGVsc1BlclVuaXRcblxuICAgIHRoaXMudmVydGV4RGF0YVs0XSA9ICgod3QuYSAqIHcwKSArICh3dC5jICogLWgwKSkgLyB0aGlzLl9waXhlbHNQZXJVbml0XG4gICAgdGhpcy52ZXJ0ZXhEYXRhWzVdID0gKCh3dC5kICogLWgwKSArICh3dC5iICogdzApKSAvIHRoaXMuX3BpeGVsc1BlclVuaXRcblxuICAgIHRoaXMudmVydGV4RGF0YVs2XSA9ICgod3QuYSAqIHcxKSArICh3dC5jICogLWgwKSkgLyB0aGlzLl9waXhlbHNQZXJVbml0XG4gICAgdGhpcy52ZXJ0ZXhEYXRhWzddID0gKCh3dC5kICogLWgwKSArICh3dC5iICogdzEpKSAvIHRoaXMuX3BpeGVsc1BlclVuaXRcblxuICAgIGlmICh0aGlzLnJvdW5kUGl4ZWxzKSB7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gUElYSS5zZXR0aW5ncy5SRVNPTFVUSU9OXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGV4RGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLnZlcnRleERhdGFbaV0gPSBNYXRoLnJvdW5kKCh0aGlzLnZlcnRleERhdGFbaV0gKiByZXNvbHV0aW9uIHwgMCkgLyByZXNvbHV0aW9uKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcnNbJWNvdW50JV07XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgICB2ZWM0IGNvbG9yO1xcbiAgICAlZm9ybG9vcCVcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yICogdmVjNChjb2xvci5yZ2IsIGNvbG9yLmEpO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcblxcbmF0dHJpYnV0ZSB2ZWM0IGFNYXRyaXgwO1xcbmF0dHJpYnV0ZSB2ZWM0IGFNYXRyaXgxO1xcbmF0dHJpYnV0ZSB2ZWM0IGFNYXRyaXgyO1xcbmF0dHJpYnV0ZSB2ZWM0IGFNYXRyaXgzO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCBhVGV4dHVyZUlkO1xcblxcbnVuaWZvcm0gdmVjNCB0aW50O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyBmbG9hdCB2VGV4dHVyZUlkO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBtYXQ0IG1vZGVsTWF0cml4ID0gbWF0NChhTWF0cml4MCwgYU1hdHJpeDEsIGFNYXRyaXgyLCBhTWF0cml4Myk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24ueHksIDAuMCwgMS4wKTtcXG5cXG4gIHZUZXh0dXJlQ29vcmQgPSB2ZWMyKGFUZXh0dXJlQ29vcmQueCwgYVRleHR1cmVDb29yZC55KTtcXG4gIHZUZXh0dXJlSWQgPSBhVGV4dHVyZUlkO1xcbiAgdkNvbG9yID0gYUNvbG9yICogdGludDtcXG59XCIiLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuZXhwb3J0IGNsYXNzIFNwcml0ZUJhdGNoR2VvbWV0cnkgZXh0ZW5kcyBQSVhJLkJhdGNoR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLmFkZEF0dHJpYnV0ZShcImFNYXRyaXgwXCIsIHRoaXMuX2J1ZmZlciwgNCwgZmFsc2UsIFBJWEkuVFlQRVMuRkxPQVQpXG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhTWF0cml4MVwiLCB0aGlzLl9idWZmZXIsIDQsIGZhbHNlLCBQSVhJLlRZUEVTLkZMT0FUKVxuICAgIHRoaXMuYWRkQXR0cmlidXRlKFwiYU1hdHJpeDJcIiwgdGhpcy5fYnVmZmVyLCA0LCBmYWxzZSwgUElYSS5UWVBFUy5GTE9BVClcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZShcImFNYXRyaXgzXCIsIHRoaXMuX2J1ZmZlciwgNCwgZmFsc2UsIFBJWEkuVFlQRVMuRkxPQVQpXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgU3ByaXRlQmF0Y2hHZW9tZXRyeSB9IGZyb20gXCIuL3Nwcml0ZS1iYXRjaC1nZW9tZXRyeVwiXG5cbmV4cG9ydCBjbGFzcyBTcHJpdGVCYXRjaFJlbmRlcmVyIGV4dGVuZHMgUElYSS5BYnN0cmFjdEJhdGNoUmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcjogUElYSS5SZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKVxuXG4gICAgdGhpcy5zaGFkZXJHZW5lcmF0b3IgPSBuZXcgUElYSS5CYXRjaFNoYWRlckdlbmVyYXRvcihcbiAgICAgIHJlcXVpcmUoXCIuL3NoYWRlci9zcHJpdGUudmVydFwiKSwgcmVxdWlyZShcIi4vc2hhZGVyL3Nwcml0ZS5mcmFnXCIpKVxuICAgIHRoaXMuZ2VvbWV0cnlDbGFzcyA9IFNwcml0ZUJhdGNoR2VvbWV0cnlcblxuICAgIC8vIFRoZSB2ZXJ0ZXggc2l6ZSB3aGVuIHJlbmRlcmluZyAyRCBzcHJpdGVzIGlzIDYuIEhlcmUsIDE2IGlzIGJlaW5nIGFkZGVkIFxuICAgIC8vIHRvIGhvbGQgdGhlIG1vZGVsIG1hdHJpeC5cbiAgICB0aGlzLnZlcnRleFNpemUgPSA2ICsgMTZcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwge1xuICAgICAgY3VsbGluZzogZmFsc2UsIGNsb2Nrd2lzZUZyb250RmFjZTogZmFsc2UsIGRlcHRoVGVzdDogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBwYWNrSW50ZXJsZWF2ZWRHZW9tZXRyeShlbGVtZW50OiBQSVhJLklCYXRjaGFibGVFbGVtZW50LCBhdHRyaWJ1dGVCdWZmZXI6IFBJWEkuVmlld2FibGVCdWZmZXIsIGluZGV4QnVmZmVyOiBVaW50MTZBcnJheSwgYUluZGV4OiBudW1iZXIsIGlJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgeyB1aW50MzJWaWV3LCBmbG9hdDMyVmlldyB9ID0gYXR0cmlidXRlQnVmZmVyXG4gICAgY29uc3QgcGFja2VkVmVydGljZXMgPSBhSW5kZXggLyB0aGlzLnZlcnRleFNpemVcbiAgICBjb25zdCB1dnMgPSBlbGVtZW50LnV2c1xuICAgIGNvbnN0IGluZGljaWVzID0gZWxlbWVudC5pbmRpY2VzXG4gICAgY29uc3QgdmVydGV4RGF0YSA9IGVsZW1lbnQudmVydGV4RGF0YVxuICAgIGNvbnN0IHRleHR1cmVJZCA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuX2JhdGNoTG9jYXRpb25cblxuICAgIGNvbnN0IGFscGhhID0gTWF0aC5taW4oZWxlbWVudC53b3JsZEFscGhhLCAxLjApXG4gICAgY29uc3QgYXJnYiA9IChhbHBoYSA8IDEuMFxuICAgICAgJiYgZWxlbWVudC5fdGV4dHVyZS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUpXG4gICAgICA/IFBJWEkudXRpbHMucHJlbXVsdGlwbHlUaW50KGVsZW1lbnQuX3RpbnRSR0IsIGFscGhhKVxuICAgICAgOiBlbGVtZW50Ll90aW50UkdCICsgKGFscGhhICogMjU1IDw8IDI0KVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBmbG9hdDMyVmlld1thSW5kZXgrK10gPSB2ZXJ0ZXhEYXRhW2ldXG4gICAgICBmbG9hdDMyVmlld1thSW5kZXgrK10gPSB2ZXJ0ZXhEYXRhW2kgKyAxXVxuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdXZzW2ldXG4gICAgICBmbG9hdDMyVmlld1thSW5kZXgrK10gPSB1dnNbaSArIDFdXG4gICAgICB1aW50MzJWaWV3W2FJbmRleCsrXSA9IGFyZ2JcbiAgICAgIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHRleHR1cmVJZFxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gZWxlbWVudC5tb2RlbFZpZXdQcm9qZWN0aW9uW2pdXG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGV4QnVmZmVyW2lJbmRleCsrXSA9IHBhY2tlZFZlcnRpY2VzICsgaW5kaWNpZXNbaV1cbiAgICB9XG4gIH1cbn1cblxuUElYSS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbihcInNwcml0ZTNkXCIsIFNwcml0ZUJhdGNoUmVuZGVyZXIpIiwiLyoqXG4gKiBSZXByZXNlbnRzIGRpZmZlcmVudCBiaWxsYm9hcmQgdHlwZXMuXG4gKi9cbmV4cG9ydCBlbnVtIFNwcml0ZUJpbGxib2FyZFR5cGUge1xuICAvKipcbiAgICogU3ByaXRlIHdpbGwgYmUgcm90YXRlZCB0b3dhcmRzIHRoZSB2aWV3ZXIgb24gYm90aCB0aGUgeC1wbGFuZSBhbmQgeS1wbGFuZS5cbiAgICovXG4gIFNwaGVyaWNhbCA9IFwic3BoZXJpY2FsXCIsXG4gIC8qKlxuICAgKiBTcHJpdGUgd2lsbCBiZSByb3RhdGVkIHRvd2FyZHMgdGhlIHZpZXdlciBvbiB0aGUgeS1wbGFuZS5cbiAgICovXG4gIEN5bGluZHJpY2FsID0gXCJjeWxpbmRyaWNhbFwiLFxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiLi4vY2FtZXJhL2NhbWVyYVwiXG5pbXBvcnQgeyBTcHJpdGVCaWxsYm9hcmRUeXBlIH0gZnJvbSBcIi4vc3ByaXRlLWJpbGxib2FyZC10eXBlXCJcbmltcG9ydCB7IENvbnRhaW5lcjNEIH0gZnJvbSBcIi4uL2NvbnRhaW5lclwiXG5pbXBvcnQgeyBNYXQ0IH0gZnJvbSBcIi4uL21hdGgvbWF0NFwiXG5pbXBvcnQgeyBQcm9qZWN0aW9uU3ByaXRlIH0gZnJvbSBcIi4vcHJvamVjdGlvbi1zcHJpdGVcIlxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzcHJpdGUgaW4gM0Qgc3BhY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcHJpdGUzRCBleHRlbmRzIENvbnRhaW5lcjNEIHtcbiAgcHJpdmF0ZSBfc3ByaXRlOiBQcm9qZWN0aW9uU3ByaXRlXG4gIHByaXZhdGUgX21vZGVsVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpXG4gIHByaXZhdGUgX2NhbWVyYVRyYW5zZm9ybUlkPzogbnVtYmVyXG4gIHByaXZhdGUgX2JpbGxib2FyZFR5cGU/OiBTcHJpdGVCaWxsYm9hcmRUeXBlXG4gIHByaXZhdGUgX3BhcmVudElEPzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIFRoZSBjYW1lcmEgdXNlZCB3aGVuIHJlbmRlcmluZyB0aGUgc3ByaXRlLiBVc2VzIG1haW4gY2FtZXJhIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBjYW1lcmE/OiBDYW1lcmFcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzcHJpdGUgdXNpbmcgdGhlIHNwZWNpZmllZCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gdGV4dHVyZSBUaGUgdGV4dHVyZSB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlOiBQSVhJLlRleHR1cmU8UElYSS5SZXNvdXJjZT4pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fc3ByaXRlID0gbmV3IFByb2plY3Rpb25TcHJpdGUodGV4dHVyZSlcbiAgICB0aGlzLl9zcHJpdGUuYW5jaG9yLnNldCgwLjUpXG4gIH1cblxuICAvKipcbiAgICogVGhlIGJpbGxib2FyZCB0eXBlIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgc3ByaXRlLiBVc2VkIGZvciBtYWtpbmcgdGhlIFxuICAgKiBzcHJpdGUgYWx3YXlzIGZhY2UgdGhlIHZpZXdlci5cbiAgICovXG4gIGdldCBiaWxsYm9hcmRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaWxsYm9hcmRUeXBlXG4gIH1cblxuICBzZXQgYmlsbGJvYXJkVHlwZSh2YWx1ZTogU3ByaXRlQmlsbGJvYXJkVHlwZSB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYmlsbGJvYXJkVHlwZSkge1xuICAgICAgdGhpcy5fYmlsbGJvYXJkVHlwZSA9IHZhbHVlXG4gICAgICB0aGlzLl9jYW1lcmFUcmFuc2Zvcm1JZCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKiBEZWZpbmVzIHRoZSBzaXplIG9mIHRoZSBzcHJpdGUgcmVsYXRpdmUgdG8gYSB1bml0IGluIHdvcmxkIHNwYWNlLiAqL1xuICBnZXQgcGl4ZWxzUGVyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ByaXRlLnBpeGVsc1BlclVuaXRcbiAgfVxuXG4gIHNldCBwaXhlbHNQZXJVbml0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9zcHJpdGUucGl4ZWxzUGVyVW5pdCA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIFxuICAgKiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAqL1xuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ByaXRlLnRpbnRcbiAgfVxuXG4gIHNldCB0aW50KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9zcHJpdGUudGludCA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBzcHJpdGUgYW5kIG9wdGlvbmFsbHkgaXRzIHRleHR1cmUgYW5kIGNoaWxkcmVuLlxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zPzogYm9vbGVhbiB8IFBJWEkuSURlc3Ryb3lPcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKVxuICAgIHRoaXMuX3Nwcml0ZS5kZXN0cm95KG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc3ByaXRlLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgVGhlIHJlbmRlcmVyIHRvIHVzZS5cbiAgICovXG4gIF9yZW5kZXIocmVuZGVyZXI6IFBJWEkuUmVuZGVyZXIpIHtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYSB8fCBDYW1lcmEubWFpblxuICAgIGNvbnN0IHVwZGF0ZSA9IGNhbWVyYS50cmFuc2Zvcm1JZCAhPT0gdGhpcy5fY2FtZXJhVHJhbnNmb3JtSWQgfHxcbiAgICAgIHRoaXMuX3BhcmVudElEICE9PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRFxuXG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgY29uc3Qgc2NhbGluZyA9IHRoaXMud29ybGRUcmFuc2Zvcm0uc2NhbGluZ1xuICAgICAgTWF0NC5tdWx0aXBseShjYW1lcmEudmlldywgdGhpcy53b3JsZFRyYW5zZm9ybS5hcnJheSwgdGhpcy5fbW9kZWxWaWV3KVxuICAgICAgc3dpdGNoICh0aGlzLl9iaWxsYm9hcmRUeXBlKSB7XG4gICAgICAgIGNhc2UgU3ByaXRlQmlsbGJvYXJkVHlwZS5TcGhlcmljYWw6IHtcbiAgICAgICAgICB0aGlzLl9tb2RlbFZpZXdbMF0gPSBzY2FsaW5nWzBdXG4gICAgICAgICAgdGhpcy5fbW9kZWxWaWV3WzFdID0gMFxuICAgICAgICAgIHRoaXMuX21vZGVsVmlld1syXSA9IDBcbiAgICAgICAgICB0aGlzLl9tb2RlbFZpZXdbM10gPSAwXG4gICAgICAgICAgdGhpcy5fbW9kZWxWaWV3WzRdID0gMFxuICAgICAgICAgIHRoaXMuX21vZGVsVmlld1s1XSA9IHNjYWxpbmdbMV1cbiAgICAgICAgICB0aGlzLl9tb2RlbFZpZXdbNl0gPSAwXG4gICAgICAgICAgdGhpcy5fbW9kZWxWaWV3WzddID0gMFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBTcHJpdGVCaWxsYm9hcmRUeXBlLkN5bGluZHJpY2FsOiB7XG4gICAgICAgICAgdGhpcy5fbW9kZWxWaWV3WzBdID0gc2NhbGluZ1swXVxuICAgICAgICAgIHRoaXMuX21vZGVsVmlld1sxXSA9IDBcbiAgICAgICAgICB0aGlzLl9tb2RlbFZpZXdbMl0gPSAwXG4gICAgICAgICAgdGhpcy5fbW9kZWxWaWV3WzNdID0gMFxuICAgICAgICAgIHRoaXMuX21vZGVsVmlld1s4XSA9IDBcbiAgICAgICAgICB0aGlzLl9tb2RlbFZpZXdbOV0gPSAwXG4gICAgICAgICAgdGhpcy5fbW9kZWxWaWV3WzEwXSA9IDFcbiAgICAgICAgICB0aGlzLl9tb2RlbFZpZXdbMTFdID0gMFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE1hdDQubXVsdGlwbHkoY2FtZXJhLnByb2plY3Rpb24sXG4gICAgICAgIHRoaXMuX21vZGVsVmlldywgdGhpcy5fc3ByaXRlLm1vZGVsVmlld1Byb2plY3Rpb24pXG4gICAgICB0aGlzLl9wYXJlbnRJRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEXG4gICAgICB0aGlzLl9jYW1lcmFUcmFuc2Zvcm1JZCA9IGNhbWVyYS50cmFuc2Zvcm1JZFxuICAgIH1cbiAgICB0aGlzLl9zcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYVxuICAgIHRoaXMuX3Nwcml0ZS5yZW5kZXIocmVuZGVyZXIpXG4gIH1cblxuICAvKipcbiAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHNwcml0ZS5cbiAgICovXG4gIGdldCBhbmNob3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nwcml0ZS5hbmNob3JcbiAgfVxuXG4gIHNldCBhbmNob3IodmFsdWU6IFBJWEkuT2JzZXJ2YWJsZVBvaW50KSB7XG4gICAgdGhpcy5fc3ByaXRlLmFuY2hvciA9IHZhbHVlXG4gIH1cblxuICAvKiogVGhlIHRleHR1cmUgdXNlZCB3aGVuIHJlbmRlcmluZyB0aGUgc3ByaXRlLiAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ByaXRlLnRleHR1cmVcbiAgfVxuXG4gIHNldCB0ZXh0dXJlKHZhbHVlOiBQSVhJLlRleHR1cmU8UElYSS5SZXNvdXJjZT4pIHtcbiAgICB0aGlzLl9zcHJpdGUudGV4dHVyZSA9IHZhbHVlXG4gIH1cblxuICAvKiogVGhlIGJsZW5kIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIHNwcml0ZS4gKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ByaXRlLmJsZW5kTW9kZVxuICB9XG5cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZTogUElYSS5CTEVORF9NT0RFUykge1xuICAgIHRoaXMuX3Nwcml0ZS5ibGVuZE1vZGUgPSB2YWx1ZVxuICB9XG59IiwiaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiXG5cbmltcG9ydCB7IE1hdDMgfSBmcm9tIFwiLi4vbWF0aC9tYXQzXCJcbmltcG9ydCB7IEtIUl90ZXh0dXJlX3RyYW5zZm9ybSB9IGZyb20gXCIuL2toclRleHR1cmVUcmFuc2Zvcm1cIlxuXG5leHBvcnQgY2xhc3MgVGV4dHVyZVRyYW5zZm9ybSB7XG4gIHByaXZhdGUgc3RhdGljIF91dlRyYW5zTWF0OiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpXG4gIHByaXZhdGUgc3RhdGljIF91dlJvdE1hdDogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KVxuICBwcml2YXRlIHN0YXRpYyBfdXZTY2FsZU1hdDogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHV2IHRyYW5zZm9ybSBtYXRyaXggYmFzZWQgb24gXCJvZmZzZXRcIiwgXCJyb3RhdGlvblwiIGFuZCBcInNjYWxlXCIgXG4gICAqIHBhcmFtZXRlcnMgZnJvbSBleHRlbnNpb24gZGF0YSAoaWYgYW55KSwgYW5kIGF0dGFjaGVzIGl0IHRvIHRleHR1cmVcbiAgICogQHBhcmFtIEtIUl90ZXh0dXJlX3RyYW5zZm9ybSBleHRlbnNpb24gZGF0YSBmcm9tIGdsdGYgZmlsZVxuICAgKiBAcGFyYW0gdGV4dHVyZSBUZXh0dXJlIHRvIGF0dGFjaCBnZW5lcmF0ZWQgbWF0cml4IHRvXG4gICAqL1xuICBzdGF0aWMgY2FsY3VsYXRlVVZUcmFuc2Zvcm0odXZUcmFuc2Zvcm06IEtIUl90ZXh0dXJlX3RyYW5zZm9ybSwgdGV4dHVyZTogUElYSS5UZXh0dXJlKSB7XG4gICAgVGV4dHVyZVRyYW5zZm9ybS5fdXZUcmFuc01hdC5zZXQoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdLCAwKVxuICAgIFRleHR1cmVUcmFuc2Zvcm0uX3V2Um90TWF0LnNldChbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0sIDApXG4gICAgVGV4dHVyZVRyYW5zZm9ybS5fdXZTY2FsZU1hdC5zZXQoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdLCAwKVxuXG4gICAgaWYgKHV2VHJhbnNmb3JtLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbih1dlRyYW5zZm9ybS5yb3RhdGlvbilcbiAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyh1dlRyYW5zZm9ybS5yb3RhdGlvbilcbiAgICAgIFRleHR1cmVUcmFuc2Zvcm0uX3V2Um90TWF0LnNldChbYywgcywgMCwgLXMsIGMsIDAsIDAsIDAsIDFdLCAwKVxuICAgIH1cbiAgICBpZiAodXZUcmFuc2Zvcm0uc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgVGV4dHVyZVRyYW5zZm9ybS5fdXZTY2FsZU1hdC5zZXQoW3V2VHJhbnNmb3JtLnNjYWxlWzBdLCAwLCAwLCAwLCB1dlRyYW5zZm9ybS5zY2FsZVsxXSwgMCwgMCwgMCwgMV0sIDApXG4gICAgfVxuICAgIGlmICh1dlRyYW5zZm9ybS5vZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgVGV4dHVyZVRyYW5zZm9ybS5fdXZUcmFuc01hdC5zZXQoWzEsIDAsIHV2VHJhbnNmb3JtLm9mZnNldFswXSwgMCwgMSwgdXZUcmFuc2Zvcm0ub2Zmc2V0WzFdLCAwLCAwLCAxXSwgMClcbiAgICB9XG5cbiAgICBsZXQgdXZNYXRyaXg6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdKVxuICAgIE1hdDMubXVsdGlwbHkoVGV4dHVyZVRyYW5zZm9ybS5fdXZSb3RNYXQsIFRleHR1cmVUcmFuc2Zvcm0uX3V2U2NhbGVNYXQsIHV2TWF0cml4KVxuICAgIE1hdDMubXVsdGlwbHkodXZNYXRyaXgsIFRleHR1cmVUcmFuc2Zvcm0uX3V2VHJhbnNNYXQsIHV2TWF0cml4KTtcblxuICAgICg8YW55PnRleHR1cmUpLnV2VHJhbnNmb3JtID0gdXZNYXRyaXhcbiAgfVxufSIsImltcG9ydCB7IFRyYW5zZm9ybUlkIH0gZnJvbSBcIi4vdHJhbnNmb3JtLWlkXCJcblxuZXhwb3J0IGNsYXNzIE1hdHJpeENvbXBvbmVudCB7XG4gIHByaXZhdGUgX2lkPzogbnVtYmVyXG4gIHByaXZhdGUgX2FycmF5OiBGbG9hdDMyQXJyYXlcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnQ6IFRyYW5zZm9ybUlkLCBzaXplOiBudW1iZXIsIHByaXZhdGUgX3VwZGF0ZTogKGFycmF5OiBGbG9hdDMyQXJyYXkpID0+IHZvaWQpIHtcbiAgICB0aGlzLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSlcbiAgfVxuXG4gIGdldCBhcnJheSgpIHtcbiAgICBpZiAodGhpcy5faWQgIT09IHRoaXMuX3BhcmVudC50cmFuc2Zvcm1JZCkge1xuICAgICAgdGhpcy5fdXBkYXRlKHRoaXMuX2FycmF5KTsgdGhpcy5faWQgPSB0aGlzLl9wYXJlbnQudHJhbnNmb3JtSWRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5XG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgaW4gM0Qgc3BhY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBPYnNlcnZhYmxlUG9pbnQzRCBleHRlbmRzIFBJWEkuT2JzZXJ2YWJsZVBvaW50IHtcbiAgcHJpdmF0ZSBfYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG5cbiAgLyoqIEFycmF5IGNvbnRhaW5pbmcgdGhlIHgsIHksIHogdmFsdWVzLiAqL1xuICBnZXQgYXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5XG4gIH1cblxuICBzZXQgYXJyYXkodmFsdWU6IEZsb2F0MzJBcnJheSkge1xuICAgIHRoaXMuc2V0RnJvbSh2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9ic2VydmFibGUgcG9pbnQuXG4gICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgd2hlbiBjaGFuZ2VkLlxuICAgKiBAcGFyYW0gc2NvcGUgVGhlIG93bmVyIG9mIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0geCBUaGUgcG9zaXRpb24gb24gdGhlIHggYXhpcy5cbiAgICogQHBhcmFtIHkgVGhlIHBvc2l0aW9uIG9uIHRoZSB5IGF4aXMuXG4gICAqIEBwYXJhbSB6IFRoZSBwb3NpdGlvbiBvbiB0aGUgeiBheGlzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2I6ICgpID0+IHZvaWQsIHNjb3BlOiBhbnksIHggPSAwLCB5ID0gMCwgeiA9IDApIHtcbiAgICBzdXBlcihjYiwgc2NvcGUpXG4gICAgdGhpcy5fYXJyYXkuc2V0KFt4LCB5LCB6XSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5WzBdXG4gIH1cblxuICBzZXQgeCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX2FycmF5WzBdICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fYXJyYXlbMF0gPSB2YWx1ZVxuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIG9uIHRoZSB5IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbMV1cbiAgfVxuXG4gIHNldCB5KHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5fYXJyYXlbMV0gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9hcnJheVsxXSA9IHZhbHVlXG4gICAgICB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUG9zaXRpb24gb24gdGhlIHogYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICovXG4gIGdldCB6KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVsyXVxuICB9XG5cbiAgc2V0IHoodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl9hcnJheVsyXSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FycmF5WzJdID0gdmFsdWVcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICAgIH1cbiAgfVxuXG4gIGNsb25lKGNiID0gdGhpcy5jYiwgc2NvcGUgPSB0aGlzLnNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUG9pbnQzRChjYiwgc2NvcGUsIHRoaXMueCwgdGhpcy55LCB0aGlzLnopXG4gIH1cblxuICBjb3B5RnJvbShwOiBPYnNlcnZhYmxlUG9pbnQzRCkge1xuICAgIGlmICh0aGlzLl9hcnJheVswXSAhPT0gcC54IHx8IHRoaXMuX2FycmF5WzFdICE9PSBwLnkgfHwgdGhpcy5fYXJyYXlbMl0gIT09IHAueikge1xuICAgICAgdGhpcy5fYXJyYXlbMF0gPSBwLnhcbiAgICAgIHRoaXMuX2FycmF5WzFdID0gcC55XG4gICAgICB0aGlzLl9hcnJheVsyXSA9IHAuelxuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjb3B5VG88VCBleHRlbmRzIFBJWEkuSVBvaW50PihwOiBUKSB7XG4gICAgaWYgKHAgaW5zdGFuY2VvZiBPYnNlcnZhYmxlUG9pbnQzRCkge1xuICAgICAgcC5zZXQodGhpcy54LCB0aGlzLnksIHRoaXMueilcbiAgICB9XG4gICAgcmV0dXJuIDxUPnBcbiAgfVxuXG4gIGVxdWFscyhwOiBPYnNlcnZhYmxlUG9pbnQzRCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwLnggPT09IHRoaXMueCAmJiBwLnkgPT09IHRoaXMueSAmJiBwLnogPT09IHRoaXMuelxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IHgsIHkgYW5kIHogcG9zaXRpb24uXG4gICAqIEBwYXJhbSB4IFRoZSBwb3NpdGlvbiBvbiB0aGUgeCBheGlzLlxuICAgKiBAcGFyYW0geSBUaGUgcG9zaXRpb24gb24gdGhlIHkgYXhpcy5cbiAgICogQHBhcmFtIHogVGhlIHBvc2l0aW9uIG9uIHRoZSB6IGF4aXMuXG4gICAqL1xuICBzZXQoeDogbnVtYmVyLCB5ID0geCwgeiA9IHgpIHtcbiAgICBpZiAodGhpcy5fYXJyYXlbMF0gIT09IHggfHwgdGhpcy5fYXJyYXlbMV0gIT09IHkgfHwgdGhpcy5fYXJyYXlbMl0gIT09IHopIHtcbiAgICAgIHRoaXMuX2FycmF5WzBdID0geFxuICAgICAgdGhpcy5fYXJyYXlbMV0gPSB5XG4gICAgICB0aGlzLl9hcnJheVsyXSA9IHpcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IHgsIHkgYW5kIHogcG9zaXRpb24uXG4gICAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgY29udGFpbmluZyB4LCB5IGFuZCB6LCBleHBlY3RlZCBsZW5ndGggaXMgMy5cbiAgICovXG4gIHNldEZyb20oYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+KSB7XG4gICAgdGhpcy5zZXQoYXJyYXlbMF0sIGFycmF5WzFdLCBhcnJheVsyXSk7IHJldHVybiB0aGlzXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgUXVhdCB9IGZyb20gXCIuLi9tYXRoL3F1YXRcIlxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByb3RhdGlvbiBxdWF0ZXJuaW9uIGluIDNEIHNwYWNlLlxuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZVF1YXRlcm5pb24gZXh0ZW5kcyBQSVhJLk9ic2VydmFibGVQb2ludCB7XG4gIHByaXZhdGUgX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg0KVxuXG4gIC8qKiBBcnJheSBjb250YWluaW5nIHRoZSB4LCB5LCB6LCB3IHZhbHVlcy4gKi9cbiAgZ2V0IGFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVxuICB9XG5cbiAgc2V0IGFycmF5KHZhbHVlOiBGbG9hdDMyQXJyYXkpIHtcbiAgICB0aGlzLnNldEZyb20odmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvYnNlcnZhYmxlIHF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgd2hlbiBjaGFuZ2VkLlxuICAgKiBAcGFyYW0gc2NvcGUgVGhlIG93bmVyIG9mIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0geCBUaGUgeCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB5IFRoZSB5IGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHogVGhlIHogY29tcG9uZW50LlxuICAgKiBAcGFyYW0gdyBUaGUgdyBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYjogKCkgPT4gdm9pZCwgc2NvcGU6IGFueSwgeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEpIHtcbiAgICBzdXBlcihjYiwgc2NvcGUpXG4gICAgdGhpcy5fYXJyYXkuc2V0KFt4LCB5LCB6LCB3XSlcbiAgfVxuXG4gIC8qKiBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHF1YXRlcm5pb24uICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVswXVxuICB9XG5cbiAgc2V0IHgodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl9hcnJheVswXSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FycmF5WzBdID0gdmFsdWVcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHF1YXRlcm5pb24uICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVsxXVxuICB9XG5cbiAgc2V0IHkodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl9hcnJheVsxXSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FycmF5WzFdID0gdmFsdWVcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHF1YXRlcm5pb24uICovXG4gIGdldCB6KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVsyXVxuICB9XG5cbiAgc2V0IHoodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl9hcnJheVsyXSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FycmF5WzJdID0gdmFsdWVcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGUgdyBjb21wb25lbnQgb2YgdGhlIHF1YXRlcm5pb24uICovXG4gIGdldCB3KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVszXVxuICB9XG5cbiAgc2V0IHcodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl9hcnJheVszXSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FycmF5WzNdID0gdmFsdWVcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBldWxlciBhbmdsZXMgaW4gZGVncmVlcy5cbiAgICogQHBhcmFtIHggVGhlIHggYW5nbGUuXG4gICAqIEBwYXJhbSB5IFRoZSB5IGFuZ2xlLlxuICAgKiBAcGFyYW0geiBUaGUgeiBhbmdsZS5cbiAgICovXG4gIHNldEV1bGVyQW5nbGVzKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpIHtcbiAgICBRdWF0LmZyb21FdWxlcih4LCB5LCB6LCB0aGlzLl9hcnJheSk7IHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSBjYiBDYWxsYmFjayB3aGVuIGNoYW5nZWQuXG4gICAqIEBwYXJhbSBzY29wZSBPd25lciBvZiBjYWxsYmFjay5cbiAgICovXG4gIGNsb25lKGNiID0gdGhpcy5jYiwgc2NvcGUgPSB0aGlzLnNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUXVhdGVybmlvbihjYiwgc2NvcGUsIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudylcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgeCwgeSwgeiwgYW5kIHcgZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvbi5cbiAgICogQHBhcmFtIHAgVGhlIHF1YXRlcm5pb24gdG8gY29weSBmcm9tLlxuICAgKi9cbiAgY29weUZyb20ocDogT2JzZXJ2YWJsZVF1YXRlcm5pb24pIHtcbiAgICBpZiAodGhpcy5fYXJyYXlbMF0gIT09IHAueCB8fCB0aGlzLl9hcnJheVsxXSAhPT0gcC55IHx8IHRoaXMuX2FycmF5WzJdICE9PSBwLnogfHwgdGhpcy5fYXJyYXlbM10gIT09IHAudykge1xuICAgICAgdGhpcy5fYXJyYXlbMF0gPSBwLnhcbiAgICAgIHRoaXMuX2FycmF5WzFdID0gcC55XG4gICAgICB0aGlzLl9hcnJheVsyXSA9IHAuelxuICAgICAgdGhpcy5fYXJyYXlbM10gPSBwLndcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB4LCB5LCB6IGFuZCB3IGludG8gdGhlIGdpdmVuIHF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSBwIFRoZSBxdWF0ZXJuaW9uIHRvIGNvcHkgdG8uXG4gICAqL1xuICBjb3B5VG88VCBleHRlbmRzIFBJWEkuSVBvaW50PihwOiBUKSB7XG4gICAgaWYgKHAgaW5zdGFuY2VvZiBPYnNlcnZhYmxlUXVhdGVybmlvbikge1xuICAgICAgcC5zZXQodGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53KVxuICAgIH1cbiAgICByZXR1cm4gPFQ+cFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcXVhdGVybmlvbiBpcyBlcXVhbCB0byB0aGlzIHF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSBwIFRoZSBxdWF0ZXJuaW9uIHRvIGNoZWNrLlxuICAgKi9cbiAgZXF1YWxzKHA6IE9ic2VydmFibGVRdWF0ZXJuaW9uKSB7XG4gICAgcmV0dXJuIHAueCA9PT0gdGhpcy54ICYmIHAueSA9PT0gdGhpcy55ICYmIHAueiA9PT0gdGhpcy56ICYmIHAudyA9PT0gdGhpcy53XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcXVhdGVybmlvbiB0byBuZXcgeCwgeSwgeiBhbmQgdyBjb21wb25lbnRzLlxuICAgKiBAcGFyYW0geCBYIGNvbXBvbmVudCB0byBzZXQuXG4gICAqIEBwYXJhbSB5IFkgY29tcG9uZW50IHRvIHNldC5cbiAgICogQHBhcmFtIHogWiBjb21wb25lbnQgdG8gc2V0LlxuICAgKiBAcGFyYW0gdyBXIGNvbXBvbmVudCB0byBzZXQuXG4gICAqL1xuICBzZXQoeDogbnVtYmVyLCB5ID0geCwgeiA9IHgsIHcgPSB4KSB7XG4gICAgaWYgKHRoaXMuX2FycmF5WzBdICE9PSB4IHx8IHRoaXMuX2FycmF5WzFdICE9PSB5IHx8IHRoaXMuX2FycmF5WzJdICE9PSB6IHx8IHRoaXMuX2FycmF5WzNdICE9PSB3KSB7XG4gICAgICB0aGlzLl9hcnJheVswXSA9IHhcbiAgICAgIHRoaXMuX2FycmF5WzFdID0geVxuICAgICAgdGhpcy5fYXJyYXlbMl0gPSB6XG4gICAgICB0aGlzLl9hcnJheVszXSA9IHdcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHF1YXRlcm5pb24gdG8gYSBuZXcgeCwgeSwgeiBhbmQgdyBjb21wb25lbnRzLlxuICAgKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IGNvbnRhaW5pbmcgeCwgeSwgeiBhbmQgdywgZXhwZWN0ZWQgbGVuZ3RoIGlzIDQuXG4gICAqL1xuICBzZXRGcm9tKGFycmF5OiBBcnJheUxpa2U8bnVtYmVyPikge1xuICAgIHRoaXMuc2V0KGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0sIGFycmF5WzNdKTsgcmV0dXJuIHRoaXNcbiAgfVxufSIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIlxuXG5pbXBvcnQgeyBPYnNlcnZhYmxlUG9pbnQzRCB9IGZyb20gXCIuL29ic2VydmFibGUtcG9pbnRcIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZVF1YXRlcm5pb24gfSBmcm9tIFwiLi9vYnNlcnZhYmxlLXF1YXRlcm5pb25cIlxuaW1wb3J0IHsgTWF0NCB9IGZyb20gXCIuLi9tYXRoL21hdDRcIlxuaW1wb3J0IHsgVmVjMyB9IGZyb20gXCIuLi9tYXRoL3ZlYzNcIlxuaW1wb3J0IHsgVmVjNCB9IGZyb20gXCIuLi9tYXRoL3ZlYzRcIlxuaW1wb3J0IHsgTWF0cml4Q29tcG9uZW50IH0gZnJvbSBcIi4vbWF0cml4LWNvbXBvbmVudFwiXG5pbXBvcnQgeyBRdWF0IH0gZnJvbSBcIi4uL21hdGgvcXVhdFwiXG5pbXBvcnQgeyBUcmFuc2Zvcm1JZCB9IGZyb20gXCIuL3RyYW5zZm9ybS1pZFwiXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbWF0cml4IGZvciBhIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybU1hdHJpeCBleHRlbmRzIFBJWEkuTWF0cml4IGltcGxlbWVudHMgVHJhbnNmb3JtSWQge1xuICBwcml2YXRlIF90cmFuc2Zvcm1JZCA9IDBcbiAgcHJpdmF0ZSBfcG9zaXRpb24/OiBNYXRyaXhDb21wb25lbnRcbiAgcHJpdmF0ZSBfc2NhbGluZz86IE1hdHJpeENvbXBvbmVudFxuICBwcml2YXRlIF9yb3RhdGlvbj86IE1hdHJpeENvbXBvbmVudFxuICBwcml2YXRlIF91cD86IE1hdHJpeENvbXBvbmVudFxuICBwcml2YXRlIF9kb3duPzogTWF0cml4Q29tcG9uZW50XG4gIHByaXZhdGUgX2ZvcndhcmQ/OiBNYXRyaXhDb21wb25lbnRcbiAgcHJpdmF0ZSBfbGVmdD86IE1hdHJpeENvbXBvbmVudFxuICBwcml2YXRlIF9yaWdodD86IE1hdHJpeENvbXBvbmVudFxuICBwcml2YXRlIF9iYWNrd2FyZD86IE1hdHJpeENvbXBvbmVudFxuXG4gIGdldCB0cmFuc2Zvcm1JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtSWRcbiAgfVxuXG4gIC8qKiBUaGUgYXJyYXkgY29udGFpbmluZyB0aGUgbWF0cml4IGRhdGEuICovXG4gIHB1YmxpYyBhcnJheTogRmxvYXQzMkFycmF5XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNmb3JtIG1hdHJpeCB1c2luZyB0aGUgc3BlY2lmaWVkIG1hdHJpeCBhcnJheS5cbiAgICogQHBhcmFtIGFycmF5IFRoZSBtYXRyaXggYXJyYXksIGV4cGVjdGVkIGxlbmd0aCBpcyAxNi4gSWYgZW1wdHksIGFuIGlkZW50aXR5IFxuICAgKiBtYXRyaXggaXMgdXNlZCBieSBkZWZhdWx0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJyYXk/OiBBcnJheUxpa2U8bnVtYmVyPikge1xuICAgIHN1cGVyKClcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgIHRoaXMuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pXG4gICAgfVxuICB9XG5cbiAgdG9BcnJheSh0cmFuc3Bvc2U6IGJvb2xlYW4sIG91dD86IEZsb2F0MzJBcnJheSkge1xuICAgIGlmICh0cmFuc3Bvc2UpIHtcbiAgICAgIHJldHVybiBNYXQ0LnRyYW5zcG9zZSh0aGlzLmFycmF5LCBvdXQpXG4gICAgfVxuICAgIHJldHVybiBvdXQgPyBNYXQ0LmNvcHkodGhpcy5hcnJheSwgb3V0KSA6IHRoaXMuYXJyYXlcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBjb21wb25lbnQgb2YgdGhlIG1hdHJpeC4gKi9cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcG9zaXRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV3IE1hdHJpeENvbXBvbmVudCh0aGlzLCAzLCBkYXRhID0+IHtcbiAgICAgICAgTWF0NC5nZXRUcmFuc2xhdGlvbih0aGlzLmFycmF5LCBkYXRhKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uLmFycmF5XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgc2NhbGluZyBjb21wb25lbnQgb2YgdGhlIG1hdHJpeC4gKi9cbiAgZ2V0IHNjYWxpbmcoKSB7XG4gICAgaWYgKCF0aGlzLl9zY2FsaW5nKSB7XG4gICAgICB0aGlzLl9zY2FsaW5nID0gbmV3IE1hdHJpeENvbXBvbmVudCh0aGlzLCAzLCBkYXRhID0+IHtcbiAgICAgICAgTWF0NC5nZXRTY2FsaW5nKHRoaXMuYXJyYXksIGRhdGEpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2NhbGluZy5hcnJheVxuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHJvdGF0aW9uIHF1YXRlcm5pb24gb2YgdGhlIG1hdHJpeC4gKi9cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcm90YXRpb24pIHtcbiAgICAgIGxldCBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KVxuICAgICAgdGhpcy5fcm90YXRpb24gPSBuZXcgTWF0cml4Q29tcG9uZW50KHRoaXMsIDQsIGRhdGEgPT4ge1xuICAgICAgICAvLyBUbyBleHRyYWN0IGEgY29ycmVjdCByb3RhdGlvbiwgdGhlIHNjYWxpbmcgY29tcG9uZW50IG11c3QgYmUgZWxpbWluYXRlZC5cbiAgICAgICAgZm9yIChsZXQgY29sIG9mIFswLCAxLCAyXSkge1xuICAgICAgICAgIG1hdHJpeFtjb2wgKyAwXSA9IHRoaXMuYXJyYXlbY29sICsgMF0gLyB0aGlzLnNjYWxpbmdbMF1cbiAgICAgICAgICBtYXRyaXhbY29sICsgNF0gPSB0aGlzLmFycmF5W2NvbCArIDRdIC8gdGhpcy5zY2FsaW5nWzFdXG4gICAgICAgICAgbWF0cml4W2NvbCArIDhdID0gdGhpcy5hcnJheVtjb2wgKyA4XSAvIHRoaXMuc2NhbGluZ1syXVxuICAgICAgICB9XG4gICAgICAgIFF1YXQubm9ybWFsaXplKE1hdDQuZ2V0Um90YXRpb24obWF0cml4LCBkYXRhKSwgZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbi5hcnJheVxuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHVwIHZlY3RvciBvZiB0aGUgbWF0cml4LiAqL1xuICBnZXQgdXAoKSB7XG4gICAgaWYgKCF0aGlzLl91cCkge1xuICAgICAgdGhpcy5fdXAgPSBuZXcgTWF0cml4Q29tcG9uZW50KHRoaXMsIDMsIGRhdGEgPT4ge1xuICAgICAgICBWZWMzLm5vcm1hbGl6ZShWZWMzLnNldCh0aGlzLmFycmF5WzRdLCB0aGlzLmFycmF5WzVdLCB0aGlzLmFycmF5WzZdLCBkYXRhKSwgZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91cC5hcnJheVxuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGRvd24gdmVjdG9yIG9mIHRoZSBtYXRyaXguICovXG4gIGdldCBkb3duKCkge1xuICAgIGlmICghdGhpcy5fZG93bikge1xuICAgICAgdGhpcy5fZG93biA9IG5ldyBNYXRyaXhDb21wb25lbnQodGhpcywgMywgZGF0YSA9PiB7XG4gICAgICAgIFZlYzMubmVnYXRlKHRoaXMudXAsIGRhdGEpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZG93bi5hcnJheVxuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGxlZnQgdmVjdG9yIG9mIHRoZSBtYXRyaXguICovXG4gIGdldCByaWdodCgpIHtcbiAgICBpZiAoIXRoaXMuX3JpZ2h0KSB7XG4gICAgICB0aGlzLl9yaWdodCA9IG5ldyBNYXRyaXhDb21wb25lbnQodGhpcywgMywgZGF0YSA9PiB7XG4gICAgICAgIFZlYzMubmVnYXRlKHRoaXMubGVmdCwgZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yaWdodC5hcnJheVxuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHJpZ2h0IHZlY3RvciBvZiB0aGUgbWF0cml4LiAqL1xuICBnZXQgbGVmdCgpIHtcbiAgICBpZiAoIXRoaXMuX2xlZnQpIHtcbiAgICAgIHRoaXMuX2xlZnQgPSBuZXcgTWF0cml4Q29tcG9uZW50KHRoaXMsIDMsIGRhdGEgPT4ge1xuICAgICAgICBWZWMzLm5vcm1hbGl6ZShWZWMzLmNyb3NzKHRoaXMudXAsIHRoaXMuZm9yd2FyZCwgZGF0YSksIGRhdGEpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGVmdC5hcnJheVxuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGZvcndhcmQgdmVjdG9yIG9mIHRoZSBtYXRyaXguICovXG4gIGdldCBmb3J3YXJkKCkge1xuICAgIGlmICghdGhpcy5fZm9yd2FyZCkge1xuICAgICAgdGhpcy5fZm9yd2FyZCA9IG5ldyBNYXRyaXhDb21wb25lbnQodGhpcywgMywgZGF0YSA9PiB7XG4gICAgICAgIFZlYzMubm9ybWFsaXplKFZlYzMuc2V0KHRoaXMuYXJyYXlbOF0sIHRoaXMuYXJyYXlbOV0sIHRoaXMuYXJyYXlbMTBdLCBkYXRhKSwgZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mb3J3YXJkLmFycmF5XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgYmFja3dhcmQgdmVjdG9yIG9mIHRoZSBtYXRyaXguICovXG4gIGdldCBiYWNrd2FyZCgpIHtcbiAgICBpZiAoIXRoaXMuX2JhY2t3YXJkKSB7XG4gICAgICB0aGlzLl9iYWNrd2FyZCA9IG5ldyBNYXRyaXhDb21wb25lbnQodGhpcywgMywgZGF0YSA9PiB7XG4gICAgICAgIFZlYzMubmVnYXRlKHRoaXMuZm9yd2FyZCwgZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9iYWNrd2FyZC5hcnJheVxuICB9XG5cbiAgY29weUZyb20obWF0cml4OiBUcmFuc2Zvcm1NYXRyaXgpIHtcbiAgICBpZiAobWF0cml4IGluc3RhbmNlb2YgVHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICBNYXQ0LmNvcHkobWF0cml4LmFycmF5LCB0aGlzLmFycmF5KTsgdGhpcy5fdHJhbnNmb3JtSWQrK1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJvdGF0aW9uLCBwb3NpdGlvbiBhbmQgc2NhbGUgY29tcG9uZW50cy4gXG4gICAqIEBwYXJhbSByb3RhdGlvbiBUaGUgcm90YXRpb24gdG8gc2V0LlxuICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIHNldC5cbiAgICogQHBhcmFtIHNjYWxpbmcgVGhlIHNjYWxlIHRvIHNldC5cbiAgICovXG4gIHNldEZyb21Sb3RhdGlvblBvc2l0aW9uU2NhbGUocm90YXRpb246IE9ic2VydmFibGVRdWF0ZXJuaW9uLCBwb3NpdGlvbjogT2JzZXJ2YWJsZVBvaW50M0QsIHNjYWxpbmc6IE9ic2VydmFibGVQb2ludDNEKSB7XG4gICAgVmVjNC5zZXQocm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueiwgcm90YXRpb24udywgdGhpcy5yb3RhdGlvbilcbiAgICBWZWMzLnNldChzY2FsaW5nLngsIHNjYWxpbmcueSwgc2NhbGluZy56LCB0aGlzLnNjYWxpbmcpXG4gICAgVmVjMy5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiwgdGhpcy5wb3NpdGlvbilcbiAgICBNYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUodGhpcy5yb3RhdGlvbiwgdGhpcy5wb3NpdGlvbiwgdGhpcy5zY2FsaW5nLCB0aGlzLmFycmF5KTsgdGhpcy5fdHJhbnNmb3JtSWQrK1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdCBvZiB0d28gbWF0cml4IHRyYW5zZm9ybXMuXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCBvcGVyYW5kLlxuICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIG9wZXJhbmQuXG4gICAqL1xuICBzZXRGcm9tTXVsdGlwbHkoYTogVHJhbnNmb3JtTWF0cml4LCBiOiBUcmFuc2Zvcm1NYXRyaXgpIHtcbiAgICBNYXQ0Lm11bHRpcGx5KGEuYXJyYXksIGIuYXJyYXksIHRoaXMuYXJyYXkpOyB0aGlzLl90cmFuc2Zvcm1JZCsrXG4gIH1cbn0iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCJcblxuaW1wb3J0IHsgVHJhbnNmb3JtTWF0cml4IH0gZnJvbSBcIi4vdHJhbnNmb3JtLW1hdHJpeFwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlUG9pbnQzRCB9IGZyb20gXCIuL29ic2VydmFibGUtcG9pbnRcIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZVF1YXRlcm5pb24gfSBmcm9tIFwiLi9vYnNlcnZhYmxlLXF1YXRlcm5pb25cIlxuaW1wb3J0IHsgTWF0NCB9IGZyb20gXCIuLi9tYXRoL21hdDRcIlxuaW1wb3J0IHsgVmVjMyB9IGZyb20gXCIuLi9tYXRoL3ZlYzNcIlxuXG4vKipcbiAqIEhhbmRsZXMgcG9zaXRpb24sIHNjYWxpbmcgYW5kIHJvdGF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtM0QgZXh0ZW5kcyBQSVhJLlRyYW5zZm9ybSB7XG5cbiAgLyoqIFRoZSBwb3NpdGlvbiBpbiBsb2NhbCBzcGFjZS4gKi9cbiAgcG9zaXRpb24gPSBuZXcgT2JzZXJ2YWJsZVBvaW50M0QodGhpcy5vbkNoYW5nZSwgdGhpcywgMCwgMCwgMClcblxuICAvKiogVGhlIHNjYWxlIGluIGxvY2FsIHNwYWNlLiAqL1xuICBzY2FsZSA9IG5ldyBPYnNlcnZhYmxlUG9pbnQzRCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAxLCAxLCAxKVxuXG4gIC8qKiBUaGUgcm90YXRpb24gaW4gbG9jYWwgc3BhY2UuICovXG4gIHJvdGF0aW9uUXVhdGVybmlvbiA9IG5ldyBPYnNlcnZhYmxlUXVhdGVybmlvbih0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwLCAwLCAxKVxuXG4gIC8qKiBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGluIHdvcmxkIHNwYWNlLiAqL1xuICB3b3JsZFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKVxuXG4gIC8qKiBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGluIGxvY2FsIHNwYWNlLiAqL1xuICBsb2NhbFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKVxuXG4gIC8qKiBUaGUgaW52ZXJzZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaW4gd29ybGQgc3BhY2UuICovXG4gIGludmVyc2VXb3JsZFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcblxuICAvKiogVGhlIG5vcm1hbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguICovXG4gIG5vcm1hbFRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1NYXRyaXgoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKSB7XG4gICAgaWYgKHRoaXMuX2xvY2FsSUQgPT09IHRoaXMuX2N1cnJlbnRMb2NhbElEKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5sb2NhbFRyYW5zZm9ybS5zZXRGcm9tUm90YXRpb25Qb3NpdGlvblNjYWxlKFxuICAgICAgdGhpcy5yb3RhdGlvblF1YXRlcm5pb24sIHRoaXMucG9zaXRpb24sIHRoaXMuc2NhbGUpXG5cbiAgICB0aGlzLl9wYXJlbnRJRCA9IC0xXG4gICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSB0aGlzLl9sb2NhbElEXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBwb3NpdGlvbiwgcm90YXRpb24gYW5kIHNjYWxlIGZyb20gYW4gbWF0cml4IGFycmF5LlxuICAgKiBAcGFyYW0gbWF0cml4IFRoZSBtYXRyaXggdG8gc2V0LlxuICAgKi9cbiAgc2V0RnJvbU1hdHJpeChtYXRyaXg6IFRyYW5zZm9ybU1hdHJpeCkge1xuICAgIHRoaXMubG9jYWxUcmFuc2Zvcm0uY29weUZyb20obWF0cml4KVxuXG4gICAgdGhpcy5wb3NpdGlvbi5zZXQodGhpcy5sb2NhbFRyYW5zZm9ybS5wb3NpdGlvblswXSwgdGhpcy5sb2NhbFRyYW5zZm9ybS5wb3NpdGlvblsxXSwgdGhpcy5sb2NhbFRyYW5zZm9ybS5wb3NpdGlvblsyXSlcbiAgICB0aGlzLnNjYWxlLnNldCh0aGlzLmxvY2FsVHJhbnNmb3JtLnNjYWxpbmdbMF0sIHRoaXMubG9jYWxUcmFuc2Zvcm0uc2NhbGluZ1sxXSwgdGhpcy5sb2NhbFRyYW5zZm9ybS5zY2FsaW5nWzJdKVxuICAgIHRoaXMucm90YXRpb25RdWF0ZXJuaW9uLnNldCh0aGlzLmxvY2FsVHJhbnNmb3JtLnJvdGF0aW9uWzBdLCB0aGlzLmxvY2FsVHJhbnNmb3JtLnJvdGF0aW9uWzFdLCB0aGlzLmxvY2FsVHJhbnNmb3JtLnJvdGF0aW9uWzJdLCB0aGlzLmxvY2FsVHJhbnNmb3JtLnJvdGF0aW9uWzNdKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHdvcmxkIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICogQHBhcmFtIHBhcmVudFRyYW5zZm9ybSBUaGUgcGFyZW50IHRyYW5zZm9ybS5cbiAgICovXG4gIHVwZGF0ZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0/OiBQSVhJLlRyYW5zZm9ybSkge1xuICAgIHRoaXMudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKVxuICAgIGlmIChwYXJlbnRUcmFuc2Zvcm0gJiYgdGhpcy5fcGFyZW50SUQgPT09IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChwYXJlbnRUcmFuc2Zvcm0gaW5zdGFuY2VvZiBUcmFuc2Zvcm0zRCkge1xuICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5zZXRGcm9tTXVsdGlwbHkocGFyZW50VHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCB0aGlzLmxvY2FsVHJhbnNmb3JtKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmNvcHlGcm9tKHRoaXMubG9jYWxUcmFuc2Zvcm0pXG4gICAgfVxuICAgIE1hdDQuaW52ZXJ0KHRoaXMud29ybGRUcmFuc2Zvcm0uYXJyYXksIHRoaXMuaW52ZXJzZVdvcmxkVHJhbnNmb3JtLmFycmF5KVxuICAgIE1hdDQudHJhbnNwb3NlKHRoaXMuaW52ZXJzZVdvcmxkVHJhbnNmb3JtLmFycmF5LCB0aGlzLm5vcm1hbFRyYW5zZm9ybS5hcnJheSlcbiAgICB0aGlzLl93b3JsZElEKytcbiAgICBpZiAocGFyZW50VHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLl9wYXJlbnRJRCA9IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVzIHRoZSB0cmFuc2Zvcm0gc28gdGhlIGZvcndhcmQgdmVjdG9yIHBvaW50cyBhdCBzcGVjaWZpZWQgcG9pbnQuXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gbG9vayBhdC5cbiAgICogQHBhcmFtIHVwIFRoZSB1cHdhcmQgZGlyZWN0aW9uLlxuICAgKi9cbiAgbG9va0F0KHBvaW50OiBPYnNlcnZhYmxlUG9pbnQzRCwgdXAgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwXSkpIHtcbiAgICBsZXQgcm90ID0gTWF0NC5nZXRSb3RhdGlvbihcbiAgICAgIE1hdDQudGFyZ2V0VG8ocG9pbnQuYXJyYXksIHRoaXMud29ybGRUcmFuc2Zvcm0ucG9zaXRpb24sIHVwKSlcbiAgICB0aGlzLnJvdGF0aW9uUXVhdGVybmlvbi5zZXQocm90WzBdLCByb3RbMV0sIHJvdFsyXSwgcm90WzNdKVxuICB9XG59IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3BpeGlfanNfXzsiXSwic291cmNlUm9vdCI6IiJ9